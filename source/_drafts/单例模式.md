---
title: 单例模式
date: 2019-11-16 14:32:26
tags: 设计模式
categories: 设计模式
---

## 前言

单例模式是应用最广的模式之一也是最简单的模式，在应用，这个模式时，单例对象的类必须保证只有一个实例存在。比如在一个应用中，应该只有一个Imageloader实例，这个实例中又含线程池，缓存系统，网路请求等，很消耗资源，因此，没有理由让它构造多个实例，这种不能自由的构造对象的情况，就是单例模式的使用场景。

## 定义

确保某一个类中只有一个实例，而且自行实例化，并向整个系统提供这个实例。

## 使用场景

确保某一个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象应该有且只有一个。例如一个对象的创建需要消耗的资源过多，如要访问IO，数据库等，这时就要考虑使用单例模式。

## 类图

{% asset_img design.png design%}

角色介绍：

- Client - 高端客户层
- Singleton - 单例类

实现单例模式的关键点：

（1）构造函数私有

（2）通过一个静态方法或枚举返回单例对象

（3）确保单例类的实例只有一个，在多线程环境下

（4）确保单例类反序化时不会重新创建对象

下面以公司来举例，Staff是一个抽象员工类，一个公司里只能有一个CEO，所以适合用单例模式实现。

## 实现方式

### 1、饿汉方式

```java
public class CEO1 extends Staff {
    
    //静态对象
    private static final CEO1 mCeo = new CEO1();
    //构造函数私有
    private CEO1(){}
    
    @Override
    public void doWork() {
        Log.d(TAG, "doWork: 我是CEO1");
    }
    
    //公有的静态函数，对外暴露获取单例对象的接口
    public static CEO1 getCEO(){
        return mCeo;
    }
}
```

### 2、懒汉模式

```java
public class CEO2 extends Staff {

    private static CEO2 mCeo;

    private CEO2(){}

    @Override
    public void doWork() {

    }
    
    public static synchronized CEO2 getInstance(){
        if(mCeo == null){
            mCeo = new CEO2();
        }
        return mCeo;
    }
}
```

getInstance()加了synchronized关键字，这是在多线程环境下保持单例唯一性的手段。懒汉模式的优点是单例只有在使用时才会被实例化，节约资源；缺点是第一次加载时需要及时进行实例化，反应稍慢，每次调用getInstance()时都进行同步，造成不必要的同步开销。这种模式不建议使用。

### 3、Double Check Lock（DCL）

```java
public class CEO3 extends Staff {
    
    private static CEO3 mCeo = null;
    
    private CEO3(){}
    
    @Override
    public void doWork() {
        
    }
    
    public static CEO3 getInstance(){
        if(mCeo == null){
            synchronized (CEO3.class){
                if(mCeo == null){
                    mCeo = new CEO3();
                }
            }
        }
        return mCeo;
    }
    
}
```

在getInstance()中对实例进行了俩次判空：第一次判空是为了避免不必要的同步；第二次判空则是为了在null的情况下创建实例。DCL优点是资源利用率高，第一次执行getInstance（）时单例对象才会被实例化，并且能在大多数情况下保证单例唯一性；缺点是第一次加载反应稍慢。

关于为什么进行两个判空和如何进一步优化DCL，可以看这一篇文章[多线程问题与double-check小结](http://blog.sina.cn/dpool/blog/s/blog_597a437101011o66.html)。

### 4、静态内部类形式

```java
public class CEO4 extends Staff {
    
    private CEO4(){}
    
    public static CEO4 getInstanse(){
        return SingletonHolder.mCeo;
    }
    
    @Override
    public void doWork() {}

    /**
     * 静态内部类
     */
    private static class SingletonHolder{
        private static final CEO4 mCeo = new CEO4();
    }
    
}
```

当第一次加载CEO4类时并不会初始化mCeo，只有在调用getInstance（）时才会导致mCeo实例化，因此第一次调用getInstance时会导致虚拟机加载SingletonHolder类。这种方式的优点是不仅能保证线程安全，也能保证单例对象的唯一性，同时也延迟了单例的实例化，所以这是推荐使用的单例模式。

### 5、枚举模式

```java
public enum CEO5{
    INSTANCE;
    public void doSomething(){
        System.out.println("do Something");
    }
}
```

写法简单是枚举单例最大的优点，枚举实例的创建默认是线程安全的，并且任何情况下它都是一个单例。

上面的几种单例模式实现中，只有一种情况下它们会出现重新创建对象的情况，那就是反序列化，如果在上面的模式中杜绝反序列化重新创建对象，那么要在类中加入以下方法：

```java
private Object readResolve() throws ObjectStreamException {
        return mCeo;
 }
```

也就是在readResolve（）将单例对象返回，而不是默认的重新创建一个新的对象，而对于枚举就不存在这样的情况，即使反序列化也不会重新生成实例。

### 6、使用容器实现单例模式

```java
public class SingletonManager extends Staff {
    
    private static Map<String, Object> objMap = new HashMap<>();
    
    private SingletonManager(){}
    
     public static void registerService(String key, SingletonManager instance){
        if(!objMap.containsKey(key)){
            objMap.put(key, instance);
        }
    }
    
    public static Object getService(String key){
        return objMap.get(key);
  }
```

在程序初始时，将多种类型的单例注入到一个统一的管理类中，在使用时根据key可以获取对象对应的单例，这种方式可以让我们管理多种类型的单例，并且使用时通过统一的接口进行获取，例如在Android中，各种类型的服务都注册在Context内的一个容器中，我们可以通过Context的getService方法获得服务的单例，因为服务不能重复创建，会很消耗资源。

## 总结

不管使用哪种形式实现单例，其核心思想是构造函数私有化，并且通过静态方法获取单例，在这个过程中要保证线程安全，避免反序列化重新生成实例等问题。单例模式是使用频率最高的模式，推荐使用DCL和静态内部类形式模式**。**

[本文源码相关位置](https://github.com/rain9155/DesignPatternDemo/tree/master/src/com/example/hy/designpatternDemo/singleton)

