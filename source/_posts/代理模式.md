---
title: 代理模式
date: 2019-10-15 20:05:03
tags: 设计模式
categories: 设计模式
---

## 介绍
代理模式，也称委托模式，何为代理呢? 在日常生活中就比如叫朋友替你拿个快递，叫朋友替你做一下作业，叫朋友替你买点东西等等，这个朋友就是你的代理，你把事情委托你的朋友做了，是不是很通熟易懂。同样在代码的世界中也存在代理，而且在你以后阅读到更多的设计模式时，你会发现很多的设计模式中也有代理模式的影子。
## 定义
为其他对象提供一种代理以控制这个对象的访问。
## 使用场景
当不想访问某个对象或访问某个对象存在困难时，就可以为这个对象创建一个代理，通过代理来间接的访问这个对象，而且这个对象和代理对象需要实现相同的接口。
## 类图

{% asset_img design1.png design %}

角色介绍:

* Subject --- 抽象主题类，定义了代理对象和真实对象的共同接口方法，既可以是接口也可以是抽象类。
* RealSubject --- 真实主题类，该类可以被称为被委托类或被代理类，该类定义了代理对象所表示的真实对象，实现了Subject接口，而Client端通过代理类间接的调用的真实主题类中的方法，由其执行真正的业务逻辑。
* ProxySubject --- 代理类，该类也被称为委托类或代理类，该类中持有一个真实主题类的引用，同样实现了Subject接口，在其实现的接口方法中调用真实主题类中相应的接口方法，以此起到代理的作用。
* Client --- 客户端，使用代理的类型。

>代理模式分为静态代理和动态代理，下面分别介绍。

## 简单示例
小明想要在大城市租房，但是他平时很忙没有时间去看房，于是他就找到一个房产中介，把自己的租房意愿告诉房产中介，让房产中介来替自己解决租房问题，很明显房产中介就是代理人，小明就是被代理的人。
### 1、静态代理
我们先用静态代理来实现这个过程，首先定义一个租房步骤过程接口:

租房步骤过程接口，即Subject角色
```java
public interface IRoom {
    void seekRoom();//找房
    void watchRoom();//看房
    void room();//给钱租房
    void finish();//完成租房
}
```
4个步骤完成租房，很简单，然后我们定义具体的想要租房的人即小明:

想要租房的小明，即RealSubject角色
```java
public class XiaoMing implements IRoom {
    
    @Override
    public void seekRoom() {
        System.out.println("找房");
    }

    @Override
    public void watchRoom() {
        System.out.println("看房");
    }

    @Override
    public void room() {
        System.out.println("给钱租房");
    }

    @Override
    public void finish() {
        System.out.println("完成租房");
    }
}
```
该类实现了IRoom接口，实现了其中的具体逻辑，但是小明并不会自己去打租房，他委托房产中介去做，所以这里定义一个房产中介:

代理人房产中介，即ProxySubject角色
```java
public class RoomAgency implements IRoom {
    
    private IRoom mRoom;//持有一个具体被代理人的引用
    
    public RoomAgency(IRoom room){
        this.mRoom = room;
    }
    
    @Override
    public void seekRoom() {
        mRoom.seekRoom();
    }

    @Override
    public void watchRoom() {
        mRoom.watchRoom();
    }

    @Override
    public void room() {
        mRoom.room();
    }

    @Override
    public void finish() {
        mRoom.finish();
    }
}
```
在该类中会持有一个具体被代理人的引用，在这里指小明，可以看到房产中介所执行的方法的实质就是简单的调用具体被代理人中的方法，下面来看看Client中具体的执行关系:

客户端，即Client角色
```java
public class Client {
    public static void main(String[] args){
        //小明想租房
        XiaoMing xiaoMing = new XiaoMing();
        //找一个代理人，房产中介
        RoomAgency roomAgency = new RoomAgency(xiaoMing);
        //房产中介找房
	roomAgency.watchRoom();
        //房产中介看房
        roomAgency.seekRoom();
        //房产中介租房
        roomAgency.room();
        //房产中介完成租房
        roomAgency.finish();
    }
}
```
输出结果:
```java
看房
找房
给钱租房
完成租房
```
上面就是傻瓜式的过程，一看就懂，可以看到代理模式还是很简单，就是一种委托机制，真实对象将方法委托给代理对象。那么房产中介代理其他人可以吗? 可以的，比如我们再定义一个XiaoMong实现IRoom接口，并在Client中修改逻辑就行。

静态代理就像上述步骤那样，也就是说在我们的代码运行前，代理类的class编译文件就已经存在。而动态代理则与静态代理相反，通过反射机制动态生成代理者对象，也就是说，我们在代码运行时才知道要代理谁。下面我们来通过动态代理实现上述过程。
### 2、动态代理
java提供了动态代理接口InvocationHandler, 定义如下：
```java
public interface InvocationHandler {
  Object invoke(Object proxy, Method method, Object[] args）throws Throwable;
}
```
里面只有一个invoke方法，我们需要实现其接口并重写该方法，我们先定义一个动态代理类, 如下:

动态代理类
```java
public class DynamicProxy implements InvocationHandler {

    private Object mObject;//具体被代理类的引用
    
    public DynamicProxy(Object object){
        this.mObject = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //调用被代理类对象的方法
        Object result = method.invoke(mObject, args);
        return result;
    }
}
```
在该类中，我们声明了一个Object引用，该引用指向被代理类，而我们调用被代理类的具体方法则在invoke方法中执行。也就是说原来静态代理中代理类所做的工作现在由InvocationHandler来处理，而且不再需要关心到底代理谁。下面时Client端逻辑:
```java
public class Client2 {
    public static void main(String[] args) {
        //构造一个小明
        IRoom xiaoMing = new XiaoMing();
        //构造一个动态代理
        DynamicProxy dynamicProxy = new DynamicProxy(xiaoMing);
        //获取被代理类小明的ClassLoader
        ClassLoader classLoader = xiaoMing.getClass().getClassLoader();
        //动态构造一个代理人房产中介
        IRoom roomAgency = (IRoom) Proxy.newProxyInstance(classLoader, new Class[]{IRoom.class}, dynamicProxy);
        //房产中介找房
        roomAgency.watchRoom();
        //房产中介看房
        roomAgency.seekRoom();
        //房产中介租房
        roomAgency.room();
        //房产中介完成租房
        roomAgency.finish();
    }
}

```
运行结果和前面的静态代理一致，可以看到动态代理也可以通过一个代理类来代理多个被代理类，其实质是通过接口将代理类与被代理类进行解耦，使得两者没有直接的耦合关系。
## 结语
代理模式应用广泛，静态代理只能为给定接口下的实现类做代理，如果接口不一样那么就要重新定义不同的代理类，较为复杂。而动态代理如果接口不一样并不需要重新定义不同的代理类，它始终通过同一个代理类InvocationHandler来代理，较为灵活。但是在实际开发中还是要根据实际情况进行选择。

[本文源码位置](https://github.com/rain9155/DesignPatternDemo/tree/master/src/com/example/hy/designpatternDemo/proxy)