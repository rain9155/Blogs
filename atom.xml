<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jianyu的博客</title>
  <icon>https://www.gravatar.com/avatar/6784cdf8051a915bd150c93df8defed3</icon>
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-08T09:57:30.688Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rain9155</name>
    <email>jianyu9155@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从进程的角度看Android的系统架构</title>
    <link href="http://yoursite.com/2019/10/08/%E4%BB%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BAndroid%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/10/08/从进程的角度看Android的系统架构/</id>
    <published>2019-10-08T08:32:55.000Z</published>
    <updated>2019-10-08T09:57:30.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一篇文章<a href="https://blog.csdn.net/Rain_9155/article/details/82889613" target="_blank" rel="noopener">Android的系统架构概述</a></li></ul><p>上一篇文章从5个层次简述了Android的系统架构，那么这5个层次是怎么联系起来的呢？本文从进程的角度看Android的系统架构，简述一下Android系统启动的过程中，各大进程的启动顺序是如何的，本文并不会涉及到任何源码，只是为了让读者对Android的进程有个大概的了解。</p><a id="more"></a><p>先看一张图：</p><img src="/2019/10/08/从进程的角度看Android的系统架构/android1.jpg" title="android"><p>从这张图中可以找到Android官方给出的5个层次（Application、Framework（java）、库和运行时（native）、HAL、Kernel）的影子，java层与native层之间通过<strong>JNI调用</strong>打通，native层与kernel层通过<strong>Syscall调用</strong>打通。这个图就是你启动Android手机时Android系统的启动过程，下面从下到上分别介绍：</p><h2 id="1、系统启动（Loader）"><a href="#1、系统启动（Loader）" class="headerlink" title="1、系统启动（Loader）"></a>1、系统启动（Loader）</h2><p>长按电源键开机键：</p><h3 id="1-1-Boot-ROM"><a href="#1-1-Boot-ROM" class="headerlink" title="1.1 Boot ROM"></a>1.1 Boot ROM</h3><p>引导芯片代码固化在<strong>ROM</strong>中，当你长按电源键开机时，会引导引导芯片代码从预定义的代码处开始执行，然后加载引导程序Boot Loader到<strong>RAM</strong>中。</p><h3 id="1-2-Boot-Loader"><a href="#1-2-Boot-Loader" class="headerlink" title="1.2 Boot Loader"></a>1.2 Boot Loader</h3><p>Boot Loader是Android系统启动之前的引导程序，顾名思义，就是将系统拉起来并启动。</p><h2 id="2、Linux内核启动（Kernel）"><a href="#2、Linux内核启动（Kernel）" class="headerlink" title="2、Linux内核启动（Kernel）"></a>2、Linux内核启动（Kernel）</h2><p>然后就到了Linux内核启动，内核启动时就会启动两个进程 — swapper（pid=0），kthreadd（pid=2）：</p><h3 id="2-1、swapper（pid-0）"><a href="#2-1、swapper（pid-0）" class="headerlink" title="2.1、swapper（pid=0）"></a>2.1、swapper（pid=0）</h3><p>swapper进程又称idle进程， 是系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作。</p><h3 id="2-2、kthreadd（pid-2）"><a href="#2-2、kthreadd（pid-2）" class="headerlink" title="2.2、kthreadd（pid=2）"></a>2.2、kthreadd（pid=2）</h3><p>kthreadd是Linux系统的内核进程，是所有内核进程的鼻祖，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。</p><h2 id="3、init进程启动（Native）"><a href="#3、init进程启动（Native）" class="headerlink" title="3、init进程启动（Native）"></a>3、init进程启动（Native）</h2><p>init进程是Linux系统的用户进程，它的pid=1，是所有用户进程的鼻祖，它是由许多源码文件组成的，它对应的源码目录在/system/core/init中。init进程有许多重要的职责：</p><ul><li>孵化出许多用户空间的守护进程（ueventd、logd、healthd、installd、adbd、lmkd）</li><li>启动ServiceManager(binder服务管家)、bootanim(开机动画)等重要服务</li><li>孵化出Media Server进程，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。</li><li>孵化出Zygote进程<h2 id="4、Zygote进程启动（Native-gt-java-Framework）"><a href="#4、Zygote进程启动（Native-gt-java-Framework）" class="headerlink" title="4、Zygote进程启动（Native -&gt; java Framework）"></a>4、Zygote进程启动（Native -&gt; java Framework）</h2>Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程，它是由init进程通过解析init.rc文件后fork生成的，Zygote的启动脚本放在/system/core/rootdir目录中。Zygote进程的职责主要有：</li><li>创建JVM虚拟机，并为JVM注册JNI方法</li><li>响应AMS的请求去创建新的应用进程</li><li>孵化出SystemServer进程<h2 id="5、SystemServer进程启动（java-Framework）"><a href="#5、SystemServer进程启动（java-Framework）" class="headerlink" title="5、SystemServer进程启动（java Framework）"></a>5、SystemServer进程启动（java Framework）</h2>SystemServer进程是Zygote孵化的第一个进程，负责创建系统服务如ActivityManagerService，WindowManagerService，PackageManagerService，InputManagerService等服务，和管理整个Java framework。SystemServer进程的职责主要有：</li><li>创建Binder线程池，这样就可以与其他进程进行跨进程通信</li><li>启动SystemServiceManger，它用来对系统服务进行创建、管理和启动</li><li>通过SystemServiceManger启动各种系统服务：引导服务（如AMS，PMS），核心服务，其他服务（如WMS，IMS）<h2 id="6、Launcher进程启动（Application）"><a href="#6、Launcher进程启动（Application）" class="headerlink" title="6、Launcher进程启动（Application）"></a>6、Launcher进程启动（Application）</h2>SystemServer进程启动的过程中会启动PMS和AMS，PMS会把系统中的应用程序安装完成，然后AMS会请求Zygote将Launcher启动起来，这就是用户看到的app桌面，然后Launcher会将已经安装了的应用的应用图标显示出来。Launcher进程是Zygote进程孵化出来的第一个App进程。<br>至此Android系统已经启动完毕，用户就可以点进桌面上的应用图标进入app，对于普通的app进程,跟SystemServer进程的启动过来有些类似，不同的是app进程是先发消息给SystemServer进程，由SystemServer向Zygote发出创建进程的请求，而SystemServer是由Zygote直接fork出来，前面已经说过Zygote是所有Java进程的父进程，SystemServer和所有的app进程都是由Zygote进程的子进程。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Android系统底层基于Linux Kernel, 当Kernel启动过程会创建init进程, 该进程是所有用户空间的鼻祖,<br>init进程会启动ServiceManager(binder服务管家)、Zygote进程(Java进程的鼻祖)，Zygote进程会创建<br>system_server进程以及各种app进程，下图是这几个系统重量级进程之间的层级关系。</p><p>从下而上，其中binder和socket都是Android中进程间的通信方式，而ServiceManager是binder服务的大管家，系统服务的binder实体都会注册到它身上。本文并没有深入的了解各个进程的启动，只是简单的让大家对Android系统主要的进程有个大概的了解，这样以后去研究相应的进程的源码时就会有个大概的方向。</p><p>参考资料：</p><p><a href="http://gityuan.com/2016/02/01/android-booting/" target="_blank" rel="noopener">Android系统启动-综述</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一篇文章&lt;a href=&quot;https://blog.csdn.net/Rain_9155/article/details/82889613&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android的系统架构概述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上一篇文章从5个层次简述了Android的系统架构，那么这5个层次是怎么联系起来的呢？本文从进程的角度看Android的系统架构，简述一下Android系统启动的过程中，各大进程的启动顺序是如何的，本文并不会涉及到任何源码，只是为了让读者对Android的进程有个大概的了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://yoursite.com/2019/09/07/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/07/工厂模式/</id>
    <published>2019-09-07T11:47:08.000Z</published>
    <updated>2019-09-07T11:57:45.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工厂方法模式是一种结构简单的模式，并且在我们的应用中很广泛，如Android中Activity的各个生命周期的回调，以onCreate方法为例，它就可以看做是一个工厂方法，我们在其中构造我们的View并返回给framework处理。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪个类。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂方法模式，用new就能完成创建的对象无需使用工厂方法模式。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>角色介绍：</p><ul><li>Factory - 抽象工厂，是工厂方法的核心</li><li>ConcreteFactory - 具体工厂，实现了业务逻辑</li><li>Product - 抽象产品，是工厂方法模式所创建的产品的父类</li><li>ConcreteProduct - 为实现抽象产品的某个具体产品</li></ul><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>下面生产汽车为例，要生产三款汽车，于是使用一条生产线来生产，我们先定义产品，产品是汽车。</p><p>抽象汽车，即抽象产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是具体的车型</p><p>奥迪汽车，即具体的产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiCar</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"奥迪汽车开始启动啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奔驰汽车，即具体的产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzCar</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"奔驰车开始启动啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宝马汽车，即具体的产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BWMCar</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"宝马汽车开始启动啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了产品就要有工厂来生产，定义一个汽车抽象工厂。</p><p>抽象汽车工厂，即抽象工厂角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是具体的车型工厂。</p><p>生产奥迪车的工厂，即具体工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AudiCar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产奔驰车的工厂，即具体工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BenzCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产宝马车的工厂，即具体工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BWMCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BWMCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们将各个汽车的生产组装成一条生产线。</p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//制造各个工厂</span></span><br><span class="line">        CarFactory audiFactory = <span class="keyword">new</span> AudiCarFactory();</span><br><span class="line">        CarFactory benzFactory = <span class="keyword">new</span> BenzCarFactory();</span><br><span class="line">        CarFactory bwmFactory = <span class="keyword">new</span> BWMCarFactory();</span><br><span class="line">        <span class="comment">//生产各种车</span></span><br><span class="line">        Car audiCar = audiFactory.createCar();</span><br><span class="line">        Car benzCar = benzFactory.createCar();</span><br><span class="line">        Car bwmCar = bwmFactory.createCar();</span><br><span class="line">        <span class="comment">//车启动</span></span><br><span class="line">        audiCar.drive();</span><br><span class="line">        benzCar.drive();</span><br><span class="line">        bwmCar.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line">奥迪汽车开始启动啦！</span><br><span class="line">奔驰车开始启动啦！</span><br><span class="line">宝马汽车开始启动啦！</span><br></pre></td></tr></table></figure><p>可以看到我们需要哪种车型就可以定义哪种车型的具体工厂，像这样拥有多个工厂的的方式我们称之为多工厂模式，每个工厂各司其职。</p><p>但上面的方式不好的是会产生大量工厂，使代码臃肿，在实际开发中，我们可以使用反射的方式更加简洁的来生产具体的产品对象，此时需要在工厂方法的参数列表中传入一个Class类来决定是哪一个产品类。</p><p>使用反射的方式来生产具体的产品对象，抽象工厂角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象工厂方法，具体生产什么产品由子类决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Car&gt; <span class="function">T <span class="title">createCar</span><span class="params">(Class&lt;T&gt; car)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 具体的工厂，则通过反射获取类的实例即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Car&gt; <span class="function">T <span class="title">createCar</span><span class="params">(Class&lt;T&gt; car)</span> </span>&#123;</span><br><span class="line">        Car c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = (T) Class.forName(car.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建工厂</span></span><br><span class="line">        CarFactory2 carFactory = <span class="keyword">new</span> ConcreteCarFactory2();</span><br><span class="line">        <span class="comment">//生产车</span></span><br><span class="line">        AudiCar audiCar = carFactory.createCar(AudiCar.class);</span><br><span class="line">        BenzCar benzCar = carFactory.createCar(BenzCar.class);</span><br><span class="line">        BWMCar bwmCar = carFactory.createCar(BWMCar.class);</span><br><span class="line">        <span class="comment">//车启动</span></span><br><span class="line">        audiCar.drive();</span><br><span class="line">        benzCar.drive();</span><br><span class="line">        bwmCar.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出和和上面一样，使用反射的方式，需要哪一个产品的对象，就传入哪一个产品的类的型即可，这种方式比较简洁，动态。</p><p>上面我们有三个工厂，如果我们只需要生产一种车型，即我们只有一个工厂时，我们就可以把抽象工厂简化掉，将对应的工厂方法改为静态方法，像下面，我们只生产一辆五菱车。</p><p>一个工厂，只生产一种产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createWuLingCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WuLingCar();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样的方式又称为简单工厂方式或静态工厂方式，它是工厂方式模式的一个弱化版本。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工厂模式依赖于抽象的架构，将实例化的具体任务交给子类去完成，有非常好的扩展性。</p><p><a href="https://github.com/rain9155/DesignPatternDemo/tree/master/src/com/example/hy/designpatternDemo/factory" target="_blank" rel="noopener">本文源码相关位置</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工厂方法模式是一种结构简单的模式，并且在我们的应用中很广泛，如Android中Activity的各个生命周期的回调，以onCreate方法为例，它就可以看做是一个工厂方法，我们在其中构造我们的View并返回给framework处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Builder模式</title>
    <link href="http://yoursite.com/2019/09/07/Builder%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/07/Builder模式/</id>
    <published>2019-09-07T11:35:25.000Z</published>
    <updated>2019-09-07T11:51:17.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Builder模式是一步步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更加精准的控制对象的构造过程，为了在构建过程中，对外部隐藏实现细节，就可以使用Builder模式将部件和组装过程分离，使得构建过程和部件可以自由扩展，两者之间的耦合度也降到最低。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>（1）相同的方法不同的执行顺序产生不同的事件结果时</p><p>（2）多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不同时</p><p>（3）产品类比较复杂或者产品类中的调用顺序不同产生不同的作用时</p><p>（4）当初始化一个对象非常复杂，如参数非常多，且很多参数都具有默认值时</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="/2019/09/07/Builder模式/design1.png" title="design"><p>类图介绍：</p><ul><li>Produc - 产品的抽象类</li><li>Builder - 抽象的Builder类，规范产品的组建，一般由子类实现具体的组建过程</li><li>ConcreteBuilder - 具体的Builder类</li><li>Director - 统一组装过程</li></ul><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>计算机的组装过程比较复杂且组装顺序说不固定的，下面把计算机的组装过程简化为构建主机，设置操作系统，设置显示器3部分，然后通过Director和具体Builder来构建计算机对象。</p><p>计算机抽象类，即Product</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String mBroad;<span class="comment">//主板</span></span><br><span class="line">    <span class="keyword">protected</span> String mDisplay;<span class="comment">//显示器</span></span><br><span class="line">    <span class="keyword">protected</span> String mOS;<span class="comment">//操作系统</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Computer</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置主板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> broad</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmBroad</span><span class="params">(String broad)</span></span>&#123;</span><br><span class="line">        mBroad = broad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置显示器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> display</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmDisplay</span><span class="params">(String display)</span></span>&#123;</span><br><span class="line">        mDisplay = display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置操作系统</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setmOS</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Computer &#123;mBroad = "</span> + mBroad + <span class="string">", mDisplay = "</span> + mDisplay + <span class="string">", mOS = "</span> + mOS + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苹果电脑，具体的Product</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Macbook</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mOS = <span class="string">"Mac OS X 10.10"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象Builder类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBroad</span><span class="params">(String broad)</span></span>;<span class="comment">//设置主机</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span></span>;<span class="comment">//设置显示器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span></span>;<span class="comment">//设置操作系统</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">create</span><span class="params">()</span></span>;<span class="comment">//创建Computer</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的Builder类，构造苹果电脑 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer mComputer = <span class="keyword">new</span> Macbook();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBroad</span><span class="params">(String broad)</span> </span>&#123;</span><br><span class="line">        mComputer.setmBroad(broad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">        mComputer.setmDisplay(display);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mComputer.setmOS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mComputer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Director类，负责构造Computer </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Builder mBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBuilder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> broad</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> display</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(String broad, String display)</span></span>&#123;</span><br><span class="line">        mBuilder.buildBroad(broad);</span><br><span class="line">        mBuilder.buildDisplay(display);</span><br><span class="line">        mBuilder.buildOS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> MacBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        director.construct(<span class="string">"英特尔主板"</span>, <span class="string">"Retina 显示器"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Computer Info: "</span> + builder.create().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果 :</span><br><span class="line">Computer Info: Computer &#123;mBroad = 英特尔主板, mDisplay = Retina 显示器, mOS = Mac OS X <span class="number">10.10</span>&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，通过具体的MacBuilder来构建Macbook对象，而Director封装构建复杂对象的过程，对外隐藏细节。Builder与Director一起将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。</p><p>但在现实开发中，Director常常被忽略，直接使用一个Builder对象来进行链式调用构造，它的关键点是每个setter返回自身，如下，我们来组装一个华硕电脑：</p><p>华硕电脑，具体的产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASUSbook</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mOS = <span class="string">"Windows 10 专业版"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象Builder类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder2 <span class="title">buildBroad</span><span class="params">(String broad)</span></span>;<span class="comment">//设置主机</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder2 <span class="title">buildDisplay</span><span class="params">(String display)</span></span>;<span class="comment">//设置显示器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder2 <span class="title">buildOS</span><span class="params">()</span></span>;<span class="comment">//设置操作系统</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">create</span><span class="params">()</span></span>;<span class="comment">//创建Computer</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的Builder类，构造ASUS电脑 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASUSBuilder</span> <span class="keyword">extends</span> <span class="title">Builder2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer mComputer = <span class="keyword">new</span> ASUSbook();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder2 <span class="title">buildBroad</span><span class="params">(String broad)</span> </span>&#123;</span><br><span class="line">        mComputer.setmBroad(broad);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder2 <span class="title">buildDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">        mComputer.setmDisplay(display);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder2 <span class="title">buildOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mComputer.setmOS();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mComputer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Builder2 builder2 = <span class="keyword">new</span> ASUSBuilder();</span><br><span class="line">        ASUSbook asusbook = (ASUSbook) builder2</span><br><span class="line">                .buildBroad(<span class="string">"AMDB350socketAM4"</span>)</span><br><span class="line">                .buildDisplay(<span class="string">"AOC 显示器"</span>)</span><br><span class="line">                .buildOS()</span><br><span class="line">                .create();</span><br><span class="line">        System.out.println(<span class="string">"Computer Info: "</span> + asusbook.toString());</span><br><span class="line"><span class="comment">//        Builder builder = new MacBuilder();</span></span><br><span class="line"><span class="comment">//        Director director = new Director(builder);</span></span><br><span class="line"><span class="comment">//        director.construct("英特尔主板", "Retina 显示器");</span></span><br><span class="line"><span class="comment">//        System.out.println("Computer Info: " + builder.create().toString());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果 :</span><br><span class="line">Computer Info: Computer &#123;mBroad = AMDB350socketAM4, mDisplay = AOC 显示器, mOS = Windows <span class="number">10</span> 专业版&#125;</span><br></pre></td></tr></table></figure><p>链式调用形式不仅去除Director角色，让整个结构简单，而且也能对product对象的组装过程有更加精准的控制。</p><p>然而上面的只是经典的实现方式，下面才是现在开发中最常用的，通过把Builder与产品类封装在一起，建立于上面的基础。</p><p>联想电脑，把Builder与产品类封装在一起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoBook</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LenovoBook</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        setmOS();</span><br><span class="line">        setmBroad(builder.broad);</span><br><span class="line">        setmDisplay(builder.display);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mOS = <span class="string">"Windows 10 家庭中文版"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Builder2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String broad;</span><br><span class="line">        String display;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder2 <span class="title">buildBroad</span><span class="params">(String broad)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.broad = broad;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder2 <span class="title">buildDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder2 <span class="title">buildOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Computer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LenovoBook(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       LenovoBook lenovoBook = (LenovoBook) <span class="keyword">new</span> LenovoBook.Builder()</span><br><span class="line">               .buildOS()</span><br><span class="line">               .buildBroad(<span class="string">"联想主板"</span>)</span><br><span class="line">               .buildDisplay(<span class="string">"联想显示器"</span>)</span><br><span class="line">               .create();</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"Computer Info: "</span> + lenovoBook.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Computer Info: Computer &#123;mBroad = 联想主板, mDisplay = 联想显示器, mOS = Windows <span class="number">10</span> 家庭中文版&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Builder模式在开发中很常用，通过把产品类的构造器，字段私有化，只能通过Builder来设置属性，也通常作为配置类的构造器将配置的构建与表示分离开来，同时也是将配置从目标类中独立出来，避免过多的setter方法。Builder模式常用的实现形式是链式调用。</p><p><a href="https://github.com/rain9155/DesignPatternDemo/tree/master/src/com/example/hy/designpatternDemo/builder" target="_blank" rel="noopener">本文源码相关位置</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Builder模式是一步步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更加精准的控制对象的构造过程，为了在构建过程中，对外部隐藏实现细节，就可以使用Builder模式将部件和组装过程分离，使得构建过程和部件可以自由扩展，两者之间的耦合度也降到最低。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="http://yoursite.com/2019/09/07/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/07/责任链模式/</id>
    <published>2019-09-07T08:46:01.000Z</published>
    <updated>2019-09-07T09:04:44.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>责任链模式是一种链式结构，就是由一个个节点首尾相接串起来的结构，具有很好的灵活性，将每一个节点看作是一个对象，每一个对象拥有不同的处理逻辑，将一个请求从链式的首端发出，沿着链的路径依此传递每一个节点对象，直到有对象处理这个请求为止，我们将这样一种模式称为责任链模式。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>1、多个对象可以处理同一请求，但具体哪个对象处理则是在运行时动态决定</li><li>2、在请求者不明确的情况下向多个对象中的一个提交一个请求</li><li>3、需要动态指定一组对象的处理请求</li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="/2019/09/07/责任链模式/design1.png" title="design"><p>角色介绍：</p><ul><li>AbstractHandler - 抽象处理者角色，声明一个请求处理的方法（handle（））、一个获得处理级别的方法（getHandlerLever（））和封装了一个对具体的处理转发逻辑实现的方法（handleRequest（)），并在其中保持对下一个处理节点的AbstractHandler对象的引用（nextHandler）</li><li>ConcreteHandler1、2 - 具体处理者角色，对请求进行处理，如果不能处理就将请求转发给下一个节点上的处理对象</li><li>AbstractRequest - 抽象的请求类，里面声明了一个获得请求内容的方法（getContent（））和一个获得请求处理级别的方法（getRequestLever（））</li><li>ConcreteRequest - 具体的请求类</li></ul><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>在一个公司中，员工拿到了一份合同，需要上级的签名，于是员工就把合同给组长，但是组长没有权限签名，于是组长就把合同给经理，但是经理也没有足够的权限签名，于是经理就把合同给老板，老板二话不说就把合同给签了。上面的例子就是责任链模式，员工是请求的发起者，处于链的底端，而老板是处于链条顶端的类，员工发起请求后，请求经过层层转发，直至请求被处理，员工只是和组长发生了关联，后面合同被谁处理，员工并不知道，也并不关心，他在乎的是合同签名的结果，责任链模式很好的将请求的发起者与处理者解耦，下面用代码来模拟。</p><p>抽象的员工，即AbstractHandler角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Staff nextHandler;<span class="comment">//上一级领导处理者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理转发的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Contract contract)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(contract.getContractLever() &lt; getHandlerLever())&#123;</span><br><span class="line">            handle(contract);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nextHandler != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nextHandler.handleRequest(contract);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getHandlerLever</span><span class="params">()</span></span>;<span class="comment">//自身能处理请求的级别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Contract contract)</span></span>;<span class="comment">//具体的处理过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个抽象的处理者中，一是定义了两个接口来确定一个Staff应有的行为和属性，二是封装了一个处理请求的逻辑转发方法，确定当前Staff是否有足够的级别来处理当前合同，如果没有，就把合同转发给上一级Staff，接下来是各个实现类。</p><p>组长，即ConcreteHandler角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CroupStaff</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHandlerLever</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Contract contract)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"组长签名了合同！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经理，即ConcreteHandler角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerStaff</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHandlerLever</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Contract contract)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"经理签名了合同！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老板，即ConcreteHandler角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BossStaff</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHandlerLever</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Contract contract)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老板签名了合同！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 接下来看一看请求，就是合同。</p><p>抽象的合同类，即AbstractRequest角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getContext</span><span class="params">()</span></span>;<span class="comment">//获得合同具体内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getContractLever</span><span class="params">()</span></span>;<span class="comment">//获得合同处理级别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最后员工从组长发起请求。</p><p>请求发起者，员工</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//构造各个节点对象</span></span><br><span class="line">        GroupStaff groupStaff = <span class="keyword">new</span> GroupStaff();</span><br><span class="line">        ManagerStaff managerStaff = <span class="keyword">new</span> ManagerStaff();</span><br><span class="line">        BossStaff bossStaff = <span class="keyword">new</span> BossStaff();</span><br><span class="line">        <span class="comment">//构成一条链</span></span><br><span class="line">        groupStaff.nextHandler = managerStaff;</span><br><span class="line">        managerStaff.nextHandler = bossStaff;</span><br><span class="line">        <span class="comment">//发起请求</span></span><br><span class="line">        Contract contract = <span class="keyword">new</span> ConcreteContract();</span><br><span class="line">        groupStaff.handleRequest(contract);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line">老板签名了合同！</span><br></pre></td></tr></table></figure><p> 其实这里也可以直接绕过组长和经理，直接找老板签名，这也是责任链模式的灵活性，请求的发起可以从任意节点发起，同时也可以改变责任链模式内部的传递规则，如直接找老板签名。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于责任链模式中的节点，有两个行为，一是处理请求，二是将请求转发给下一个节点，不允许某个节点处理者处理了请求后又把节点转发给下一个节点。对于责任链中的请求，只有俩个结果，一个是被某个节点处理，一个是所有对象均没有处理。</p><p><a href="https://github.com/rain9155/DesignPatternDemo/tree/master/src/com/example/hy/designpatternDemo/iterator" target="_blank" rel="noopener">本文相关源码位置</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;责任链模式是一种链式结构，就是由一个个节点首尾相接串起来的结构，具有很好的灵活性，将每一个节点看作是一个对象，每一个对象拥有不同的处理逻辑，将一个请求从链式的首端发出，沿着链的路径依此传递每一个节点对象，直到有对象处理这个请求为止，我们将这样一种模式称为责任链模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>okhttp3源码分析之拦截器</title>
    <link href="http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://yoursite.com/2019/09/07/okhttp3源码分析之拦截器/</id>
    <published>2019-09-07T07:01:40.000Z</published>
    <updated>2019-09-19T11:18:55.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一篇文章：<a href="https://rain9155.github.io/2019/09/03/okhttp3源码分析之请求流程/" target="_blank" rel="noopener">okhttp3源码分析之请求流程</a></li></ul><p>本篇文章继续通过源码来探讨okhttp的另外一个重要知识点：拦截器，在上一篇文章我们知道，在请求发送到服务器之前有一系列的拦截器对请求做了处理后才发送出去，在服务器返回响应之后，同样的有一系列拦截器对响应做了处理后才返回给发起请求的调用者，可见，拦截器是okhttp的一个重要的核心功能，在分析各个拦截器功能的同时又会牵扯出okhttp的缓存机制、连接机制。</p><blockquote><p>本文源码基于okhttp3.14.x</p></blockquote><p>okhttp项目地址：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsquare%2Fokhttp" target="_blank" rel="noopener">okhttp</a></p><a id="more"></a><h2 id="拦截器的简单使用"><a href="#拦截器的简单使用" class="headerlink" title="拦截器的简单使用"></a>拦截器的简单使用</h2><p>自定义一个拦截器需要实现Interceptor接口，接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//我们需要实现这个intercept(chain)方法，在里面定义我们的拦截逻辑</span></span><br><span class="line">  <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">     <span class="comment">//返回Request对象</span></span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用Chain的proceed(Request)方法处理请求，最终返回Response</span></span><br><span class="line">    <span class="function">Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前是网络拦截器，该方法返回Request执行后建立的连接</span></span><br><span class="line">    <span class="comment">//如果当前是应用拦截器，该方法返回null</span></span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回对应的Call对象</span></span><br><span class="line">    <span class="function">Call <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//下面的方法见名知意，返回或写入超时</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">connectTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Chain <span class="title">withConnectTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Chain <span class="title">withReadTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Chain <span class="title">withWriteTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到Interceptor由两部分组成：intercept(Chain)方法和内部接口Chain，下面是自定义一个拦截器的通用逻辑，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1、通过传进来的Chain获取Request</span></span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//2、 处理Request，逻辑自己写</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、调用Chain的proceed(Request)方法处理请求，得到Response</span></span><br><span class="line">        Response response = chain.proceed(request);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//4、 处理Response，逻辑自己写</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5、返回Response</span></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就是一个拦截器的通用逻辑，首先我们继承Interceptor实现intercept(Chain)方法，完成我们自己的拦截逻辑，即根据需要进行1、2、3、4、5步，不管是自定义拦截器还是后面介绍的okhttp默认的拦截器大概都是这个模板实现，定义完拦截器后，我们在构造OkhttpChient时就可以通过addInterceptor(Interceptor)或addNetworkInterceptor(Interceptor)添加自定义拦截器，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">     .addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">     .build();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">     .addNetworkInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">     .build();</span><br></pre></td></tr></table></figure><p>这样okhttp在链式调用拦截器处理请求时就会调用到我们自定义的拦截器，那么addInterceptor(Interceptor)和addNetworkInterceptor(Interceptor)有什么不一样呢？它们一个是添加应用拦截器，一个是添加网络拦截器，主要是调用的时机不一样，更多区别可以参考官方WIKI文档<a href="https://www.jianshu.com/p/2710ed1e6b48" target="_blank" rel="noopener">Okhttp-wiki 之 Interceptors 拦截器</a>，当我们平时做应用开发使用addInterceptor(Interceptor)就行了。</p><p>上述是我们自定义的拦截器，下面我们来看看okhttp默认的拦截器都干了什么。</p><h2 id="RealCall-getResponseWithInterceptorChain"><a href="#RealCall-getResponseWithInterceptorChain" class="headerlink" title="RealCall  :: getResponseWithInterceptorChain()"></a>RealCall  :: getResponseWithInterceptorChain()</h2><p>在上一篇文章知道RealCall的getResponseWithInterceptorChain()是处理、发送请求并且返回响应的地方，我们再看一遍getResponseWithInterceptorChain()方法的源码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.java</span></span><br><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//新建一个List用来保存拦截器</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加我们自定义的应用拦截器</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//添加负责重试重定向的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">    <span class="comment">//添加负责转换请求响应的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">//添加负责缓存的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//添加负责管理连接的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;<span class="comment">//没有特殊要求，不使用WebSocket协议，WebSocket是什么？自行百度</span></span><br><span class="line">      <span class="comment">//添加我们自定义的网络拦截器</span></span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加负责发起请求获取响应的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造第一个Chain</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//调用Chain的proceed(Request)方法处理请求</span></span><br><span class="line">      Response response = chain.proceed(originalRequest);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">//返回响应</span></span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>getResponseWithInterceptorChain()干了三件事：1、添加拦截器到interceptors列表中；2、构造第一个Chain；3、调用Chain的proceed(Request)方法处理请求。下面分别介绍:</p><h3 id="1、添加拦截器到interceptors列表中"><a href="#1、添加拦截器到interceptors列表中" class="headerlink" title="1、添加拦截器到interceptors列表中"></a>1、添加拦截器到interceptors列表中</h3><p>除了添加我们自定义的拦截器外，还添加了默认的拦截器，如下：</p><ul><li>1、RetryAndFollowUpInterceptor：负责失败重试和重定向。</li><li>2、BridgeInterceptor：负责把用户构造的Request转换为发送给服务器的Request和把服务器返回的Response转换为对用户友好的Response。</li><li>3、CacheInterceptor：负责读取缓存以及更新缓存。</li><li>4、ConnectInterceptor：负责与服务器建立连接并管理连接。</li><li>5、CallServerInterceptor：负责向服务器发送请求和从服务器读取响应。</li></ul><p>这几个默认的拦截器是本文的重点，在后面会分别介绍。</p><h3 id="2、构造第一个Chain"><a href="#2、构造第一个Chain" class="headerlink" title="2、构造第一个Chain"></a>2、构造第一个Chain</h3><p>Chain是Interceptor的一个内部接口，它的实现类是RealInterceptorChain，我们要对它的传进来的前6个构造参数有个印象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Chain</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors, Transmitter transmitter, @Nullable Exchange exchange, <span class="keyword">int</span> index, Request request, Call call, <span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interceptors = interceptors;<span class="comment">//interceptors列表</span></span><br><span class="line">        <span class="keyword">this</span>.transmitter = transmitter;<span class="comment">//Transmitter对象，后面会介绍</span></span><br><span class="line">        <span class="keyword">this</span>.exchange = exchange;<span class="comment">//Exchange对象，后面会介绍</span></span><br><span class="line">        <span class="keyword">this</span>.index = index;<span class="comment">//interceptor索性，用于获取interceptors列表中的interceptor</span></span><br><span class="line">        <span class="keyword">this</span>.request = request;<span class="comment">//请求request</span></span><br><span class="line">        <span class="keyword">this</span>.call = call;<span class="comment">//Call对象</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后面的拦截器中都可以通过Chain获取这些传进来的参数。我们知道，为了让每个拦截器都有机会处理请求，okhttp使用了责任链模式来把各个拦截器串联起来，拦截器就是责任链的节点，而Chain就是责任链中各个节点之间的连接点，负责把各个拦截器连接起来。那么是怎么连接的？看下面的Chain的proceed方法。</p><h3 id="3、调用Chain的proceed-Request-方法处理请求"><a href="#3、调用Chain的proceed-Request-方法处理请求" class="headerlink" title="3、调用Chain的proceed(Request)方法处理请求"></a>3、调用Chain的proceed(Request)方法处理请求</h3><p>实际是RealInterceptorChain的proceed(Request)方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Chain</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proceed(request, transmitter, exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//index不能越界</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//再新建一个Chain，这里注意index加1，</span></span><br><span class="line">        RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">                                                             index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取interceptors列表中的下一个拦截器</span></span><br><span class="line">        Interceptor interceptor = interceptors.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用下一个拦截器的intercept(Chain)方法，传入刚才新建的RealInterceptorChain，返回Response</span></span><br><span class="line">        Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回响应</span></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proceed方法里面首先会再新建一个Chain并且<strong>index + 1</strong>作为构造参数传了进去，然后通过index从interceptors列表中获取了一个拦截器，接着就会调用拦截器的intercept方法，并把刚刚新建的Chain作为参数传给拦截器，我们再回顾一下上面所讲的拦截器intercept方法的模板，intercept方法处理完Request逻辑后，会再次调用传入的Chain的proceed(Request)方法，这样又会重复Chain的proceed方法中的逻辑，由于index已经加1了，所以这次Chain就会通过index获取下一个拦截器，并调用下一个拦截器的intercept(Chain)方法，然后如此循环重复下去，这样就把每个拦截器通过一个个Chain连接起来，形成一条链，把Request沿着链传递下去，直到请求被处理，然后返回Response，响应同样的沿着链传递上去，如下：</p><img src="/2019/09/07/okhttp3源码分析之拦截器/okhttp1.png" title="okhttp"><p>从上图可知，责任链首节点就是RetryAndFollowUpInterceptor，尾节点就是CallServerInterceptor，Request按照拦截器的顺序正向处理，Response则逆向处理，每个拦截器都有机会处理Request和Response，一个完美的责任链模式的实现。</p><p>知道了getResponseWithInterceptorChain()的整体流程后，下面分别介绍各个默认拦截器的功能。</p><h2 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h2><p>在自定义拦截器的时候就讲过，Interceptor的intercept(Chain)方法就是拦截器的拦截实现，RetryAndFollowUpInterceptor的intercept(Chain)方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RetryAndFollowUpInterceptor.java</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Request</span></span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    <span class="comment">//获取Transmitter</span></span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重定向次数</span></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用Transmitter的prepareToConnect方法，做好连接建立的准备</span></span><br><span class="line">        transmitter.prepareToConnect(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Response response;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用proceed方法，里面调用下一个拦截器BridgeInterceptor的intercept方法</span></span><br><span class="line">            response = realChain.proceed(request, transmitter, <span class="keyword">null</span>);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RouteException e) &#123;<span class="comment">//出现RouteException异常</span></span><br><span class="line">            <span class="comment">//调用recover方法检测连接是否可以继续使用</span></span><br><span class="line">            <span class="keyword">if</span> (!recover(e.getLastConnectException(), transmitter, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getFirstConnectException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;<span class="comment">//出现IOException异常，和服务端建立连接失败</span></span><br><span class="line">            <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">            <span class="comment">//调用recover方法检测连接是否可以继续使用</span></span><br><span class="line">            <span class="keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//出现其他未知异常</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">//调用Transmitter的exchangeDoneDueToException()方法释放连接</span></span><br><span class="line">                transmitter.exchangeDoneDueToException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行到这里，没有出现任何异常，连接成功, 响应返回</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据响应码来处理请求头</span></span><br><span class="line">        Request followUp = followUpRequest(response, route);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//followUp为空，不需要重定向，直接返回Response</span></span><br><span class="line">        <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//followUp不为空，需要重定向</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//MAX_FOLLOW_UPS值为20，重定向次数不能大于20次</span></span><br><span class="line">        <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以重定向后的Request再次重试</span></span><br><span class="line">        request = followUp;</span><br><span class="line">        priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RetryAndFollowUpInterceptor的intercept(Chain)方法中主要是失败重试和重定向的逻辑，该方法流程如下：</p><p>1、首先获取Transmitter类；</p><p>2、然后进入一个死循环，先调用Transmitter的prepareToConnect方法，准备建立连接；（连接真正的建立在ConnectInterceptor中）</p><p>3、接着调用Chain的proceed方法，继续执行下一个拦截器BridgeInterceptor的intercept方法：</p><p>​    3.1、如果在请求的过程中抛出RouteException异常或IOException异常，就会调用recover方法检测连接是否可以继续使用，如果不可以继续使用就抛出异常，整个过程结束，否则就再次重试，这就是失败重试；</p><p>​    3.2、如果在请求的过程中抛出除了3.1之外的异常，就会调用Transmitter的exchangeDoneDueToException()方法释放连接，整个过程结束。</p><p>4、没有任何异常抛出，当响应Response返回后，就会调用followUpRequest方法，里面根据返回的Response的响应码来决定是否需要重定向（构造followUp请求），如果不需要重定向，就直接返回Response，如果需要重定向，那么以重定向后的Request再次重试，重定向次数不能大于20次。</p><h3 id="1、Transmitter"><a href="#1、Transmitter" class="headerlink" title="1、Transmitter"></a>1、Transmitter</h3><p>在整个方法的流程中出现了一个Transmitter，这里介绍一下，它是okhttp中应用层和网络层的桥梁，管理同一个Cal的所有连接、请求、响应和IO流之间的关系，它在RealCall创建后就被创建了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建RealCall</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    <span class="comment">//创建Transmitter，赋值给call的transmitter字段</span></span><br><span class="line">    call.transmitter = <span class="keyword">new</span> Transmitter(client, call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建后，在构造节点Chain时作为参数传了进去，在getResponseWithInterceptorChain方法中有讲到，所以在intercept方法中它可以通过chain.transmitter()获得，它的整个生命周期贯穿了所有拦截器，在接下来的ConnectInterceptor和CallServerInterceptor中你都可以见到它的身影，我们看一下它的主要成员，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;<span class="comment">//OkHttpClient大管家</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RealConnectionPool connectionPool;<span class="comment">//连接池，管理着连接</span></span><br><span class="line">    <span class="keyword">public</span> RealConnection connection;<span class="comment">//本次连接对象</span></span><br><span class="line">    <span class="keyword">private</span> ExchangeFinder exchangeFinder;<span class="comment">//负责连接的创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Exchange exchange;<span class="comment">//负责连接IO流读写</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Call call;<span class="comment">//Call对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Transmitter</span><span class="params">(OkHttpClient client, Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());</span><br><span class="line">        <span class="keyword">this</span>.call = call;</span><br><span class="line">        <span class="keyword">this</span>.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">        <span class="keyword">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareToConnect</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.request != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sameConnection(<span class="keyword">this</span>.request.url(), request.url()) &amp;&amp; exchangeFinder.hasRouteToTry()) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// Already ready.</span></span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="comment">//创建ExchangeFinder</span></span><br><span class="line">        <span class="keyword">this</span>.exchangeFinder = <span class="keyword">new</span> ExchangeFinder(<span class="keyword">this</span>, connectionPool, createAddress(request.url()), call, eventListener);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Transmitter中client和call我们都认识，剩下的RealConnectionPool、RealConnection、ExchangeFinder、Exchange都和okhttp的连接机制有关，都会在ConnectInterceptor中介绍，Transmitter就是负责管理它们之间的关系。这里我们只要记住，Transmitter的prepareToConnect方法中主要是创建了一个ExchangeFinder，为在ConnectInterceptor中连接的建立做了一个准备。</p><h2 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h2><p>BridgeInterceptor的intercept(Chain)方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BridgeInterceptor.java</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Request</span></span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//下面都是根据需要为Request的header添加或移除一些信息</span></span><br><span class="line">    </span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      MediaType contentType = body.contentType();</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用proceed方法，里面调用下一个拦截器CacheInterceptor的intercept方法</span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Response后</span></span><br><span class="line">    <span class="comment">//下面都是根据需要为Response的header添加或移除一些信息</span></span><br><span class="line">    </span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>)) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">          .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">      responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>BridgeInterceptor中的逻辑是在所有默认拦截器中是最简单，它主要就是对Request或Response的header做了一些处理，把用户构造的Request转换为发送给服务器的Request，还有把服务器返回的Response转换为对用户友好的Response。例如，对于Request，当开发者没有添加Accept-Encoding时，它会自动添加Accept-Encoding : gzip，表示客户端支持使用gzip；对于Response，当Content-Encoding是gzip方式并且客户端是自动添加gzip支持时，它会移除Content-Encoding、Content-Length，然后重新解压缩响应的内容。</p><h2 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h2><p>CacheInterceptor的intercept(Chain)方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheInterceptor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据Request得到Cache中缓存的Response，Cache是什么，后面介绍</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span> ? cache.get(chain.request()) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建缓存策略：网络、缓存、或两者都使用，CacheStrategy是什么，后面介绍</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    <span class="comment">//得到networkRequest</span></span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    <span class="comment">//得到cacheResponse，cacheResponse等于上面的cacheCandidate</span></span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个Response缓存无效，close掉它</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、networkRequest为null且cacheResponse为null：表示强制使用缓存，但是没有缓存，所以构造状态码为504，body为空的Response</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(<span class="number">504</span>)<span class="comment">//状态码504</span></span><br><span class="line">            .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2、networkRequest为null但cacheResponse不为null：表示强制使用缓存，并且有缓存，所以直接返回缓存的Response</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//networkRequest不为null，所以可以发起网络请求，调用chain.proceed(Request)，里面调用下一个拦截器BridgeInterceptor的intercept方法，会返回网络请求得到的networkResponse</span></span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">       </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//发起网络请求出现IO异常或其他异常的处理</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、networkRequest不为null且cacheResponse不为null：因为cacheResponse不为null，所以根据网络请求得到的networkResponse和缓存的cacheResponse做比较，来决定是否更新cacheResponse</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;<span class="comment">//HTTP_NOT_MODIFIED等于304，304表示服务器缓存有更新，所以客户端要更新cacheResponse</span></span><br><span class="line">            <span class="comment">//下面根据networkResponse更新(重新构造)cacheResponse</span></span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .networkResponse(stripBody(networkResponse))</span><br><span class="line">                .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line">            <span class="comment">//更新cacheResponse在本地缓存</span></span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//不需要更新cacheResponse，close掉它</span></span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、networkRequest不为null但cacheResponse为null：cacheResponse为null，没有缓存使用，所以从networkResponse读取网络响应，构造Response准备返回</span></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把Response缓存到Cache中</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">            <span class="comment">//cacheResponse为null，所以这里是第一次缓存，把Response缓存到Cache中</span></span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                <span class="comment">// The cache cannot be written.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Response</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheInterceptor的intercept(Chain)里面定义了okhttp的缓存机制，我们先来了解两个类：Cache和CacheStrategy，这样才能看懂intercept(Chain)里面的逻辑。</p><h3 id="1、Cache-缓存实现"><a href="#1、Cache-缓存实现" class="headerlink" title="1、Cache - 缓存实现"></a>1、Cache - 缓存实现</h3><p>Cache是okhttp中缓存的实现，内部使用了DiskLruCache，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//内部都是通过DiskLruCache实现</span></span><br><span class="line">    <span class="keyword">final</span> DiskLruCache cache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有一个InternalCache实现，都调用了Cache中的方法</span></span><br><span class="line">    <span class="keyword">final</span> InternalCache internalCache = <span class="keyword">new</span> InternalCache() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Cache.<span class="keyword">this</span>.get(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Cache.<span class="keyword">this</span>.put(response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Cache.<span class="keyword">this</span>.remove(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Response cached, Response network)</span> </span>&#123;</span><br><span class="line">            Cache.<span class="keyword">this</span>.update(cached, network);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackConditionalCacheHit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Cache.<span class="keyword">this</span>.trackConditionalCacheHit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackResponse</span><span class="params">(CacheStrategy cacheStrategy)</span> </span>&#123;</span><br><span class="line">            Cache.<span class="keyword">this</span>.trackResponse(cacheStrategy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以通过下面两个构造函数构造一个Cache</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cache</span><span class="params">(File directory, <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(directory, maxSize, FileSystem.SYSTEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cache(File directory, <span class="keyword">long</span> maxSize, FileSystem fileSystem) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是主要方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Response cached, Response network)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trackConditionalCacheHit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trackResponse</span><span class="params">(CacheStrategy cacheStrategy)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cache中有一个内部实现类InternalCache，见名知意，它是okhttp内部使用的，它实现了InternalCache接口，接口中的方法都和Cache中的方法同名，而且这个实现类的所有方法都是调用了Cache中相应的方法，也就是说InternalCache的方法实现和Cache相应的方法一样，但Cache和InternalCache不一样的是，Cache比InternalCache多了一些方法供外部调用如flush()、 close()等，提供了更多对缓存的控制，而InternalCache中的方法都只是缓存的基本操作，如get、put、remove、update等方法，这些方法的逻辑都是基于Cache中的DiskLruCache实现，详情可以看<a href="https://blog.csdn.net/guolin_blog/article/details/28863651" target="_blank" rel="noopener">DiskLruCache</a>的原理实现。</p><p>要知道，okhttp默认是不使用缓存，也就是Cache为null，如果要使用缓存，我们需要自行配置，通过下面方法使用okhttp的缓存机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存的路径</span></span><br><span class="line">File cacheDir = <span class="keyword">new</span> File(Constant.PATH_NET_CACHE);</span><br><span class="line"><span class="comment">//这里通过带有两个参数的构造函数构造一个Cache</span></span><br><span class="line">Cache cache = <span class="keyword">new</span> Cache(cacheDir, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>);<span class="comment">//缓存的最大尺寸10M</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后设置给OkHttpClient</span></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .cache(cache)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>通过上面全局设置后，Cache和InternalCache都不会为null，因为在创建Cache时InternalCache也一起创建了，okhttp的缓存机制就会生效。</p><p>我们先回到CacheInterceptor的intercept方法，它首先一开始就要判断cache是否等于null，那么CacheInterceptor的cache在哪里来的呢？是在构造函数中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span> InternalCache cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheInterceptor</span><span class="params">(@Nullable InternalCache cache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用看到它是InternalCache实例，在 getResponseWithInterceptorChain()中添加拦截器时就通过client为这个InternalCache赋值了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.java</span></span><br><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//添加负责缓存的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到new CacheInterceptor(client.internalCache())，所以我们看client的internalCache方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OkHttpClient.java</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="function">InternalCache <span class="title">internalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache != <span class="keyword">null</span> ? cache.internalCache : internalCache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>cache就是上面全局设置的cache实例，所以不为null，返回cache中的internalCache实例，这样CacheInterceptor中就持有internalCache实例。</p><h3 id="2、CacheStrategy-缓存策略"><a href="#2、CacheStrategy-缓存策略" class="headerlink" title="2、CacheStrategy - 缓存策略"></a>2、CacheStrategy - 缓存策略</h3><p>CacheStrategy是okhttp缓存策略的实现，okhttp缓存策略遵循了HTTP缓存策略，因此了解okhttp缓存策略前需要有HTTP缓存相关基础：<a href="https://my.oschina.net/leejun2005/blog/369148" target="_blank" rel="noopener">HTTP 协议缓存机制详解</a>，了解了HTTP缓存策略后，我们再来看CacheStrategy，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CacheStrategy两个主要的成员变量：networkRequest、cacheResponse</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Request networkRequest;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Response cacheResponse;</span><br><span class="line"></span><br><span class="line">    CacheStrategy(Request networkRequest, Response cacheResponse) &#123;</span><br><span class="line">        <span class="keyword">this</span>.networkRequest = networkRequest;</span><br><span class="line">        <span class="keyword">this</span>.cacheResponse = cacheResponse;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过工厂模式创建CacheStrategy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> nowMillis;</span><br><span class="line">        <span class="keyword">final</span> Request request;</span><br><span class="line">        <span class="keyword">final</span> Response cacheResponse;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(<span class="keyword">long</span> nowMillis, Request request, Response cacheResponse)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.nowMillis = nowMillis;</span><br><span class="line">            <span class="keyword">this</span>.request = request;</span><br><span class="line">            <span class="keyword">this</span>.cacheResponse = cacheResponse;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            CacheStrategy candidate = getCandidate();</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheStrategy是通过<a href="https://rain9155.github.io/2019/09/07/工厂模式/#more" target="_blank" rel="noopener">工厂模式</a>创建的，它有两个主要的成员变量：networkRequest、cacheResponse，CacheInterceptor的intercept方法通过CacheStrategy的networkRequest和cacheResponse的组合来判断执行什么策略，networkRequest是否为空决定是否请求网络，cacheResponse是否为空决定是否使用缓存，networkRequest和cacheResponse的4种组合和对应的缓存策略如下：</p><ul><li>1、networkRequest为null且cacheResponse为null：没有缓存使用，又不进行网络请求，构造状态码为504的Response。</li><li>2、networkRequest为null但cacheResponse不为null：有缓存使用，且缓存在有效期内，所以直接返回缓存的Response。</li><li>3、networkRequest不为null且cacheResponse不为null：有缓存使用，但缓存在客户端的判断中表示过期了，所以请求服务器进行决策，来决定是否使用缓存的Response。</li><li>4、networkRequest不为null但cacheResponse为null：没有缓存使用，所以直接使用服务器返回的Response</li></ul><p>networkRequest和cacheResponse在创建CacheStrategy时通过构造参数赋值，那么CacheStrategy在那里被创建呢？当调用CacheStrategy.Factory(long, Request, Response).get()时就会返回一个CacheStrategy实例，所以CacheStrategy在Factory的get方法中被创建，我们来看Factory的get方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheStrategy.Factory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheStrategy candidate = getCandidate();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到CacheStrategy通过Factory的getCandidate方法创建，getCandidate方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheStrategy.Factory</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、没有Response缓存，直接进行网络请求</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、如果TLS握手信息丢失，直接进行网络请求</span></span><br><span class="line">    <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、根据Response状态码，Expired和Cache-Control的no-Store进行判断Response缓存是否可用</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="comment">//Response缓存不可用，直接进行网络请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得Request的缓存控制字段CacheControl</span></span><br><span class="line">    CacheControl requestCaching = request.cacheControl();</span><br><span class="line">    <span class="comment">//4、根据Request中的Cache-Control的noCache和header是否设置If-Modified-Since或If-None-Match进行判断是否可以使用Response缓存</span></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="comment">//不可以使用Response缓存，直接进行网络请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//走到这里表示Response缓存可用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得Response的缓存控制字段CacheControl</span></span><br><span class="line">    CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得该Response已经缓存的时长</span></span><br><span class="line">    <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">    <span class="comment">//获得该Response可以缓存的时长</span></span><br><span class="line">    <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) </span><br><span class="line">        <span class="comment">//一般取max-age</span></span><br><span class="line">        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//一般取0</span></span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//取max-stale，</span></span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、判断缓存是否过期，决定是否使用Response缓存：Response已经缓存的时长 &lt; max-stale + max-age</span></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"110 HttpURLConnection \"Response is stale\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"113 HttpURLConnection \"Heuristic expiration\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.1、缓存没有过期，直接使用该Response缓存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.2、缓存过期了，判断是否设置了Etag或Last-Modified等标记</span></span><br><span class="line">    String conditionName;</span><br><span class="line">    String conditionValue;</span><br><span class="line">    <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-None-Match"</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//缓存没有设置Etag或Last-Modified等标记，所以直接进行网络请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存设置了Etag或Last-Modified等标记，所以添加If-None-Match或If-Modified-Since请求头，构造请求，交给服务器判断缓存是否可用</span></span><br><span class="line">    Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">    Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">    Request conditionalRequest = request.newBuilder()</span><br><span class="line">        .headers(conditionalRequestHeaders.build())</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//networkRequest和cacheResponse都不为null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> getCandidate()方法中根据<a href="https://my.oschina.net/leejun2005/blog/369148" target="_blank" rel="noopener"><strong>HTTP的缓存策略</strong></a>决定networkRequest和cacheResponse的组合，从getCandidate()方法中我们可以看到HTTP的缓存策略分为两种：</p><ul><li>1、强制缓存：<strong>客户端参与决策决定是否继续使用缓存</strong>，客户端第一次请求数据时，服务端返回了缓存的过期时间：Expires或Cache-Control，当客户端再次请求时，就判断缓存的过期时间，没有过期就可以继续使用缓存，否则就不使用，重新请求服务端。</li><li>2、对比缓存：<strong>服务端参与决策决定是否继续使用缓存</strong>，客户端第一次请求数据时，服务端会将缓存标识：Last-Modified/If-Modified-Since、Etag/If-None-Match和数据一起返回给客户端 ，当客户端再次请求时，客户端将缓存标识发送给服务端，服务端根据缓存标识进行判断，如果缓存还没有更新，可以使用，则返回304，表示客户端可以继续使用缓存，否则客户端不能继续使用缓存，只能使用服务器返回的新的响应。</li></ul><p>而且强制缓存优先于对比缓存，我们再贴出来自<a href="https://my.oschina.net/leejun2005/blog/369148" target="_blank" rel="noopener">HTTP 协议缓存机制详解</a>的一张图，它很好的解释了getCandidate()方法中1~5步骤流程，如下：</p><img src="/2019/09/07/okhttp3源码分析之拦截器/okhttp2.png" title="okhttp"><h3 id="3、缓存机制"><a href="#3、缓存机制" class="headerlink" title="3、缓存机制"></a>3、缓存机制</h3><p>我们再回到CacheInterceptor的intercept方法，它的1~4步骤就是CacheStrategy的networkRequest和cacheResponse的4种组合情况，都有详细的注释，每一种组合对应一种缓存策略，而缓存策略又是基于getCandidate()方法中写死的HTTP缓存策略，再结合okhttp本地缓存的实现Cache，我们得出结论：<strong>okhttp的缓存机制 = Cache缓存实现 + 基于HTTP的缓存策略</strong>，整个流程图如下：</p><img src="/2019/09/07/okhttp3源码分析之拦截器/okhttp3.png" title="okhttp"><p>了解了okhttp的缓存机制后，我们接着下一个拦截器ConnectInterceptor。</p><h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><p>ConnectInterceptor的intercept(Chain)方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConnectInterceptor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   </span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    <span class="comment">//获取Transmitter</span></span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">//1、新建一个Exchange</span></span><br><span class="line">    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用proceed方法，里面调用下一个拦截器CallServerInterceptor的intercept方法</span></span><br><span class="line">    <span class="comment">//这里调用的proceed方法是带有三个参数的，它传进了Request、Transmitter和刚刚新建的Exchange</span></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConnectInterceptor的intercept(Chain)方法很简洁，里面定义了okhttp的连接机制，它首先获取Transmitter，然后通过Transmitter的newExchange方法创建一个Exchange，把它传到下一个拦截器CallServerInterceptor，Exchange是什么？Exchange负责从创建的连接的IO流中写入请求和读取响应，完成一次请求/响应的过程，在CallServerInterceptor中你会看到它真正的作用，这里先忽略。所以注释1的newExchange方法是连接机制的主要逻辑实现，我们继续看Transmitter的newExchange方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Transmitter.java</span></span><br><span class="line"><span class="function">Exchange <span class="title">newExchange</span><span class="params">(Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、通过ExchangeFinder的find方法找到一个ExchangeCodec</span></span><br><span class="line">    ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Exchange，并把ExchangeCodec实例codec传进去，所以Exchange内部持有ExchangeCodec实例</span></span><br><span class="line">    Exchange result = <span class="keyword">new</span> Exchange(<span class="keyword">this</span>, call, eventListener, exchangeFinder, codec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是注释1，ExchangeFinder对象早在RetryAndFollowUpInterceptor中通过Transmitter的prepareToConnect方法创建，它的find方法是连接真正创建的地方，ExchangeFinder是什么？ExchangeFinder就是负责连接的创建，把创建好的连接放入连接池，如果连接池中已经有该连接，就直接取出复用，所以ExchangeFinder管理着两个重要的角色：RealConnection、RealConnectionPool，下面讲解一下RealConnectionPool和RealConnection，有助于连接机制的理解。</p><h3 id="1、RealConnection-连接实现"><a href="#1、RealConnection-连接实现" class="headerlink" title="1、RealConnection - 连接实现"></a>1、RealConnection - 连接实现</h3><p>连接的真正实现，实现了Connection接口，内部利用Socket建立连接，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回这个连接使用的Route</span></span><br><span class="line">    <span class="function">Route <span class="title">route</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回这个连接使用的Socket</span></span><br><span class="line">    <span class="function">Socket <span class="title">socket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是HTTPS，返回TLS握手信息用于建立连接，否则返回null</span></span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">Handshake <span class="title">handshake</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回应用层使用的协议，Protocol是一个枚举，如HTTP1.1、HTTP2</span></span><br><span class="line">    <span class="function">Protocol <span class="title">protocol</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnection</span> <span class="keyword">extends</span> <span class="title">Http2Connection</span>.<span class="title">Listener</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> RealConnectionPool connectionPool;</span><br><span class="line">    <span class="comment">//路由</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Route route;</span><br><span class="line">    <span class="comment">//内部使用这个rawSocket在TCP层建立连接</span></span><br><span class="line">    <span class="keyword">private</span> Socket rawSocket;</span><br><span class="line">    <span class="comment">//如果没有使用HTTPS，那么socket == rawSocket，否则这个socket == SSLSocket</span></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="comment">//TLS握手</span></span><br><span class="line">    <span class="keyword">private</span> Handshake handshake;</span><br><span class="line">    <span class="comment">//应用层协议</span></span><br><span class="line">    <span class="keyword">private</span> Protocol protocol;</span><br><span class="line">    <span class="comment">//HTTP2连接</span></span><br><span class="line">    <span class="keyword">private</span> Http2Connection http2Connection;</span><br><span class="line">    <span class="comment">//okio库的BufferedSource和BufferedSink，相当于javaIO的输入输出流</span></span><br><span class="line">    <span class="keyword">private</span> BufferedSource source;</span><br><span class="line">    <span class="keyword">private</span> BufferedSink sink;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealConnection</span><span class="params">(RealConnectionPool connectionPool, Route route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionPool = connectionPool;</span><br><span class="line">        <span class="keyword">this</span>.route = route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, Call call, EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RealConnection中有一个connect方法，外部可以调用该方法建立连接，connect方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealConnection.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, Call call, EventListener eventListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"already connected"</span>);</span><br><span class="line"></span><br><span class="line">    RouteException routeException = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;ConnectionSpec&gt; connectionSpecs = route.address().connectionSpecs();</span><br><span class="line">    ConnectionSpecSelector connectionSpecSelector = <span class="keyword">new</span> ConnectionSpecSelector(connectionSpecs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//路由选择</span></span><br><span class="line">    <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">            <span class="string">"CLEARTEXT communication not enabled for client"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      String host = route.address().url().host();</span><br><span class="line">      <span class="keyword">if</span> (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">            <span class="string">"CLEARTEXT communication to "</span> + host + <span class="string">" not permitted by network security policy"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">            <span class="string">"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (route.requiresTunnel()) &#123;<span class="comment">//如果是通道模式，则建立通道连接</span></span><br><span class="line">          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">          <span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We were unable to connect the tunnel but properly closed down our resources.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//1、否则进行Socket连接，大部分是这种情况</span></span><br><span class="line">          connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立HTTPS连接</span></span><br><span class="line">        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (http2Connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        allocationLimit = http2Connection.maxConcurrentStreams();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们关注注释1，一般会调用connectSocket方法建立Socket连接，connectSocket方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealConnection.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                           EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Proxy proxy = route.proxy();</span><br><span class="line">    Address address = route.address();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据代理类型的不同创建Socket</span></span><br><span class="line">    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">        ? address.socketFactory().createSocket()</span><br><span class="line">        : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line"></span><br><span class="line">    eventListener.connectStart(call, route.socketAddress(), proxy);</span><br><span class="line">    rawSocket.setSoTimeout(readTimeout);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1、建立Socket连接</span></span><br><span class="line">        Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获得Socket的输入输出流</span></span><br><span class="line">        source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line">        sink = Okio.buffer(Okio.sink(rawSocket));</span><br><span class="line">    &#125; </span><br><span class="line">     <span class="comment">//...省略异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们关注注释1，Platform是okhttp中根据不同Android版本平台的差异实现的一个兼容类，这里就不细究，Platform的connectSocket方法最终会调用rawSocket的connect()方法建立其Socket连接，建立Socket连接后，就可以通过Socket连接获得输入输出流source和sink，okhttp就可以从source读取或往sink写入数据，source和sink是BufferedSource和BufferedSink类型，它们是来自于<a href="https://github.com/square/okio" target="_blank" rel="noopener">okio库</a>，它是一个封装了java.io和java.nio的库，okhttp底层依赖这个库读写数据，Okio好在哪里？详情可以看这篇文章<a href="https://www.jianshu.com/p/2fff6fe403dd" target="_blank" rel="noopener">Okio好在哪</a>。</p><h3 id="2、RealConnectionPool-连接池"><a href="#2、RealConnectionPool-连接池" class="headerlink" title="2、RealConnectionPool -  连接池"></a>2、RealConnectionPool -  连接池</h3><p>连接池，用来管理连接对象RealConnection，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnectionPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</span><br><span class="line">        Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, </span><br><span class="line">        <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, </span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), </span><br><span class="line">        Util.threadFactory(<span class="string">"OkHttp ConnectionPool"</span>, <span class="keyword">true</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">boolean</span> cleanupRunning;</span><br><span class="line">    <span class="comment">//清理连接任务，在executor中执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//调用cleanup方法执行清理逻辑</span></span><br><span class="line">            <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">            <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">                waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (RealConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//调用wait方法进入等待</span></span><br><span class="line">                        RealConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双端队列，保存连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">            cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//使用线程池执行清理任务</span></span><br><span class="line">            executor.execute(cleanupRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新建连接插入队列</span></span><br><span class="line">        connections.add(connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RealConnectionPool 在内部维护了一个线程池，用来执行清理连接任务cleanupRunnable，还维护了一个双端队列connections，用来缓存已经创建的连接。要知道创建一次连接要经历TCP握手，如果是HTTPS还要经历TLS握手，握手的过程都是耗时的，所以为了提高效率，就需要connections来对连接进行缓存，从而可以复用；还有如果连接使用完毕，长时间不释放，也会造成资源的浪费，所以就需要cleanupRunnable定时清理无用的连接，okhttp支持5个并发连接，默认每个连接keepAlive为5分钟，keepAlive就是连接空闲后，保持存活的时间。</p><p>当我们第一次调用RealConnectionPool 的put方法缓存新建连接时，如果cleanupRunnable还没执行，它首先会使用线程池执行cleanupRunnable，然后把新建连接放入双端队列，cleanupRunnable中会调用cleanup方法进行连接的清理，该方法返回现在到下次清理的时间间隔，然后调用wiat方法进入等待状态，等时间到了后，再次调用cleanup方法进行清理，就这样往复循环。我们来看一下cleanup方法的清理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealConnectionPool.java</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;<span class="comment">//正在使用连接数</span></span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;<span class="comment">//空闲连接数</span></span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历所有连接，记录空闲连接和正在使用连接各自的数量</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果该连接还在使用，pruneAndGetAllocationCount种通过引用计数的方式判断一个连接是否空闲</span></span><br><span class="line">            <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//使用连接数加1</span></span><br><span class="line">                inUseConnectionCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//该连接没有在使用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//空闲连接数加1</span></span><br><span class="line">            idleConnectionCount++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录keepalive时间最长的那个空闲连接</span></span><br><span class="line">            <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">            <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">                longestIdleDurationNs = idleDurationNs;</span><br><span class="line">                <span class="comment">//这个连接很可能被移除，因为空闲时间太长</span></span><br><span class="line">                longestIdleConnection = connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//跳出循环后</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认keepalive时间keepAliveDurationNs最长为5分钟，空闲连接数idleConnectionCount最大为5个</span></span><br><span class="line">        <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;<span class="comment">//如果longestIdleConnection的keepalive时间大于5分钟 或 空闲连接数超过5个</span></span><br><span class="line">            <span class="comment">//把longestIdleConnection连接从队列清理掉</span></span><br><span class="line">            connections.remove(longestIdleConnection);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;<span class="comment">//如果空闲连接数小于5个 并且 longestIdleConnection连接还没到期清理</span></span><br><span class="line">            <span class="comment">//返回该连接的到期时间，下次再清理</span></span><br><span class="line">            <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;<span class="comment">//如果没有空闲连接 且 所有连接都还在使用</span></span><br><span class="line">            <span class="comment">//返回keepAliveDurationNs，5分钟后再清理</span></span><br><span class="line">            <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有任何连接，把cleanupRunning复位</span></span><br><span class="line">            cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把longestIdleConnection连接从队列清理掉后，关闭该连接的socket，返回0，立即再次进行清理</span></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从cleanup方法得知，okhttp清理连接的逻辑如下：</p><p>1、首先遍历所有连接，记录空闲连接数idleConnectionCount和正在使用连接数inUseConnectionCount，在记录空闲连接数时，还要找出空闲时间最长的空闲连接longestIdleConnection，这个连接是很有可能被清理的；</p><p>2、遍历完后，根据最大空闲时长和最大空闲连接数来决定是否清理longestIdleConnection，</p><p>​    2.1、如果longestIdleConnection的空闲时间大于最大空闲时长 或 空闲连接数大于最大空闲连接数，那么该连接就会被从队列中移除，然后关闭该连接的socket，返回0，立即再次进行清理；</p><p>​    2.2、如果空闲连接数小于5个 并且 longestIdleConnection的空闲时间小于最大空闲时长即还没到期清理，那么返回该连接的到期时间，下次再清理；</p><p>​    2.3、如果没有空闲连接 且 所有连接都还在使用，那么返回默认的keepAlive时间，5分钟后再清理；</p><p>​    2.4、没有任何连接，idleConnectionCount和inUseConnectionCount都为0，把cleanupRunning复位，等待下一次put连接时，再次使用线程池执行cleanupRunnable。</p><p>了解了RealConnectionPool和RealConnection后，我们再回到ExchangeFinder的find方法，这里是连接创建的地方。</p><h3 id="3、连接创建（连接机制）"><a href="#3、连接创建（连接机制）" class="headerlink" title="3、连接创建（连接机制）"></a>3、连接创建（连接机制）</h3><p>ExchangeFinder的fing方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExchangeFinder.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExchangeCodec <span class="title">find</span><span class="params">( OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//调用findHealthyConnection方法，返回RealConnection</span></span><br><span class="line">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,  writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">return</span> resultConnection.newCodec(client, chain);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//一个死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//调用findConnection方法，返回RealConnection</span></span><br><span class="line">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">          pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line">        </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断连接是否可用</span></span><br><span class="line">        <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">            candidate.noNewExchanges();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ExchangeFinder的find方法会调用findHealthyConnection方法，里面会不断调用findConnection方法，直到找到一个可用的连接返回。ExchangeFinder的findConnection方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExchangeFinder.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> foundPooledConnection = <span class="keyword">false</span>;</span><br><span class="line">    RealConnection result = <span class="keyword">null</span>;<span class="comment">//返回结果，可用的连接</span></span><br><span class="line">    Route selectedRoute = <span class="keyword">null</span>;</span><br><span class="line">    RealConnection releasedConnection;</span><br><span class="line">    Socket toClose;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">       <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      hasStreamFailure = <span class="keyword">false</span>; .</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1、尝试使用已经创建过的连接，已经创建过的连接可能已经被限制创建新的流</span></span><br><span class="line">      releasedConnection = transmitter.connection;</span><br><span class="line">      <span class="comment">//1.1、如果已经创建过的连接已经被限制创建新的流，就释放该连接（releaseConnectionNoEvents中会把该连接置空），并返回该连接的Socket以关闭</span></span><br><span class="line">      toClose = transmitter.connection != <span class="keyword">null</span> &amp;&amp; transmitter.connection.noNewExchanges</span><br><span class="line">          ? transmitter.releaseConnectionNoEvents()</span><br><span class="line">          : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.2、已经创建过的连接还能使用，就直接使用它当作结果、</span></span><br><span class="line">        <span class="keyword">if</span> (transmitter.connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = transmitter.connection;</span><br><span class="line">            releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、已经创建过的连接不能使用</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.1、尝试从连接池中找可用的连接，如果找到，这个连接会赋值先保存在Transmitter中</span></span><br><span class="line">            <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="keyword">null</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                <span class="comment">//2.2、从连接池中找到可用的连接</span></span><br><span class="line">                foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">                result = transmitter.connection;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextRouteToTry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                selectedRoute = nextRouteToTry;</span><br><span class="line">                nextRouteToTry = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retryCurrentRoute()) &#123;</span><br><span class="line">                selectedRoute = transmitter.connection.route();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">closeQuietly(toClose);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//3、如果在上面已经找到了可用连接，直接返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//走到这里没有找到可用连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//看看是否需要路由选择，多IP操作</span></span><br><span class="line">    <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">        newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">        routeSelection = routeSelector.next();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Route&gt; routes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有下一个路由</span></span><br><span class="line">        <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">            routes = routeSelection.getAll();</span><br><span class="line">            <span class="comment">//4、这里第二次尝试从连接池中找可用连接</span></span><br><span class="line">            <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                <span class="comment">//4.1、从连接池中找到可用的连接</span></span><br><span class="line">                foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">                result = transmitter.connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在连接池中没有找到可用连接</span></span><br><span class="line">        <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">                selectedRoute = routeSelection.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//5、所以这里新创建一个连接，后面会进行Socket连接</span></span><br><span class="line">            result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">            connectingConnection = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.2、如果在连接池中找到可用的连接，直接返回该连接</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">        eventListener.connectionAcquired(call, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.1、调用RealConnection的connect方法进行Socket连接，这个在RealConnection中讲过</span></span><br><span class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener);</span><br><span class="line">    </span><br><span class="line">    connectionPool.routeDatabase.connected(result.route());</span><br><span class="line"></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        connectingConnection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果我们刚刚创建了同一地址的多路复用连接，释放这个连接并获取那个连接</span></span><br><span class="line">        <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            result.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line">            socket = result.socket();</span><br><span class="line">            result = transmitter.connection;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//5.2、把刚刚新建的连接放入连接池</span></span><br><span class="line">            connectionPool.put(result);</span><br><span class="line">            <span class="comment">//5.3、把刚刚新建的连接保存到Transmitter的connection字段</span></span><br><span class="line">            transmitter.acquireConnectionNoEvents(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    closeQuietly(socket);</span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.4、返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个findConnection方法就是整个ConnectInterceptor的核心，我们忽略掉多IP操作和多路复用(HTTP2)，假设现在我们是第一次请求，连接池和Transmitter中没有该连接，所以跳过1、2、3，直接来到5，创建一个新的连接，然后把它放入连接池和Transmitter中；接着我们用同一个Call进行了第二次请求，这时连接池和Transmitter中有该连接，所以就会走1、2、3，如果Transmitter中的连接还可用就返回，否则从连接池获取一个可用连接返回，所以整个连接机制的大概过程如下：</p><img src="/2019/09/07/okhttp3源码分析之拦截器/okhttp4.png" title="okhttp"><p>Transmitter中的连接和连接池中的连接有什么区别？我们知道每创建一个Call，就会创建一个对应的Transmitter，一个Call可以发起多次请求（同步、异步），不同的Call有不同的Transmitter，连接池是在创建OkhttpClient时创建的，所以连接池是所有Call共享的，即连接池中的连接所有Call都可以复用，而Transmitter中的那个连接只是对应它相应的Call，只能被本次Call的所有请求复用。</p><p>了解了okhttp的连接机制后，我们接着下一个拦截器CallServerInterceptor。</p><h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><p>CallServerInterceptor的intercept(Chain)方法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CallServerInterceptor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    <span class="comment">//获取Exchange</span></span><br><span class="line">    Exchange exchange = realChain.exchange();</span><br><span class="line">    <span class="comment">//获取Request</span></span><br><span class="line">    Request request = realChain.request();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Exchange的writeRequestHeaders(request)方法写入请求的header</span></span><br><span class="line">    exchange.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> responseHeadersStarted = <span class="keyword">false</span>;</span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过okio写入请求的body</span></span><br><span class="line">            <span class="keyword">if</span> (request.body().isDuplex()) &#123;</span><br><span class="line">                exchange.flushRequest();</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                    exchange.createRequestBody(request, <span class="keyword">true</span>));</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                    exchange.createRequestBody(request, <span class="keyword">false</span>));</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面开始获取网络请求返回的响应</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过Exchange的readResponseHeaders(boolean)方法读取响应的header</span></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取响应后，通过Builder模式构造Response</span></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造Response的body</span></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="comment">//构造一个空的body的Response</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//通过Exchange的openResponseBody(Response)方法读取响应的body，然后通过响应的body继续构造Response</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .body(exchange.openResponseBody(response))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回响应Response</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在ConnectInterceptor中我们已经建立了连接，连接到了服务器，获取了输入输出流，所以CallServerInterceptor的intercept(Chain)方法逻辑就是把请求发送到服务器，然后获取服务器的响应，如下：</p><p>1、发送请求：</p><p>​    1.1、通过Exchange的writeRequestHeaders(request)方法写入请求的header；</p><p>​    1.2、如果请求的body不为空，通过okio写入请求的body。</p><p>2、获取响应：</p><p>​    2.1、通过Exchange的readResponseHeaders(boolean)方法读取响应的header；</p><p>​    2.2、通过Exchange的openResponseBody(Response)方法读取响应的body。</p><p>这个发送获取的过程通过Exchange进行，前面已经讲过它在ConnectInterceptor中创建，在process方法中传进来，所以这里可以通过Chain获取Exchange，Exchange它是负责从IO流中写入请求和读取响应，完成一次请求/响应的过程，它内部的读写都是通过一个ExchangeCodec类型的codec来进行，而ExchangeCodec内部又是通过Okio的BufferedSource和BufferedSink进行IO读写，这个过程在上一篇文章已经分析过了，这里不在累述。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>结合上一篇文章，我们对okhttp已经有了一个深入的了解，首先，我们会在请求的时候初始化一个Call的实例，然后执行它的execute()方法或enqueue()方法，内部最后都会执行到getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、连接拦截器和用户自定义网络拦截器和访问服务器拦截器等拦截处理过程，来获取到一个响应并交给用户。okhttp的请求流程、缓存机制和连接机制是当中的重点，在阅读源码的过程中也学习到很多东西，下一次就来分析它的搭档Retrofit。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一篇文章：&lt;a href=&quot;https://rain9155.github.io/2019/09/03/okhttp3源码分析之请求流程/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;okhttp3源码分析之请求流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章继续通过源码来探讨okhttp的另外一个重要知识点：拦截器，在上一篇文章我们知道，在请求发送到服务器之前有一系列的拦截器对请求做了处理后才发送出去，在服务器返回响应之后，同样的有一系列拦截器对响应做了处理后才返回给发起请求的调用者，可见，拦截器是okhttp的一个重要的核心功能，在分析各个拦截器功能的同时又会牵扯出okhttp的缓存机制、连接机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文源码基于okhttp3.14.x&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;okhttp项目地址：&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsquare%2Fokhttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;okhttp&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="优秀开源库分析" scheme="http://yoursite.com/categories/%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="okhttp" scheme="http://yoursite.com/tags/okhttp/"/>
    
  </entry>
  
  <entry>
    <title>okhttp3源码分析之请求流程</title>
    <link href="http://yoursite.com/2019/09/03/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/03/okhttp3源码分析之请求流程/</id>
    <published>2019-09-03T14:49:13.000Z</published>
    <updated>2019-09-19T11:17:46.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Android开发中，当下最火的网络请求框架莫过于okhttp和retrofit，它们都是square公司的产品，两个都是非常优秀开源库，值得我们去阅读它们的源码，学习它们的设计理念，但其实retrofit底层还是用okhttp来发起网络请求的，所以深入理解了okhttp也就深入理解了retrofit，它们的源码阅读顺序应该是先看okhttp，我在retrofit上发现它最近的一次提交才把okhttp版本更新到3.14，okhttp目前最新的版本是4.0.x，okhttp从4.0.x开始采用kotlin编写，在这之前还是用java，而我本次分析的okhttp源码版本是基本3.14.x，看哪个版本的不重要，重要的是阅读过后的收获，我打算分2篇文章去分析okhttp，分别是：</p><ul><li>请求流程(同步、异步)</li><li>拦截器(Interceptor)</li></ul><p>本文是第一篇 - okhttp的请求流程，okhttp项目地址：<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">okhttp</a></p><a id="more"></a><h2 id="okhttp的简单使用"><a href="#okhttp的简单使用" class="headerlink" title="okhttp的简单使用"></a>okhttp的简单使用</h2><p>我们通过一个简单的GET请求来回忆一下okhttp的使用步骤，并以这个实例为例讲解okhttp的请求流程，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建OkHttpClient</span></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .readTimeout(<span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建请求Request</span></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">//3、创建一个Call，用于发起网络请求</span></span><br><span class="line">Call call = client.newCall(request);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、发起GET请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.1、同步请求，调用Call的execute()方法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//接收到回复Response</span></span><br><span class="line">    Response response = call.execute();</span><br><span class="line">    Log.d(TAG, response.body().string());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.2、异步请求, 调用Call的enqueue()方法</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//接收到回复Response</span></span><br><span class="line">        Log.d(TAG, response.body().string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，使用okhttp发起网络请求要经过4步：</p><ul><li>1、创建OkHttpClient</li><li>2、创建请求Request</li><li>3、通过OkHttpClient和Request创建一个Call，用于发起网络请求</li><li>4、调用Call的execute()或enqueue()方法发起同步或异步请求</li></ul><p>当服务器处理完一个请求Request后，就会返回一个响应，在okhttp中用Response代表HTTP的响应，这就是一个典型的<a href="https://rain9155.github.io/2018/12/31/Http网络请求浅析/" target="_blank" rel="noopener">HTTP</a>请求/响应流程。下面简单介绍1~3步骤：</p><h3 id="1、创建OkHttpClient"><a href="#1、创建OkHttpClient" class="headerlink" title="1、创建OkHttpClient"></a>1、创建OkHttpClient</h3><p>OkHttpClient是okhttp中的大管家，它将具体的工作分发到各个子系统中去完成，它使用<a href="https://rain9155.github.io/2019/09/07/Builder%E6%A8%A1%E5%BC%8F/#more" target="_blank" rel="noopener">Builder模式</a>配置网络请求的各种参数如超时、拦截器、分发器等，Builder中可配置的参数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OkHttpClient.Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    Dispatcher dispatcher;<span class="comment">//分发器</span></span><br><span class="line">    <span class="meta">@Nullable</span> Proxy proxy;<span class="comment">//代理</span></span><br><span class="line">    List&lt;Protocol&gt; protocols;<span class="comment">//应用层协议</span></span><br><span class="line">    List&lt;ConnectionSpec&gt; connectionSpecs;<span class="comment">//传输层协议</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//应用拦截器</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//网络拦截器</span></span><br><span class="line">    EventListener.Factory eventListenerFactory;<span class="comment">//http请求回调监听</span></span><br><span class="line">    ProxySelector proxySelector;<span class="comment">//代理选择</span></span><br><span class="line">    CookieJar cookieJar;<span class="comment">//cookie</span></span><br><span class="line">    <span class="meta">@Nullable</span> Cache cache;<span class="comment">//网络缓存</span></span><br><span class="line">    <span class="meta">@Nullable</span> InternalCache internalCache;<span class="comment">//内部缓存</span></span><br><span class="line">    SocketFactory socketFactory;<span class="comment">//socket 工厂</span></span><br><span class="line">    <span class="meta">@Nullable</span> SSLSocketFactory sslSocketFactory;<span class="comment">//安全套接层socket 工厂，用于HTTPS</span></span><br><span class="line">    <span class="meta">@Nullable</span> CertificateChainCleaner certificateChainCleaner;<span class="comment">//验证确认响应证书，适用 HTTPS 请求连接的主机名</span></span><br><span class="line">    HostnameVerifier hostnameVerifier;<span class="comment">//主机名字确认</span></span><br><span class="line">    CertificatePinner certificatePinner;<span class="comment">//证书链</span></span><br><span class="line">    Authenticator proxyAuthenticator;<span class="comment">//代理身份验证</span></span><br><span class="line">    Authenticator authenticator;<span class="comment">//本地身份验证</span></span><br><span class="line">    ConnectionPool connectionPool;<span class="comment">//连接池,复用连接</span></span><br><span class="line">    Dns dns;<span class="comment">//域名</span></span><br><span class="line">    <span class="keyword">boolean</span> followSslRedirects;<span class="comment">//安全套接层重定向</span></span><br><span class="line">    <span class="keyword">boolean</span> followRedirects;<span class="comment">//本地重定向</span></span><br><span class="line">    <span class="keyword">boolean</span> retryOnConnectionFailure;<span class="comment">//错误重连</span></span><br><span class="line">    <span class="keyword">int</span> callTimeout;<span class="comment">//请求超时，它包括dns解析、connect、read、write和服务器处理的时间</span></span><br><span class="line">    <span class="keyword">int</span> connectTimeout;<span class="comment">//connect超时</span></span><br><span class="line">    <span class="keyword">int</span> readTimeout;<span class="comment">//read超时</span></span><br><span class="line">    <span class="keyword">int</span> writeTimeout;<span class="comment">//write超时</span></span><br><span class="line">    <span class="keyword">int</span> pingInterval;<span class="comment">//ping超时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是配置默认的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">      protocols = DEFAULT_PROTOCOLS;<span class="comment">//Protocol.HTTP_2和Protocol.HTTP_1_1</span></span><br><span class="line">      connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">      eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">      proxySelector = ProxySelector.getDefault();</span><br><span class="line">      <span class="keyword">if</span> (proxySelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">        proxySelector = <span class="keyword">new</span> NullProxySelector();</span><br><span class="line">      &#125;</span><br><span class="line">      cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">      socketFactory = SocketFactory.getDefault();</span><br><span class="line">      hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">      certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">      proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">      authenticator = Authenticator.NONE;</span><br><span class="line">      connectionPool = <span class="keyword">new</span> ConnectionPool();</span><br><span class="line">      dns = Dns.SYSTEM;</span><br><span class="line">      followSslRedirects = <span class="keyword">true</span>;</span><br><span class="line">      followRedirects = <span class="keyword">true</span>;</span><br><span class="line">      retryOnConnectionFailure = <span class="keyword">true</span>;</span><br><span class="line">      callTimeout = <span class="number">0</span>;</span><br><span class="line">      connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">      readTimeout = <span class="number">10_000</span>;</span><br><span class="line">      writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">      pingInterval = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里通过另外一个OkHttpClient配置参数</span></span><br><span class="line">    Builder(OkHttpClient okHttpClient) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dispatcher = okHttpClient.dispatcher;</span><br><span class="line">      <span class="keyword">this</span>.proxy = okHttpClient.proxy;</span><br><span class="line">      <span class="keyword">this</span>.protocols = okHttpClient.protocols;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置完参数后，通过Builder的参数创建一个OkHttpClient</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OkHttpClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、创建请求Request"><a href="#2、创建请求Request" class="headerlink" title="2、创建请求Request"></a>2、创建请求Request</h3><p>在okhttp中Request代表着一个HTTP请求，它封装了请求的具体消息，如url、header、body等，它和OkHttpClient一样都是使用Budiler模式来配置自己的参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Request.Budiler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    HttpUrl url;</span><br><span class="line">    String method;</span><br><span class="line">    Headers.Builder headers;</span><br><span class="line">    RequestBody body;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里配置默认的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.method = <span class="string">"GET"</span>;<span class="comment">//默认是GET请求</span></span><br><span class="line">      <span class="keyword">this</span>.headers = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里通过另外一个Request配置参数</span></span><br><span class="line">    Builder(Request request) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = request.url;</span><br><span class="line">      <span class="keyword">this</span>.method = request.method;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置完参数后，通过Builder的参数创建一个Request</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"url == null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、创建用于发起网络请求的Call"><a href="#3、创建用于发起网络请求的Call" class="headerlink" title="3、创建用于发起网络请求的Call"></a>3、创建用于发起网络请求的Call</h3><p>Call是一个接口，它的具体实现类是RealCall，Call中定义了一些enqueue(Callback)<code>、</code>execute()等关键方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回当前请求</span></span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//同步请求方法，此方法会阻塞当前线程直到请求结果放回</span></span><br><span class="line">    <span class="function">Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">//异步请求方法，此方法会将请求添加到队列中，然后等待请求返回</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span></span>;</span><br><span class="line">    <span class="comment">//取消请求</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断请求是否在执行</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//判断请求是否取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回请求的超时时间</span></span><br><span class="line">    <span class="function">Timeout <span class="title">timeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//克隆一个新的请求</span></span><br><span class="line">    <span class="function">Call <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到Call接口中有一个Factory接口，Factory中有一个newCall(Request)方法，这说明Call是通过<a href="https://rain9155.github.io/2019/09/07/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/#more" target="_blank" rel="noopener">工厂模式</a>创建，而OkHttpClient实现了Call.Factory接口，重写了newCall(Request)方法，返回了Call的具体实现类RealCall，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Call</span>.<span class="title">Factory</span>, <span class="title">WebSocket</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用了RealCall的newRealCall()</span></span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">implements</span> <span class="title">Call</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回RealCall对象</span></span><br><span class="line">        RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">        call.transmitter = <span class="keyword">new</span> Transmitter(client, call);</span><br><span class="line">        <span class="keyword">return</span> call;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以调用<strong>client.newCall(request)</strong>其实返回的是RealCall对象，而RealCall封装了请求的调用逻辑。</p><p>到这里也就走到了注释4，也就是第4步，okhttp通过Call的实现类RealCall的execute()或enqueue()方法发起同步或异步请求，也就是本文的重点，下面分别详细介绍:</p><h2 id="同步请求-RealCall-execute"><a href="#同步请求-RealCall-execute" class="headerlink" title="同步请求 - RealCall :: execute()"></a>同步请求 - RealCall :: execute()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1、调用Dispatcher的executed(RealCall)方法</span></span><br><span class="line">        client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//2、调用getResponseWithInterceptorChain()方法</span></span><br><span class="line">        <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3、同步请求任务执行完毕，调用Dispatcher的finished(RealCall)方法</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client就是我们上面所讲的OkHttpClient的实例，它在创建RealCall时作为构造参数传了进去，而OkHttpClient的dispatcher()方法返回的是Dispatcher实例，它在OkHttpClient构造时被创建。</p><p>我们先讲一下Dispatcher，那Dispatcher是什么呢？Dispatcher是一个任务调度器，它负责进行请求任务的调度，它的内部维护着3个任务队列(readyAsyncCalls、runningAsyncCalls、runningSyncCalls)和1个<a href="https://rain9155.github.io/2019/07/19/java线程池/" target="_blank" rel="noopener">线程池</a>(executorService)，Dispatcher主要内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;<span class="comment">//最大请求数64个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;<span class="comment">//每个主机最大请求数5个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback;<span class="comment">//idle任务回调，类似于Android的idlehandler, 可以在Dispatcher没有任务调度（空闲时）时执行idleCallback中的任务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池，执行runningAsyncCalls队列里面的请求任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待执行的异步请求任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正在执行的异步请求任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正在执行的同步请求任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dispatcher提供了executed(RealCall)和enqueue(AsyncCall)方法来进行同步和异步请求任务的入队，还提供了finished(RealCall)和finished(AsyncCalll)方法来进行同步和异步请求任务的出队，可以看到okhttp把ReadCall当作同步请求任务的代表，把AsyncCall当作异步请求任务的代表，RealCall前面已经讲过了，而AsyncCal是RealCall的一个内部类，它本质上就是一个Runnable，Dispatcher的线程池执行任务主要执行的是runningAsyncCalls队列里面的异步请求任务，也就是AsyncCall异步任务，而Dispatcher的promoteAndExecute()方法就是用来进行异步任务的调度，它的逻辑主要是按顺序把readyAsyncCalls队列中准备执行的异步任务转移到runningAsyncCalls后，再由线程池执行，对于同步任务Dispatcher只是暂时保存在runningSyncCalls队列中，并不会由线程池执行。</p><p>我们继续回到RealCall的execute()方法，根据注释1、2、3分为3部分解释同步请求流程，如下：</p><h3 id="1、Dispatcher-executed-RealCall"><a href="#1、Dispatcher-executed-RealCall" class="headerlink" title="1、Dispatcher :: executed(RealCall)"></a>1、Dispatcher :: executed(RealCall)</h3><p>看RealCall的execute()方法的注释1，它首先调用了Dispatcher的executed(RealCall)方法，Dispatcher的executed(RealCall)方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到没有做什么处理，只是简单的把同步请求任务放入runningSyncCalls队列。</p><h3 id="2、RealCall-getResponseWithInterceptorChain"><a href="#2、RealCall-getResponseWithInterceptorChain" class="headerlink" title="2、RealCall  :: getResponseWithInterceptorChain()"></a>2、RealCall  :: getResponseWithInterceptorChain()</h3><p>看RealCall的execute()方法的注释2，调用getResponseWithInterceptorChain()方法，这里才是同步请求处理的地方，我们点进去，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.java </span></span><br><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//拦截器的添加</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加用户自定义拦截器</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//添加默认拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加的最后一个拦截器是CallServerInterceptor</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个RealInterceptorChain，传入了interceptors和Request</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//调用RealInterceptorChain的proceed(Request)方法处理请求</span></span><br><span class="line">      Response response = chain.proceed(originalRequest);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>getResponseWithInterceptorChain()方法最终返回一个Response，也就是网络请求的响应，该方法中首先把用户自定义的拦截器和okhttp默认的拦截器封装到一个List中，然后创建RealInterceptorChain并执行proceed(Request)方法处理请求，RealInterceptorChain的proceed(Request)方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealInterceptorChain.java</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> proceed(request, transmitter, exchange);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//再新建一个RealInterceptorChain，这里注意index加1，</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">                                                         index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">    <span class="comment">//获取interceptors列表中的下一个拦截器</span></span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    <span class="comment">//调用下一个拦截器的intercept(Chain)方法，传入刚才新建的RealInterceptorChain，返回Response</span></span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proceed()方法中再次新建了一个RealInterceptorChain，传入了index + 1，而获取拦截器时是通过index获取，这样每次都能获取到下一个拦截器，然后调用下一个拦截器的intercept(Chain)方法，intercept(Chain)方法中就是拦截器的主要功能实现，里面会继续调用传入的RealInterceptorChain的proceed()方法，这样又会重复上述逻辑，我们把拦截器看作一条链中的节点，这样每个拦截器就通过一个个RealInterceptorChain连接起来，形成一条链，这就是典型的<a href="https://rain9155.github.io/2019/09/07/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/#more" target="_blank" rel="noopener">责任链模式</a>，从节点的首部开始把请求传递下去，每一个拦截器都有机会处理这个请求，这又像是一个递归的过程，直到最后一个拦截器器处理完请求后，才开始逐层返回Resquese，拦截器才是Okhttp核心功能所在，关于拦截器介绍下篇文章再讲，这里只需要知道每一个拦截器都代表了一个功能。</p><p>经过对拦截器的简单介绍后，我们知道最后一个添加的拦截器才是把请求发送出去并且返回响应的地方，我们看getResponseWithInterceptorChain()方法，最后一个拦截器的添加是CallServerInterceptor，所以我们直接看CallServerInterceptor的intercept(Chain)方法实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CallServerInterceptor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//强转成RealInterceptorChain</span></span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    <span class="comment">//获取Exchange</span></span><br><span class="line">    Exchange exchange = realChain.exchange();</span><br><span class="line">    <span class="comment">//获取Request</span></span><br><span class="line">    Request request = realChain.request();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过Exchange的writeRequestHeaders(request)方法发送Request的header</span></span><br><span class="line">    exchange.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> responseHeadersStarted = <span class="keyword">false</span>;</span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//因为前面已经讲了，默认是GET请求，而GET请求是没有body的，所以不会进入if分支</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//省略的是发送Request的body过程</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//GET请求body为空，进入这个分支，完成请求</span></span><br><span class="line">    <span class="keyword">if</span> (request.body() == <span class="keyword">null</span> || !request.body().isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略的是一些监听回调</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面开始获取网络请求返回的响应</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、通过Exchange的readResponseHeaders(boolean)方法获取响应的header</span></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取响应后，通过Builder模式构造Response</span></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略的是response对状态码code的处理</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造Response的body</span></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="comment">//构造一个空的body的Response</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//通过Exchange的openResponseBody(Response)方法获取响应的body，然后通过响应的body继续构造Response</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .body(exchange.openResponseBody(response))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回响应Response</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>intercept(Chain）方法中主要做的就是<strong>发送请求，获取响应</strong>的事情，注释中已经写的很清楚了，发送请求要把header和body分开发送，而获取响应时也要分别获取header和body，而发送请求和获取响应两个过程都是通过一个Exchange对象进行的，Exchange是在构造RealInterceptorChain时就作为构造参数传进RealInterceptorChain中，一直都为null，直到在ConnectInterceptor的intercept()中才通过Transmitter的newExchange()被赋值，而ConnectInterceptor的下一个拦截器就是CallServerInterceptor，所以CallServerInterceptor可以通过Chain获取到Exchange实例，这里不用细究这个赋值过程，Exchange它主要是用来负责完成一次网络请求和响应的过程。</p><p>这里我以intercept(Chain）方法中注释1和注释2请求header的发送(wirte)和获取(read)为例了解Exchange的工作过程，首先看Exchange的writeRequestHeaders(Request)方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Exchange.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeRequestHeaders</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//主要是调用了codec的writeRequestHeaders(request)</span></span><br><span class="line">        codec.writeRequestHeaders(request);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看Exchange的readResponseHeaders(boolean)方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Exchange.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> Response.<span class="function">Builder <span class="title">readResponseHeaders</span><span class="params">(<span class="keyword">boolean</span> expectContinue)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//主要是调用了codec的readResponseHeaders(boolean)</span></span><br><span class="line">      Response.Builder result = codec.readResponseHeaders(expectContinue);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从Exchange的两个方法可以看出，它把 wirt和read header的任务都交给了codec，codec是什么呢？codec是ExchangeCodec类型，它是一个接口，它主要用来编码http请求并解码http返回结果，所以Exchange中真正干活的是ExchangeCodec，它的有两个实现类，分别是Http2ExchangeCodec和Http1ExchangeCodec，分别对应Http2.x和Http1.x，这里我们以Http1ExchangeCodec为例，查看它的writeRequestHeaders(request)和readResponseHeaders(boolean)方法，首先看Http1ExchangeCodec的writeRequestHeaders(request)方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Http1ExchangeCodec.java</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeRequestHeaders</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String requestLine = RequestLine.get(</span><br><span class="line">        request, realConnection.route().proxy().type());</span><br><span class="line">    <span class="comment">//调用了writeRequest()</span></span><br><span class="line">    writeRequest(request.headers(), requestLine);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeRequest</span><span class="params">(Headers headers, String requestLine)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != STATE_IDLE) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"state: "</span> + state);</span><br><span class="line">    <span class="comment">//可以看到通过sink把请求头写入IO流，发送到服务器，sink是BufferedSink类型</span></span><br><span class="line">    sink.writeUtf8(requestLine).writeUtf8(<span class="string">"\r\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class="line">      sink.writeUtf8(headers.name(i))</span><br><span class="line">          .writeUtf8(<span class="string">": "</span>)</span><br><span class="line">          .writeUtf8(headers.value(i))</span><br><span class="line">          .writeUtf8(<span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sink.writeUtf8(<span class="string">"\r\n"</span>);</span><br><span class="line">    state = STATE_OPEN_REQUEST_BODY;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们再看Http1ExchangeCodec的readResponseHeaders(boolean)方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Http1ExchangeCodec.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Response.<span class="function">Builder <span class="title">readResponseHeaders</span><span class="params">(<span class="keyword">boolean</span> expectContinue)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StatusLine statusLine = StatusLine.parse(readHeaderLine());</span><br><span class="line">        Response.Builder responseBuilder = <span class="keyword">new</span> Response.Builder()</span><br><span class="line">            .protocol(statusLine.protocol)</span><br><span class="line">            .code(statusLine.code)</span><br><span class="line">            .message(statusLine.message)</span><br><span class="line">            .headers(readHeaders());<span class="comment">//调用了readHeaders()</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> responseBuilder;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Headers <span class="title">readHeaders</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Headers.Builder headers = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">    <span class="comment">//调用了readHeaderLine()，一行一行的读取header</span></span><br><span class="line">    <span class="keyword">for</span> (String line; (line = readHeaderLine()).length() != <span class="number">0</span>; ) &#123;</span><br><span class="line">      Internal.instance.addLenient(headers, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headers.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> String <span class="title">readHeaderLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//服务器响应返回，通过source从IO读取响应头，source是BufferedSource类型</span></span><br><span class="line">    String line = source.readUtf8LineStrict(headerLimit);</span><br><span class="line">    headerLimit -= line.length();</span><br><span class="line">    <span class="keyword">return</span> line;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从Http1ExchangeCodec的两个方法可以看出，底层是通过BufferedSink把信息写入IO流，通过BufferedSource从IO流读取信息，BufferedSink和BufferedSource都是来自<a href="https://github.com/square/okio" target="_blank" rel="noopener">okio</a>这个开源库的，okhttp底层是通过okio来向网络中写入和读取IO的，想要了解更多可自行查看okio源码(okio也是square公司的产品)。</p><p>到此RealCall的 getResponseWithInterceptorChain()分析完，getResponseWithInterceptorChain()返回Response后，RealCall的execute() 方法就return了，我们就可以通过返回的Response获取我们想要的信息，但RealCall的execute() 方法就return后，还要继续执行finally 分支中的逻辑。</p><h3 id="3、Dispatcher-finished-RealCall"><a href="#3、Dispatcher-finished-RealCall" class="headerlink" title="3、Dispatcher :: finished(RealCall)"></a>3、Dispatcher :: finished(RealCall)</h3><p>我们继续看RealCall的execute()方法的注释3，调用Dispatcher的finished(AsyncCall)方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传进了runningSyncCalls队列</span></span><br><span class="line">    finished(runningSyncCalls, call);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//尝试移除队列中的同步请求任务</span></span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">        idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//紧接着调用promoteAndExecute()方法进行异步任务的调度，如果没有异步任务要进行，promoteAndExecute()返回false</span></span><br><span class="line">    <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//isRunning等于false且设置了idleCallback，会执行一遍idle任务</span></span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>finished()方法中首先尝试从runningSyncCalls队列把刚才通过 executed()入队的同步任务RealCall移除，如果移除失败，就抛出异常，如果移除成功，就紧接着调用promoteAndExecute()方法进行异步任务的调度并尝试执行一遍idle任务，promoteAndExecute()方法在异步请求中再详细介绍。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此okhttp的同步请求过程分析完毕，这里总结一下：当我们调用call.execute()时，就会发起一个同步请求，而call的实现类是RealCall，所以实际执行的是realCall.execute()，realCall.execute()中执行Dispatcher的executed(RealCall)把这个同步请求任务保存进runningSyncCalls队列中，然后RealCall执行getResponseWithInterceptorChain()处理同步请求，请求经过层层拦截器后到达最后一个拦截器CallServerInterceptor，在这个拦截器中通过Exchange把请求发送到服务器，然后同样的通过Exchange获得服务器的响应，根据响应构造Response，然后返回，最后RealCall执行Dispatcher的finished(RealCall)把之前暂时保存的同步请求任务从runningSyncCalls队列中移除。</p><p>下面是同步请求过程的调用链：</p><img src="/2019/09/03/okhttp3源码分析之请求流程/okhttp1.png" title="okhttp"><h2 id="异步请求-RealCall-enqueue-Callback"><a href="#异步请求-RealCall-enqueue-Callback" class="headerlink" title="异步请求 - RealCall.enqueue(Callback)"></a>异步请求 - RealCall.enqueue(Callback)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1、调用Dispatcher的enqueue(AsyncCall)方法</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步请求执行的是RealCall的enqueue(Callback)方法，它比同步请求只是多了一个Callback，在Callback的 onResponse(Call, Response)回调中我们可以拿到网络响应返回的Response，RealCall的enqueue(Callback)方法中首先把Callback用AsyncCall包装起来，然后调用调用Dispatcher的enqueue(AsyncCall)方法。</p><h3 id="1、Dispatcher-enqueue-AsyncCall"><a href="#1、Dispatcher-enqueue-AsyncCall" class="headerlink" title="1、Dispatcher :: enqueue(AsyncCall)"></a>1、Dispatcher :: enqueue(AsyncCall)</h3><p>我们看Dispatcher的enqueue(AsyncCall)方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       readyAsyncCalls.add(call);</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先把异步请求任务AsyncCall放入readyAsyncCalls队列，然后调用promoteAndExecute()进行异步任务的调度，我们看一下Dispatcher 是如何进行异步任务的调度的。</p><h3 id="2、Dispatcher-promoteAndExecute"><a href="#2、Dispatcher-promoteAndExecute" class="headerlink" title="2、Dispatcher :: promoteAndExecute()"></a>2、Dispatcher :: promoteAndExecute()</h3><p>promoteAndExecute()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//准备一个正在执行任务列表executableCalls</span></span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//1、这个for循环主要把readyAsyncCalls中等待执行的异步任务转移到runningAsyncCalls队列和executableCalls列表中去</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出readyAsyncCalls中等待执行的异步任务</span></span><br><span class="line">            AsyncCall asyncCall = i.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断条件：1、正在运行的异步请求任务不能大于maxRequests；2、等待执行的异步任务的主机请求数不能大于maxRequestsPerHost</span></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//满足条件，进入下面逻辑</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把这个等待执行的异步任务从readyAsyncCalls中移除</span></span><br><span class="line">            i.remove();</span><br><span class="line">            asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//把这个等待执行的异步任务添加进executableCalls列表</span></span><br><span class="line">            executableCalls.add(asyncCall);</span><br><span class="line">            <span class="comment">//把这个等待执行的异步任务添加进runningAsyncCalls队列</span></span><br><span class="line">            runningAsyncCalls.add(asyncCall);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//runningCallsCount()里面的逻辑： return runningAsyncCalls.size() + runningSyncCalls.size();</span></span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、这个for循环主要是执行executableCalls列表中的异步任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">        AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">        <span class="comment">//传进executorService，调用AsyncCall的executeOn()方法，由线程池执行这个异步任务</span></span><br><span class="line">        asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>promoteAndExecute()方法中主要是2个for循环，注释1的第一个for循环是把符合条件的异步请求任务从readyAsyncCalls转移（提升）到runningAsyncCalls队列和添加到executableCalls列表中去，紧接着注释2的第二个for循环就是遍历executableCalls列表，从executableCalls列表中获取AsyncCall对象，并且调用它的executeOn()方法，executeOn()方法传进了一个Dispatcher的executorService，所以我们看AsyncCall的executeOn()方法，里面是真正执行异步请求任务的地方。</p><h4 id="2-1、AsyncCall-executeOn-ExecutorService"><a href="#2-1、AsyncCall-executeOn-ExecutorService" class="headerlink" title="2.1、AsyncCall :: executeOn(ExecutorService)"></a>2.1、AsyncCall :: executeOn(ExecutorService)</h4><p>AsyncCall的executeOn()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AsyncCall.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//传进this，执行AsyncCall异步任务，AsyncCall本质是Runnable</span></span><br><span class="line">        executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">//异步任务执行失败，调用Dispatcher的finished(AsyncCall)方法</span></span><br><span class="line">            client.dispatcher().finished(<span class="keyword">this</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，里面的主要逻辑就是调用 executorService.execute(this)执行当前的AsyncCall异步任务，前面已经说过AsyncCall实现了NamedRunnable，本质是Runnable，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//run方法中执行execute()方法</span></span><br><span class="line">      execute();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池执行到此异步任务时，它的run方法就会被执行，而run方法主要调用execute()方法，而execute()方法是一个抽象方法，AsyncCall实现了NamedRunnable，所以AsyncCall重写了execute()实现了执行逻辑，所以我们直接看AsyncCal的execute()方法。</p><h4 id="2-2、AsyncCal-execute"><a href="#2-2、AsyncCal-execute" class="headerlink" title="2.2、AsyncCal :: execute()"></a>2.2、AsyncCal :: execute()</h4><p>AsyncCal的execute()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AsyncCall.java</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用RealCall的getResponseWithInterceptorChain()方法处理请求</span></span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//请求处理完毕，返回响应，回调Callback的onResponse()方法</span></span><br><span class="line">        responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//异步请求任务执行完毕，调用Dispatcher的finished(AsyncCall)方法</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AsyncCal的execute()方法的逻辑和前面介绍的同步请求过程殊途同归，首先调用RealCall的getResponseWithInterceptorChain()方法处理请求，请求处理完毕后，返回响应Response，这时回调我们调用Call.enqueue(Callback)时传进来的Callback的onResponse()方法，最后在finally语句中调用Dispatcher的finished(AsyncCall)方法来把异步请求任务从runningAsyncCalls队列中移除出去，这个移除逻辑和上面同步请求任务的移除逻辑一样，只是这次是从runningAsyncCalls移除而不是runningSyncCalls，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCal call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传进runningAsyncCalls，而不是runningSyncCalls</span></span><br><span class="line">    finished(runningSyncCalls, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>至此okhttp的异步请求过程分析完毕，这里再次总结一下，当我们调用call.enqueue(Callback)时，就会发起一个异步请求，实际执行的是realCall.enqueue(Callback)，它比同步请求只是多了一个Callback参数，然后realCall.execute()中先把传进来的Callback包装成一个AsyncCall，然后执行Dispatcher的enqueue(AsyncCall)把这个异步请求任务保存进readyAsyncCalls队列中，保存后开始执行 promoteAndExecute()进行异步任务的调度，它会先把符合条件的异步请求任务从readyAsyncCalls转移到runningAsyncCalls队列和添加到executableCalls列表中去，然后遍历executableCalls列表，逐个执行AsyncCall 的executeOn(ExecutorService)，然后在这个方法中AsyncCall会把自己放进Dispatcher 的线程池，等待线程池的调度，当线程池执行到这个AsyncCall时，它的run方法就会被执行，从而执行重写的execute()方法，execute()方法中的流程和同步请求流程大致相同。</p><p>下面是异步请求过程的调用链：</p><img src="/2019/09/03/okhttp3源码分析之请求流程/okhttp2.png" title="okhttp"><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>okhttp通过Builder模式创建OkHttpClient、Request和Response，通过client.newCall(Resquest)创建一个Call，用于发起异步或同步请求，请求会经过Dispatcher、一系列拦截器，最后通过okio与服务器建立连接、发送数据并解析返回结果，这个过程如图：</p><img src="/2019/09/03/okhttp3源码分析之请求流程/okhttp3.png" title="okhttp"><p>以上就是对okhttp的请求流程的分析，如有错误，欢迎指出。</p><p>参考文章：</p><p><a href="https://tamicer.github.io/2017/10/31/okhttp3-2/" target="_blank" rel="noopener">OkHttp 3.x 源码解析之Dispather分发器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Android开发中，当下最火的网络请求框架莫过于okhttp和retrofit，它们都是square公司的产品，两个都是非常优秀开源库，值得我们去阅读它们的源码，学习它们的设计理念，但其实retrofit底层还是用okhttp来发起网络请求的，所以深入理解了okhttp也就深入理解了retrofit，它们的源码阅读顺序应该是先看okhttp，我在retrofit上发现它最近的一次提交才把okhttp版本更新到3.14，okhttp目前最新的版本是4.0.x，okhttp从4.0.x开始采用kotlin编写，在这之前还是用java，而我本次分析的okhttp源码版本是基本3.14.x，看哪个版本的不重要，重要的是阅读过后的收获，我打算分2篇文章去分析okhttp，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求流程(同步、异步)&lt;/li&gt;
&lt;li&gt;拦截器(Interceptor)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文是第一篇 - okhttp的请求流程，okhttp项目地址：&lt;a href=&quot;https://github.com/square/okhttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;okhttp&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="优秀开源库分析" scheme="http://yoursite.com/categories/%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="okhttp" scheme="http://yoursite.com/tags/okhttp/"/>
    
  </entry>
  
  <entry>
    <title>View的事件分发机制</title>
    <link href="http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/29/View的事件分发机制/</id>
    <published>2019-07-29T15:14:42.000Z</published>
    <updated>2019-08-06T05:51:57.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天写过一篇文章<a href="https://rain9155.github.io/2019/07/22/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">View的工作原理</a>，讲述的View工作的三大流程，其实与View的工作流程同样重要还有View的事件分发机制，平时我们经常通过setOnClickListener()方法来设置一个View的点击监听，那你有没有想过这个点击事件底层是怎么样传递到这个View的呢？当你自定义控件时，如果要处理滑动事件，那么到底返回true还是false？还有当你遇到了滑动嵌套的情景，你要怎么解决滑动嵌套引起的冲突？所以，本文通过 源码 + 流程图 来深入了解一个事件分发机制，当你掌握了它之后，当你遇到与滑动相关的问题时就更加的游刃有余。</p><a id="more"></a><blockquote><p>本文源码基于Android8.0</p></blockquote><h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="1、什么是触摸事件"><a href="#1、什么是触摸事件" class="headerlink" title="1、什么是触摸事件"></a>1、什么是触摸事件</h3><p>触摸事件事件就是当你的手触摸到手机屏幕时所产生的最小单元事件，所谓最小单元，就是不可再拆分的，它一般有4种类型：<strong>按下（down)、移动（move）、抬起（up）、取消(cancel)</strong>。然后由若干个不可再拆分的最小单元事件就组成了<strong>点击事件、长按事件、滑动事件</strong>等。</p><h3 id="2、什么是MotionEvent"><a href="#2、什么是MotionEvent" class="headerlink" title="2、什么是MotionEvent"></a>2、什么是MotionEvent</h3><p>MotionEvent就是Android对上面触摸事件相关信息的封装，View的事件分发中的<strong>事件</strong>就是这个MotionEvent，当这个MotionEvent产生后，那么系统就会将这个MotionEvent传递给View的层级，MotionEvent在View的层级传递的过程就是事件分发。MotionEvent封装了事件类型和坐标两类信息。</p><p>事件类型可以通过 <strong>motionEvent.getAction()</strong> 方法获得，它返回一个常量，对应着一个事件类型，事件类型主要有以下4种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MotionEvent.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MotionEvent</span> <span class="keyword">extends</span> <span class="title">InputEvent</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按下（down)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_DOWN             = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//抬起（up）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_UP               = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//移动（move）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_MOVE             = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//取消(cancel)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_CANCEL           = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//还有很多就不一 一列举</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>坐标信息也是通过MotionEvent获取，<strong>motionEvent.getRawX()、motionEvent.getRawY()</strong> 可以获得以屏幕作为参考系的坐标值，<strong>motionEvent.getX()、motionEvent.getY()</strong> 可以获得以被触摸的 View 作为参考系的坐标值。参考下面的视图坐标：</p><img src="/2019/07/29/View的事件分发机制/view1.png" title="view1"><p>蓝色点想象成手指触摸屏幕的位置。</p><h3 id="3、一个事件序列"><a href="#3、一个事件序列" class="headerlink" title="3、一个事件序列"></a>3、一个事件序列</h3><p>从手指按下屏幕到抬起，在这个过程中所产生的一系列事件，就是一个事件序列，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。所以可能会有下面两种事件序列：</p><ul><li>ACTION_DOWN -&gt; ACTION_UP：手指按下屏幕后又抬起</li><li>ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_MOVE -&gt; ACTION_UP：手指按下屏幕，滑动一会，然后抬起</li></ul><p>在分析事件分发的过程时，会有事件序列这个概念。</p><h3 id="4、事件分发的起点，事件从何而来"><a href="#4、事件分发的起点，事件从何而来" class="headerlink" title="4、事件分发的起点，事件从何而来"></a>4、事件分发的起点，事件从何而来</h3><p>我想大家都知道View的事件分发机制的起点是View的dispatchTouchEvent()方法，但是如果从View的dispatchTouchEvent()继续追溯上去，事件是从哪里来的呢？</p><p>Android的输入设备有很多种，如屏幕、键盘、鼠标、轨迹球等，而屏幕是我们接触最多的设备，当用户手指触摸屏幕时就会产生触摸事件，这时Android的输入系统就会为这个触摸事件在/dev/input/路径下写入以event[NUMBER]为名的输入设备节点，这时输入系统中的EventHub就会监听到这个输入事件，然后InputReader就会把这个原始输入事件读取并经过加工后交给输入系统中的InputDispatcher，InputDispatcher会在Window列表中会找到合适的Window，然后把这个输入事件分发给合适的Window，然后Window就会把这个事件分发给顶级View，<strong>然后顶级View就把这个输入事件在View树中层层分发下去，直到找到合适的View来处理这个事件，这来到了我们熟悉的View的事件分发机制</strong>。</p><p>上面的一些名词如EventHub、InputReader、InputReader都是属于Android的输入系统，这部分是一个很复杂的知识，我只是概括了一下。所以我们只要知道，<strong>输入系统监听到输入事件后，就会先交给Window，然后Window再交给顶级View，然后顶级View在把它分发下去</strong>。(关于Window和View的关系可以看这篇文章<a href="https://rain9155.github.io/2019/03/22/Window,%20WindowManager%E5%92%8CWindowManagerService%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" target="_blank" rel="noopener">Window, WindowManager和WindowManagerService之间的关系</a>)</p><p>这个顶级View可能是View，也有可能是ViewGroup，具体情况看你添加Window到WMS时你的addView(View view, ViewGroup.LayoutParams params)方法中的View是View实例还是ViewGroup实例，所以本文接下来就分别分析View的事件分发和ViewGroup的事件分发。</p><h2 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h2><h3 id="1、View-dispatchTouchEvent"><a href="#1、View-dispatchTouchEvent" class="headerlink" title="1、View::dispatchTouchEvent()"></a>1、View::dispatchTouchEvent()</h3><p>View的事件分发比ViewGroup的简单，因为它只是一个单独的元素，所以它只需要处理自己的事件，View的事件分发从View的dispatchTouchEvent()方法开始，所以我们看它的dispatchTouchEvent方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//result默认为false</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        li != <span class="keyword">null</span><span class="comment">//如果ListenerInfo不为空</span></span><br><span class="line">        &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span><span class="comment">//如果触摸事件的监听不为空</span></span><br><span class="line">        &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED<span class="comment">//如果该控件是ENABLED状态</span></span><br><span class="line">        &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)<span class="comment">//如果onTouch方法返回了true</span></span><br><span class="line">    )&#123;</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        !result<span class="comment">//如果上面四个条件都不满足，result默认为false</span></span><br><span class="line">        &amp;&amp; onTouchEvent(event)<span class="comment">//如果onTouchEvent()方法返回了true</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerInfo</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> OnClickListener mOnClickListener;<span class="comment">//点击事件的监听</span></span><br><span class="line">     <span class="keyword">protected</span> OnLongClickListener mOnLongClickListener;<span class="comment">//长按事件的监听</span></span><br><span class="line">     <span class="keyword">private</span> OnTouchListener mOnTouchListener;<span class="comment">//触摸事件的监听</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从View的dispatchTouchEvent()方法的伪代码可以看出，dispatchTouchEvent()方法首先会根据4个条件来决定是否调用View的onTouchEvent方法，如下：</p><ul><li><p>1、如果ListenerInfo不为空：ListenerInfo里面有View的各种监听，那么mListenerInfo是什么时候被赋值的呢？答案是给View设置监听的时候，在我们给View设置任何监听的时候，如果这个mListenerInfo还没初始化就会先初始化，比如设置触摸事件的监听，我们看setOnTouchListener()方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnTouchListener</span><span class="params">(OnTouchListener l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先调用getListenerInfo方法初始化mListenerInfo，然后把触摸事件的监听赋值给mOnTouchListener</span></span><br><span class="line">    getListenerInfo().mOnTouchListener = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function">ListenerInfo <span class="title">getListenerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (mListenerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">      &#125;</span><br><span class="line">      mListenerInfo = <span class="keyword">new</span> ListenerInfo();</span><br><span class="line">      <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>2、如果触摸事件的监听不为空：即ListenerInfo的mOnTouchListener不为空，从1可以看出，当你给View设置OnTouchListener时，就已经满足了1、2条件了。</p></li><li>3、如果该控件是ENABLED状态：即该Vew处于enable状态，如果你没有手动调用过View的setEnable(false)设置控件为不可用的话，这个条件就为true，控件默认为enable状态。</li><li>4、如果onTouch方法返回了true：当你给View设置OnTouchListener，并且在onTouch方法中返回了true，表示消费了这次事件，那么这个条件就为true。所以到这里，如果4个条件都满足的话，result就会等于true，就会导致下面无法调用View的onTouchEvent()方法。</li></ul><p>但是如果你<strong>没有给你给View设置OnTouchListener或者你给View设置了OnTouchListener，但是onTouch方法返回了false</strong>，只要满足这两个条件之一，就会让result保持默认值false，从而满足下面的条件调用View的onTouchEvent()方法。这里得出一个结论：<strong>OnTouchListener的onTouch方法的优先级高于onTouchEvent()方法</strong>。</p><p>假设现在不满足上面4个条件，从而调用View的onTouchEvent()方法，我们来看View的onTouchEvent()方法。</p><h3 id="2、View-onTouchEvent"><a href="#2、View-onTouchEvent" class="headerlink" title="2、View::onTouchEvent()"></a>2、View::onTouchEvent()</h3><p>onTouchEvent()方法里面会处理View点击事件、长按事件，即回调你设置的OnClickListener的onClick()方法和OnLongClickListener的OnLongClick()方法，在你设置OnClickListener或OnLongClickListener回调时会同时把你的View设置为可点击状态即clickable状态，有些控件默认可点击如Button，而有些控件需要设置点击回调或setClickable(true)才可以点击如TextView。</p><p>接下来我们看View的onTouchEvent()方法的主要源码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"><span class="comment">//该View是否可点击，可以看到这里点击包含3种点击：CLICKABLE、LONG_CLICKABLE和CONTEXT_CLICKABLE(回调OnContextClickListener)</span></span><br><span class="line">    <span class="comment">//这里我们关注CLICKABLE和LONG_CLICKABLE就行，即点击和长按</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">        || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">        || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line">    <span class="comment">//1、如果View处于disabled状态，即不可用状态</span></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">        <span class="comment">//这里说明了即使View处于不可用状态，但是如果它可以点击，它还是会消费点击事件</span></span><br><span class="line">        <span class="keyword">return</span> clickable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、如果View设置有代理机制，那么就会执行TouchDelegate的onTouchEvent()方法</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、下面是onTouchEvent()对点击事件和长按事件的处理</span></span><br><span class="line">    <span class="comment">//如果控件可以点击</span></span><br><span class="line">    <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从这里看出，如果我们的View是可以点击的，最终一定返回true，表示消费了此事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、最终虽然控件可用，但是不可点击，返回false，不消费此事件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个onTouchEvent()方法有点长，这里我截取了整体框架，这里我们先明确一点的是onTochEvent()中返回true就表示这个事件由这个View消费，返回false就表示这个View不消费这个事件然后它的父容器会继续找合适的View消费。首先我们看注释1，它说明了即使View处于不可用状态，但是如果它可以点击即clickable = true，它会返回true，表明不可用状态下的View它还是会消费事件，即使这个View会没有响应，反之返回false；接着注释2，如果设置了mTouchDelegate，则会将事件交给代理者处理，直接return true，如果大家希望自己的View增加它的touch范围，可以尝试使用TouchDelegate；接着注释3，如果控件可以点击，就判断事件类型：ACTION_UP、ACTION_DOWN、ACTION_CANCEL、ACTION_MOVE，然后根据不同的事件类型做出不同的行为，然后都返回了true，表示消费了此事件；最后注释4如果控件不可点击，就返回false，不消费此事件。</p><p>接下来我们重点看注释3，看onTouchEvent()是如何在ACTION_UP、ACTION_DOWN、ACTION_CANCEL、ACTION_MOVE中触发onClick()和onLingClick()回调的。</p><h4 id="2-1、case-ACTION-DOWN"><a href="#2-1、case-ACTION-DOWN" class="headerlink" title="2.1、case ACTION_DOWN:"></a>2.1、case ACTION_DOWN:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="comment">//1、设置mHasPerformedLongPress为false</span></span><br><span class="line">          mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="comment">//2、给mPrivateFlags设置一个PREPRESSED标识</span></span><br><span class="line">           mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">          <span class="comment">//3、通过postDelayed发送一个延时100毫秒后执行的任务mPendingCheckForTap</span></span><br><span class="line">          postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>我们想象一下，我们的手指按下这个View，这时进入ACTION_DOWN分支，在这个分支里，在注释1中它首先设置mHasPerformedLongPress为false，表示长按事件还没有触发，然后在注释2给mPrivateFlags设置一个PREPRESSED的标识，表示开始检查长按事件，然后在注释3通过postDelayed发送了一个延时消息，ViewConfiguration.getTapTimeout()返回100毫秒，即100毫秒后会执行任务mPendingCheckForTap，它一个CheckForTap类型任务，它是用来<strong>检测长按事件</strong>的。我们看这个任务是什么，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java </span></span><br><span class="line"><span class="comment">//用来检测长按事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckForTap</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">float</span> x;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1、mPrivateFlags清除PFLAG_PREPRESSED标识</span></span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_PREPRESSED;</span><br><span class="line">            <span class="comment">//2、见下面调用链，这里传入true，即给mPrivateFlags设置一个PFLAG_PRESSED标识</span></span><br><span class="line">            setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">            <span class="comment">//3、调用checkForLongClick()方法，传入100毫秒</span></span><br><span class="line">            checkForLongClick(ViewConfiguration.getTapTimeout(), x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPressed</span><span class="params">(<span class="keyword">boolean</span> pressed, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//主要调用了带一个参数的setPressed(pressed)方法</span></span><br><span class="line">        setPressed(pressed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置控件是否处于按下状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPressed</span><span class="params">(<span class="keyword">boolean</span> pressed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (pressed) &#123;<span class="comment">//如果pressed为true</span></span><br><span class="line">        <span class="comment">//给mPrivateFlags设置一个PFLAG_PRESSED标识</span></span><br><span class="line">        mPrivateFlags |= PFLAG_PRESSED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果pressed为false</span></span><br><span class="line">        <span class="comment">//清除mPrivateFlags之前设置的PFLAG_PRESSED标识</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_PRESSED;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mPendingCheckForTap的run方法里面在注释1首先会先清除mPrivateFlags中PFLAG_PREPRESSED标识，然后在注释2设置PFLAG_PRESSED标识，表示准备执行长按事件，最主要的是注释3，我们看checkForLongClick方法里面干了什么，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForLongClick</span><span class="params">(<span class="keyword">int</span> delayOffset, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、检查mViewFlags，如果可以进行长按事件LONG_CLICKABLE</span></span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">        <span class="comment">//此时mHasPerformedLongPress标志位还是false</span></span><br><span class="line">        mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPendingCheckForLongPress == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2、创建了一个CheckForLongPress类型的任务</span></span><br><span class="line">            mPendingCheckForLongPress = <span class="keyword">new</span> CheckForLongPress();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//3、ViewConfiguration.getLongPressTimeout()返回500毫秒，再减100毫秒等于400毫秒</span></span><br><span class="line">        <span class="comment">//通过postDelayed()发送延时400毫秒后执行的任务mPendingCheckForLongPress</span></span><br><span class="line">        postDelayed(mPendingCheckForLongPress,</span><br><span class="line">                    ViewConfiguration.getLongPressTimeout() - delayOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在注释1首先检测该View是否可以进行长按事件，View的LONG_CLICKABLE属性默认为false，但是在setOnLongClickListener（）时就会把它设置为true，然后在注释2创建了一个CheckForLongPress类型的任务，然后在注释3通过postDelayed()发送了一个延时消息，即400毫秒后执行mPendingCheckForLongPress任务，它是用来<strong>执行长按事件</strong>的，我们看这个任务的具体实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="comment">//用来执行长按事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckForLongPress</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> mX;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> mY;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((mOriginalPressedState == isPressed())<span class="comment">//1、首先检查mPrivateFlags中是否清除了PFLAG_PRESSED标识，如果清除了表示长按事件取消</span></span><br><span class="line">                &amp;&amp; (mParent != <span class="keyword">null</span>)</span><br><span class="line">                &amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) &#123;</span><br><span class="line">                <span class="comment">//2、调用performLongClick()方法</span></span><br><span class="line">                <span class="keyword">if</span> (performLongClick(mX, mY)) &#123;</span><br><span class="line">                    <span class="comment">//3、设置mHasPerformedLongPress为true</span></span><br><span class="line">                    mHasPerformedLongPress = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (performLongClick(mX, mY)) &#123;</span><br><span class="line">                mHasPerformedLongPress = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回true表示检测mPrivateFlags中清除了PFLAG_PRESSED标识，false反之</span></span><br><span class="line">    <span class="keyword">return</span> (mPrivateFlags &amp; PFLAG_PRESSED) == PFLAG_PRESSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CheckForLongPress就是用于执行长按事件的，它的run方法里面会先检查mPrivateFlags中是否清除了PFLAG_PRESSED标识，如果清除了就表示长按事件取消，否则就调用performLongClick()方法，里面会最终回调onLongClick()方法回调，如果performLongClick()返回true，就会设置mHasPerformedLongPress为true，否则mHasPerformedLongPress还是为false，即<strong>mHasPerformedLongPress是否为true取决performLongClick(float x, float y)是否返回true</strong>，接下来我们看performLongClick(float x, float y)方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performLongClick</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled = performLongClick();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performLongClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> performLongClickInternal(mLongClickX, mLongClickY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performLongClickInternal</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="comment">//如果设置了OnLongClickListener回调</span></span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLongClickListener != <span class="keyword">null</span>) &#123;       </span><br><span class="line">        <span class="comment">//回调OnLongClickListener的onLongClick方法</span></span><br><span class="line">        handled = li.mOnLongClickListener.onLongClick(View.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中一路跟进，最终来到了performLongClickInternal(float x, float y)方法中，在performLongClickInternal()方法中，如果我们通过setOnLongClickListener()设置了OnLongClickListener回调，这里就会回调我们熟悉的onLongClick()方法，而performLongClickInternal()是否返回true取决于我们在onLongClick()方法中是否返回true，performLongClick()是否返回true取决于performLongClickInternal()是否返回true，然后这里结合上面的黑体字得出一个结论：<strong>如果你设置了onLongClickListener，mHasPerformedLongPress是否为true取决我们在onLongClick()方法中是否返回true，如果没有设置，mHasPerformedLongPress就一直为false</strong>，这个mHasPerformedLongPress是否为true会影响我们在ACTION_UP是否能够回调onClick()方法的关键。</p><p>现在我们通过case ACTION_DOWN知道：<strong>如果我们按下手指在500毫秒内没有抬起，就会触发长按事件</strong>。下面分析ACTION_UP。</p><h4 id="2-2、case-ACTION-UP"><a href="#2-2、case-ACTION-UP" class="headerlink" title="2.2、case ACTION_UP:"></a>2.2、case ACTION_UP:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (action) &#123;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1、如果mPrivateFlags中包含PFLAG_PRESSED或PFLAG_PREPRESSED标识，都会进入if分支</span></span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (prepressed) &#123;<span class="comment">//如果mPrivateFlags中只包含PFLAG_PREPRESSED标识，表示用户在100毫秒内抬起了手指，还没执行CheckForTap任务</span></span><br><span class="line">                <span class="comment">//2、这里传入为true，即给mPrivateFlags设置一个PFLAG_PRESSED标识</span></span><br><span class="line">                <span class="comment">//这里主要让用户看到控件还是按下状态</span></span><br><span class="line">                setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">//3、这个mHasPerformedLongPress为false就进入if分支，mIgnoreNextUpEvent默认为false</span></span><br><span class="line">            <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                <span class="comment">//4、移除长按事件CheckForLongPress任务消息，即取消长按事件</span></span><br><span class="line">                removeLongPressCallback();</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//5、如果mPerformClick为null，初始化一个实例</span></span><br><span class="line">                    mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//6、通过Handler把mPerformClick添加到消息队列，但其实PerformClick中的run方法还是执行performClick()方法，所以我们只要看performClick()方法就行</span></span><br><span class="line">                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                    <span class="comment">//如果post一个PerformClick失败就执行performClick()方法</span></span><br><span class="line">                    performClick();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//7、移除检测长按事件CheckForTap任务消息，即取消检测长按事件</span></span><br><span class="line">            removeTapCallback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="comment">//PerformClick中的run方法还是执行performClick()方法</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformClick</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         performClick();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们想象一下，现在我们抬起了手指，分三个时间段抬起：</p><ul><li><p>1、如果你在<strong>100毫秒内</strong>抬起手指，那么mPrivateFlags肯定只有PFLAG_PREPRESSED标识，且mHasPerformedLongPress为false，根据注释1和3，这样就会执行PerformClick()方法，在执行PerformClick()方法前，在注释4调用removeLongPressCallback()移除长按事件CheckForLongPress任务，即不会触发onLongClick()回调。</p></li><li><p>2、如果你在<strong>100毫秒后到500毫秒</strong>才抬起，那么mPrivateFlags肯定只有PFLAG_PRESSED标识，且mHasPerformedLongPress为false，接下来的逻辑和1一样。</p></li><li><p>3、如果你在<strong>500毫秒后</strong>才抬起，那么mPrivateFlags肯定只有PFLAG_PRESSED标识，而mHasPerformedLongPress是否为true取决我们是否设置onLongClickListener并在onLongClick()方法中是否返回true。如果你设置了onLongClickListener回调并在onLongClick()方法中返回了false或者你没有设置onLongClickListener回调，那么你还是可以走到注释6执行performClick()方法；但是如果你设置了onLongClickListener回调并在onLongClick()方法中返回了true，那么你就不能执行performClick()方法了。</p></li></ul><p>对照ACTION_DOWN的流程和ACTION_UP的流程就能更好的理解上面3个时间段，所以从这里我们知道：<strong>如果你在500毫秒内抬起手指，那么你就只能执行点击事件，不能执行长按事件；如果你在500毫秒后抬起，并且你设置了onLongClickListener并在onLongClick()方法中返回了false 或者 你没有设置onLongClickListener回调，那么你执行完长按事件后还可以执行点击事件，但是如果你设置了onLongClickListener回调并在onLongClick()方法中返回了true，那么你就不能执行点击事件</strong>。performClick()和 performLongClick()方法类似，它里面最终回调onClick()方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">     <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">     <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//1、执行了OnClickListener的onClick()方法</span></span><br><span class="line">         li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">         result = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         result = <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>performClick()方法中的逻辑是，如果你设置了OnClickListener回调，那么就会执行onClick(）方法，大家也注意到performClick()会返回一个true或者false，但是这个返回值对于onTouchEvent()方法没有任何意义，因为上面提到switch语句块的后面一定返回true。这里我们再得出一个结论：<strong>OnLongClickListener的onLongClick()方法的优先级高于onClickListener的onClick()方法</strong>。</p><p>好了现在我们的手指从按下到抬起，就已经分析完onTouchEvent()中的ACTION_DOWN和ACTION_UP分支，如果你的手指在抬起前，不小心移动了一下，就会触发ACTION_CANCEL或ACTION_MOVE，这个时候它就会根据条件(手指是否移出View的范围)通过调用 removeLongPressCallback()或 removeTapCallback()方法移除CheckForLongPress或CheckForTap任务，即取消长按或点击，这里限于篇幅就不再展开分析，大家可自行分析。</p><h3 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h3><p>1、View没有子View，所以它的的分发比较简单，从View的dispatchTouchEvent()方法开始进入View的事件分发流程，该方法只负责事件的分发，没有进行实际事件的处理，进行实际事件的处理有两处地方：1、通过外部设置的onTouchListener的onTouch()方法，2、View的onTouchEvent()方法。</p><p>2、当一个View要处理点击事件时，如果它设置了onTouchListener，那么onTouch方法就会回调，这时事件如何处理还要看onTouch()方法的返回值，如果返回true，那么onTouchEvent()方法将不会被调用，dispatchTouchEvent()方法直接返回true；如果返回false，onTouchEvent()方法会被调用，这时事件如何处理就要看onTouchEvent()的返回值，在onTouchEvent()中，不管控件可用还是不可用，返回值取决于控件是否可点击，如果控件可点击(clickabale或longClickabale，只要有一个为true)，onTouchEvent()返回true，如果控件不可点击(clickabale和longClickabale都为false)，onTouchEvent()返回false。</p><p>3、如果我们同时设置了OnTouchListener、OnLongClickListener和OnClickListener回调，根据优先级，事件的传递顺序是：<strong>onTouch() -&gt; onLongClick() -&gt; onClick()</strong>，其中除了onClick()都有boolean返回值，返回值能决定下一个方法是否被调用，onClick()优先级最低，连返回值都没有。</p><p>4、 对于ViewGroup（也就是当前 View 的父容器）而言，它只认识子 View的dispatchTouchEvent()方法，不认识另外两个处理事件的方法。子View的 onTouch()  和 onTouchEvent() 都是在自己的 dispatchTouchEvent() 里面调用的，他们两个会影响 dispatchTouchEvent() 的返回值，但是对于上级 ViewGroup 而言，它只认识 dispatchTouchEvent() 的返回值。</p><p>流程图：</p><img src="/2019/07/29/View的事件分发机制/view2.png" title="view2"><h2 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h2><h3 id="1、ViewGroup-dispatchTouchEvent"><a href="#1、ViewGroup-dispatchTouchEvent" class="headerlink" title="1、ViewGroup::dispatchTouchEvent()"></a>1、ViewGroup::dispatchTouchEvent()</h3><p>ViewGroup是View的子类，它是一组View的集合，它包含很多子View和子ViewGroup，所以ViewGroup的事件分发比View的复杂，但是ViewGroup的事件分发才是整个事件分发机制的精髓，和View一样ViewGroup的事件分发的起点也是dispatchTouchEvent()，虽然这个方法在View中，但是ViewGroup重写了它，因为它们的分发逻辑不一样。所以我们看ViewGroup的dispatchTouchEvent()方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//本次事件处理结果</span></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">        <span class="comment">//1、如果本次事件是ACTION_DOWN</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">//置空mFirstTouchTarget</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            <span class="comment">//清除mGroupFlags中的FLAG_DISALLOW_INTERCEPT标志位，这个标志等同于下面的disallowIntercept</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ViewGroup是否拦截本次事件标志</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="comment">//2、如果本次事件是ACTION_DOWN 或者 mFirstTouchTarget为空</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">            || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//子View是否禁止ViewGroup拦截事件标志</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;<span class="comment">//如果子View允许ViewGroup拦截事件</span></span><br><span class="line">                <span class="comment">//调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定</span></span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果子View禁止ViewGroup拦截事件</span></span><br><span class="line">                intercepted = <span class="keyword">false</span>;<span class="comment">//intercepted值为false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果本次事件不是ACTION_DOWN又没有target</span></span><br><span class="line">            <span class="comment">//intercepted值为true，在此之后，当前事件序列中的所有事件序列都由ViewGroup处理，不会再传递给子View</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//检查本次事件是否是ACTION_CANCEL</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//3、如果本次事件不取消并且不拦截，就寻找合适的子View处理</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//3.1、如果本次事件是ACTION_DOWN</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">               </span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="comment">//如果target是null并且ViewGroup有子View，就寻找某个子View当mFirstTouchTarget</span></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="comment">//从后往前逐个取出子View</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">                        <span class="comment">//判断子View能否接受点击事件：子View可见或在播放动画，并且触摸点在子View范围内</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">  <span class="comment">//走到这里表示子View满足处理事件的条件</span></span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                        <span class="comment">//dispatchTransformedTouchEvent()里面会调用子View的dispatchTouchEvent()方法，在这个方法里把事件分发给子View</span></span><br><span class="line">                         <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                              <span class="comment">//...</span></span><br><span class="line">                               <span class="comment">//如果dispatchTransformedTouchEvent()返回true，表示找到子View消费本次事件了，就会走到这里, 所以这个子View就被当作mFirstTouchTarget，这里会调用addTouchTarget()方法为mFirstTouchTarget赋值</span></span><br><span class="line">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                                alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">                    &#125;<span class="comment">//end...for（）</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="comment">//end...if(newTouchTarget == null &amp;&amp; childrenCount != 0)</span></span><br><span class="line">                </span><br><span class="line">            &#125;<span class="comment">//end...if(actionMasked == MotionEvent.ACTION_DOWN...)</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="comment">///end...if(!canceled &amp;&amp; !intercepted)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、根据mFirstTouchTarget是否为null做出不同行为</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;<span class="comment">//这一般有三种情况导致mFirstTouchTarget为空：</span></span><br><span class="line">            <span class="comment">//1、ViewGroup没有子View；</span></span><br><span class="line">            <span class="comment">//2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false；</span></span><br><span class="line">            <span class="comment">//3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true</span></span><br><span class="line">       <span class="comment">//在这三种情况下ViewGroup就会自己处理事件</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                                                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target：</span></span><br><span class="line">            <span class="comment">//1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target；</span></span><br><span class="line">            <span class="comment">//2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target</span></span><br><span class="line">           <span class="comment">//所以接下来就直接把事件分发给mFirstTouchTarget的child处理处理就行</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="comment">//mFirstTouchTarget是一个单链表结构</span></span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;<span class="comment">//情况1的处理</span></span><br><span class="line">                    <span class="comment">//因为在找到target时已经调用过dispatchTransformedTouchEvent()了，表示该target的View已经消费了该事件，handle直接等于true</span></span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//情况2的处理</span></span><br><span class="line">                     <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                                || intercepted;<span class="comment">//注意这个intercepted，如果为true，cancelChild为true，会导致子View收到一个ACTION_CANCEL, 表示子View的本次事件取消</span></span><br><span class="line">                    <span class="comment">//调用dispatchTransformedTouchEvent()方法把事件分发给target</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        <span class="comment">//handle的是否为true取决于子View的dispatchTouchEvent()返回值</span></span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//清空这个子View对应的target，导致该事件序列的后序事件该子View都无法再收到</span></span><br><span class="line">                     <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                         <span class="comment">//...</span></span><br><span class="line">                         target.recycle();</span><br><span class="line">                         target = next;</span><br><span class="line">                         <span class="keyword">continue</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;<span class="comment">//end...while (target != null) </span></span><br><span class="line">            </span><br><span class="line">         &#125;<span class="comment">//end...if (mFirstTouchTarget == null)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">    &#125;<span class="comment">//end...if (onFilterTouchEventForSecurity(ev))</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法特别长，里面就是整个ViewGroup的事件分发逻辑，我知道大家也没有想看的欲望了，这个方法对应的流程图如下：</p><img src="/2019/07/29/View的事件分发机制/view3.png" title="view3"><p>可以看到，<strong>在同一个事件序列内（从down开始，到up结束）</strong>，ViewGroup的dispatchTouchEvent()方法可以分为两大过程：<strong>1、ACTION_DOWN事件的处理流程；2、除了ACTION_DOWN以外的事件处理流程</strong>。下面跟着这两个流程分别走一遍。</p><h3 id="2、ViewGroup处理ACTION-DOWN事件的流程"><a href="#2、ViewGroup处理ACTION-DOWN事件的流程" class="headerlink" title="2、ViewGroup处理ACTION_DOWN事件的流程"></a>2、ViewGroup处理ACTION_DOWN事件的流程</h3><p>ACTION_DOWN事件的处理流程又可以分为两个流程即：<strong>ViewGroup拦截事件(intercepted = true)与不拦截事件（intercepted = false）</strong>。</p><img src="/2019/07/29/View的事件分发机制/view4.png" title="view4"><p>看流程图，在dispatchTouchEvent()方法注释2中的if语句会决定 intercepted 的值，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup是否拦截本次事件标志</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="comment">//2、如果本次事件是ACTION_DOWN 或者 mFirstTouchTarget为空</span></span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//2.1、子View是否禁止ViewGroup拦截事件标志</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;<span class="comment">//如果子View允许ViewGroup拦截事件</span></span><br><span class="line">        <span class="comment">//调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定</span></span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果子View禁止ViewGroup拦截事件</span></span><br><span class="line">        intercepted = <span class="keyword">false</span>;<span class="comment">//intercepted值为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果本次事件是ACTION_DOWN也会进入这个if分支，看注释2.1检查 mGroupFlags 中是否包含FLAG_DISALLOW_INTERCEPT标识，默认没有，即默认disallowIntercept为false，所以就会调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent()决定，onInterceptTouchEvent()默认返回false，所以<strong>intercepted = false</strong>。</p><h4 id="2-1、intercepted-false"><a href="#2-1、intercepted-false" class="headerlink" title="2.1、intercepted = false"></a>2.1、intercepted = false</h4><p>当DOWN事件没有被ViewGroup拦截，<strong>intercepted = false</strong>，它就会进入dispatchTouchEvent()方法注释3的if语句，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//检查本次事件是否是ACTION_CANCEL</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//3、如果本次事件不取消并且不拦截，就寻找合适的子View处理</span></span><br><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//如果本次事件是ACTION_DOWN</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="comment">//如果target是null并且ViewGroup有子View，就寻找某个子View当mFirstTouchTarget</span></span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">            <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">            <span class="comment">//从后往前逐个取出子View</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">                <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">                <span class="comment">//3.1、判断子View能否接受点击事件：子View可见或在播放动画，并且触摸点在子View范围内</span></span><br><span class="line">                <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                    || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//走到这里表示子View满足处理事件的条件</span></span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="comment">//3.2、dispatchTransformedTouchEvent()里面会调用子View的dispatchTouchEvent()方法，在这个方法里把事件分发给子View</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    <span class="comment">//3.3、如果dispatchTransformedTouchEvent()返回true，表示找到子View消费本次事件了，就会走到这里, 所以这个子View就被当作mFirstTouchTarget，这里会调用addTouchTarget()方法为mFirstTouchTarget赋值</span></span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;<span class="comment">//end...for（）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//end...if(newTouchTarget == null &amp;&amp; childrenCount != 0)</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//end...if(actionMasked == MotionEvent.ACTION_DOWN...)</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">///end...if(!canceled &amp;&amp; !intercepted)</span></span><br></pre></td></tr></table></figure><p>如果是DOWN事件，假设ViewGroup有子View，就会进入for循环，ViewGroup就会遍历所有子View，先在注释3.1中判断这个子View是否满足接收事件的条件，如果不满足，就再找下一个子View，如果满足，就来到了注释3.2，然后调用dispatchTransformedTouchEvent()方法看这个子View是否消费DOWN事件。</p><p>dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="comment">//dispatchTransformedTouchEvent（）只需要关注两个参数：</span></span><br><span class="line"><span class="comment">//@params cancel 是否取消本次事件</span></span><br><span class="line"><span class="comment">//@params child 准备接收分发事件的子View</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel, View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="comment">//1、如果cancel为true，进入这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        <span class="comment">//设置ACTION_CANCEL事件</span></span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2、如果cancel为false，进入这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;<span class="comment">//如果child为空</span></span><br><span class="line">        <span class="comment">//调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件</span></span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果child不为空</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件</span></span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为传入cancel为false，所以来带注释2的if分支，因为传入的child不为空，所以调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件，<strong>到这里DOWN事件就传递给子View，如果子View是一个View，那么它的处理流程就像前面介绍的View的事件分发一样，如果子View是一个ViewGroup，那么它的处理流程就又是ViewGroup的事件分发</strong>。</p><p>好了，假设子View消费这个事件，返回true，则dispatchTransformedTouchEvent()返回true，ViewGrou找到了要消费这个DOWN事件的子View，这时进入注释3.3，调用addTouchTarget(child, idBitsToAssign)方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(@NonNull View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    <span class="comment">//给mFirstTouchTarget赋值</span></span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewGroup::TouchTarget</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TouchTarget <span class="title">obtain</span><span class="params">(@NonNull View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    target.child = child;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果找到了要消费这个DOWN事件的子View，那么这个子View就会被赋值给mFirstTouchTarget的child字段，这个就相当于做了一个记录，当下一个事件到来时，如果发现mFirstTouchTarget不为空，我就可以直接把事件分发给mFirstTouchTarget中的View，就不用再去遍历子View了。那么mFirstTouchTarget是什么？它是一个TouchTarget类型，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///ViewGroup::TouchTarget</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TouchTarget</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前消费事件的View</span></span><br><span class="line">    <span class="keyword">public</span> View child;</span><br><span class="line">    <span class="comment">//它的下一个结点</span></span><br><span class="line">    <span class="keyword">public</span> TouchTarget next;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是一个链表结构，为什么mFirstTouchTarget是一个链表？我的猜测是由于多点触控的存在，例如我5个手指可以同时触摸到列表的5个子View，如果5个子View都是要消费这个DOWN事件的话，那么就要用链表把它们记录起来，当下一个事件到来时，5个子View都能分发到事件。</p><p>好了，现在找到可以消费事件的子View了，并且mFirstTouchTarget也被赋值了，就一个break跳出for循环，直接来到dispatchTouchEvent()方法的注释4，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//4、根据mFirstTouchTarget是否为null做出不同行为</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target：</span></span><br><span class="line">    <span class="comment">//1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target；</span></span><br><span class="line">    <span class="comment">//2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target</span></span><br><span class="line">    <span class="comment">//所以接下来就直接把事件分发给mFirstTouchTarget的child处理就行</span></span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="comment">//mFirstTouchTarget是一个单链表结构</span></span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">        <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;<span class="comment">//情况1的处理</span></span><br><span class="line">            <span class="comment">//因为在找到target时已经调用过dispatchTransformedTouchEvent()了，表示该target的View已经消费了该事件，handle直接等于true</span></span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//情况2的处理</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        predecessor = target;</span><br><span class="line">        target = next;</span><br><span class="line">    &#125;<span class="comment">//end...while (target != null) </span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//end...if (mFirstTouchTarget == null)</span></span><br></pre></td></tr></table></figure><p>mFirstTouchTarget不为空，就来到else分支，然后因为是DOWN事件，在上面的for循环中找到子View消费事件后alreadyDispatchedToNewTouchTarget赋值为true并且mFirstTouchTarget等于newTouchTarget实例，就来到情况1的处理的if分支，这里直接返回了true，因为上面在for循环中target的View已经消费了该事件，handle直接等于true。</p><p>到这里在DOWN事件下ViewGroup不拦截的情况下分析完毕。上面是假设找到了子View并且子View消费了事件，这样当下一次事件到来时mFirstTouchTarget不为空，就直接把这个事件给子View；但是如果上面是找到子View而这个子View不消费这个DOWN事件，即子View的dispatchTouchEvent()方法返回false，那么dispatchTransformedTouchEvent()返回false，就导致无法为mFirstTouchTarget赋值，mFirstTouchTarget为空，当下一次事件序列到来时，ViewGroup会直接处理，而不再转发给子View。这里得出一个结论：<strong>子View如果不消费ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，而是交给它的父ViewGroup处理；子View一旦消费ACTION_DOWN事件，那么同一事件序列的其他事件都会交给它处理</strong>。</p><p>所以如果此时子View没有消费ACTION_DOWN事件，或者我重写了ViewGroup的onInterceptTouchEvent()并返回了true，那么ViewGroup就会开始拦截事件，接下来看在DOWN事件下ViewGroup拦截的情况，即<strong>intercepted = true</strong>。</p><h4 id="2-2、intercepted-true"><a href="#2-2、intercepted-true" class="headerlink" title="2.2、intercepted = true"></a>2.2、intercepted = true</h4><p>如果ViewGroup拦截DOWN事件，那么<strong>intercepted = true</strong>，就不会进入dispatchTouchEvent()方法的注释3的if语句，这样在DOWN事件下ViewGroup就不会遍历它的子View，也就无法调用dispatchTransformedTouchEvent()找到要消费事件的子View，同理无法调用addTouchTarget()方法为mFirstTouchTarget赋值，就会导致在DOWN事件下mFirstTouchTarget为空，这样就直接来到了dispatchTouchEvent()方法的注释4的if语句，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//检查本次事件是否是ACTION_CANCEL</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"><span class="comment">//...   </span></span><br><span class="line"><span class="comment">//4、根据mFirstTouchTarget是否为null做出不同行为</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;<span class="comment">//这一般有三种情况导致mFirstTouchTarget为空：</span></span><br><span class="line">    <span class="comment">//1、ViewGroup没有子View；</span></span><br><span class="line">    <span class="comment">//2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false；</span></span><br><span class="line">    <span class="comment">//3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true</span></span><br><span class="line">    <span class="comment">//在这三种情况下ViewGroup就会自己处理事件</span></span><br><span class="line">    <span class="comment">//注意第三个参数传入null，表示ViewGroup自己处理事件</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                                            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;         </span><br><span class="line">    <span class="comment">//...           </span></span><br><span class="line">&#125;<span class="comment">//end...if (mFirstTouchTarget == null)</span></span><br></pre></td></tr></table></figure><p>很明显这里是情况3，所以没有找到子View，dispatchTransformedTouchEvent()方法的第三个参数为空，而第二个参数为false，因为不是ACTION_CANCEL事件，我们参考上面的dispatchTransformedTouchEvent()方法分析，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="comment">//dispatchTransformedTouchEvent（）只需要关注两个参数：</span></span><br><span class="line"><span class="comment">//@params cancel 是否取消本次事件</span></span><br><span class="line"><span class="comment">//@params child 准备接收分发事件的子View</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel, View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2、如果cancel为false，进入这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;<span class="comment">//如果child为空</span></span><br><span class="line">        <span class="comment">//调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件</span></span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果child不为空</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件</span></span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面就会调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件，ViewGroup的父类是View，所以super.dispatchTouchEvent(event)里面的处理逻辑就是View的事件分发的处理逻辑，见前面分析的View的事件分发。</p><p>到这里在DOWN事件下ViewGroup拦截的情况分析完毕。这里得出一个结论：<strong>ViewGroup如果在onInterceptTouchEvent()方法的ACTION_DOWN事件中返回true，那么整个事件序列都会交给ViewGroup处理，不再交给子View</strong>。</p><p>我们回到dispatchTouchEvent()方法，还有一点要注意的是在ACTION_DOWN下不管拦截还是不拦截都会进入dispatchTouchEvent()方法中注释1的if语句，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1、如果本次事件是ACTION_DOWN</span></span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">//置空mFirstTouchTarget</span></span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    <span class="comment">//清除mGroupFlags中的FLAG_DISALLOW_INTERCEPT标志位，这个标志等同于下面的disallowIntercept</span></span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个if语句的作用就是防止前一次事件序列对本次事件序列造成影响，所以它会向先调用 cancelAndClearTouchTargets(ev)清空mFirstTouchTarget，然后调用resetTouchState()清除FLAG_DISALLOW_INTERCEPT标志位，因为ACTION_DOWN事件是一个新的事件序列的开始，所以dispatchTouchEvent()方法首先要做的就是判断是不是迎来了一个新的事件序列，所以要判断该事件是否是ACTION_DOWN 事件，如果是 ACTION_DOWN 事件，作为一个事件序列的开头，应当要消除前面的事件序列可能留下的影响。关于FLAG_DISALLOW_INTERCEPT标志位后面会讲。</p><p>到这里ViewGroup处理ACTION_DOWN事件的流程分析完毕，下面我们来看除了ACTION_DOWN以外的事件的处理流程。</p><h3 id="3、ViewGroup处理除了ACTION-DOWN以外的事件的流程"><a href="#3、ViewGroup处理除了ACTION-DOWN以外的事件的流程" class="headerlink" title="3、ViewGroup处理除了ACTION_DOWN以外的事件的流程"></a>3、ViewGroup处理除了ACTION_DOWN以外的事件的流程</h3><p>ACTION_DOWN事件的处理流程又可以分为两个流程即：<strong>mFirstTouchTarget != null与mFirstTouchTarget == null</strong>。你会发现intercepted这个标记位似乎已经没有多大作用， 它如果是true，它根本不会进入dispatchTouchEvent()方法的注释3，就算是false进入了dispatchTouchEvent()方法的注释3，它也不会满足注释3.1的条件。所以我们就直接来到注释4。</p><img src="/2019/07/29/View的事件分发机制/view5.png" title="view5"><h4 id="3-1、mFirstTouchTarget-null"><a href="#3-1、mFirstTouchTarget-null" class="headerlink" title="3.1、mFirstTouchTarget == null"></a>3.1、mFirstTouchTarget == null</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//检查本次事件是否是ACTION_CANCEL</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"><span class="comment">//...   </span></span><br><span class="line"><span class="comment">//4、根据mFirstTouchTarget是否为null做出不同行为</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;<span class="comment">//这一般有三种情况导致mFirstTouchTarget为空：</span></span><br><span class="line">    <span class="comment">//1、ViewGroup没有子View；</span></span><br><span class="line">    <span class="comment">//2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false；</span></span><br><span class="line">    <span class="comment">//3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true</span></span><br><span class="line">    <span class="comment">//在这三种情况下ViewGroup就会自己处理事件</span></span><br><span class="line">    <span class="comment">//注意第三个参数传入null，表示ViewGroup自己处理事件</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                                            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;         </span><br><span class="line">    <span class="comment">//...           </span></span><br><span class="line">&#125;<span class="comment">//end...if (mFirstTouchTarget == null)</span></span><br></pre></td></tr></table></figure><p>这里1、2、3情况都有可能发生，<strong>从ACTION_DOWN的处理流程我们知道为mFirstTouchTarget赋值的过程只会在处理ACTION_DOWN事件的时候出现</strong>，所以如果在处理ACTION_DOWN事件的时候ViewGroup没有子View，不会进入for循环，导致mFirstTouchTarget为空；如果ViewGroup有子View，进入了for循环，但是View不消费DOWN事件，即在dispatchTouchEvent()返回了false，导致无法调用addTouchTarget()方法为mFirstTouchTarget赋值，导致mFirstTouchTarget为空；ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true，不会进入注释3的if语句，导致mFirstTouchTarget为空；所以在处理ACTION_DOWN事件的时候没有找到mFirstTouchTarget，就会导致在除了ACTION_DOWN其他事件到来时mFirstTouchTarget == null，这里就直接让ViewGroup自己处理事件了。</p><h4 id="3-2、mFirstTouchTarget-null"><a href="#3-2、mFirstTouchTarget-null" class="headerlink" title="3.2、mFirstTouchTarget != null"></a>3.2、mFirstTouchTarget != null</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//4、根据mFirstTouchTarget是否为null做出不同行为</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target：</span></span><br><span class="line">    <span class="comment">//1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target；</span></span><br><span class="line">    <span class="comment">//2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target</span></span><br><span class="line">    <span class="comment">//所以接下来就直接把事件分发给mFirstTouchTarget的child处理就行</span></span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="comment">//mFirstTouchTarget是一个单链表结构</span></span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">        <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;<span class="comment">//情况1的处理</span></span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//情况2的处理</span></span><br><span class="line">             <span class="comment">//4.1</span></span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                                || intercepted;<span class="comment">//注意这个intercepted，如果为true，cancelChild为true，会导致子View收到一个ACTION_CANCEL, 表示子View的本次事件取消</span></span><br><span class="line">                    <span class="comment">//4.2、调用dispatchTransformedTouchEvent()方法把事件分发给target</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        <span class="comment">//handle的是否为true取决于子View的dispatchTouchEvent()返回值</span></span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//4.3、清空这个子View对应的target，导致该事件序列的后序事件该子View都无法再收到</span></span><br><span class="line">                     <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                         <span class="comment">//...</span></span><br><span class="line">                         target.recycle();</span><br><span class="line">                         target = next;</span><br><span class="line">                         <span class="keyword">continue</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">        &#125;</span><br><span class="line">        predecessor = target;</span><br><span class="line">        target = next;</span><br><span class="line">    &#125;<span class="comment">//end...while (target != null) </span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//end...if (mFirstTouchTarget == null)</span></span><br></pre></td></tr></table></figure><p>mFirstTouchTarget != null，表示在处理ACTION_DOWN事件的时候已经找到mFirstTouchTarget，就会进入注释4的else分支，这里是情况2，就会进入情况2的处理的else分支，注释4.1的cancelChild这个值会决定子View是收到ACTION_CANCEL事件还是其他事件，而cancelChild的值取决于intercepted的值，所以如果ViewGroup在除了ACTION_DOWN以外的其他事件中的onInterceptTouchEvent(ev)方法返回了true，导致intercepted = true，从而cancelChild = true，而如果ViewGroup一直保持默认状态，intercepted = false，从而cancelChild = false，紧接着在注释4.2把cancelChild和target.child传进了dispatchTransformedTouchEvent()方法中。</p><p>我再贴一下dispatchTransformedTouchEvent()方法的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel, View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="comment">//1、如果cancel为true，进入这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        <span class="comment">//设置ACTION_CANCEL事件</span></span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="comment">//分发ACTION_CANCEL事件</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2、如果cancel为false，进入这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件</span></span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件</span></span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果cancel为true，进入注释1这个if分支，里面会set一个ACTION_CANCEL事件，然后传递给target记录的子View；如果cancel为false，进入注释2这个else分支，调用child.dispatchTouchEvent(event)，表示让target记录的子View决定是否处理本次事件，前面已经讲过了。</p><p>好，现在我们走出dispatchTransformedTouchEvent()方法，来到注释4，如果cancelChild为true，就会调用TouchTarget的recycler()方法回收这个target，这样做的后果是什么呢？这样相当于清空了mFirstTouchTarget，当下一次事件到来时mFirstTouchTarget == null，ViewGroup直接处理事件，不会再分发给子View。</p><p>到这里ViewGroup处理除了ACTION_DOWN以外事件的流程分析完毕。</p><h3 id="4、子View如何禁止ViewGroup拦截事件"><a href="#4、子View如何禁止ViewGroup拦截事件" class="headerlink" title="4、子View如何禁止ViewGroup拦截事件"></a>4、子View如何禁止ViewGroup拦截事件</h3><p>前面的分析都是默认子View不禁止ViewGroup拦截事件，所以ViewGroup可以通过onInterceptTouchEvent()返回true从而拦截下子View的事件，但此时子View希望依然能够响应这些事件该怎么办呢？Android给我们提供了一个方法：requestDisallowInterceptTouchEvent(boolean) 用于设置是否允许拦截，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDisallowInterceptTouchEvent</span><span class="params">(<span class="keyword">boolean</span> disallowIntercept)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (disallowIntercept) &#123;</span><br><span class="line">        mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pass it up to our parent</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子View调用getParent.requestDisallowInterceptTouchEvent(true)，mGroupFlags就会有FLAG_DISALLOW_INTERCEPT标识，当子View调用getParent.requestDisallowInterceptTouchEvent(false)，mGroupFlags就会清除FLAG_DISALLOW_INTERCEPT标识，那么FLAG_DISALLOW_INTERCEPT标识又是怎么控制ViewGroup的拦截的呢？如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!disallowIntercept) &#123;<span class="comment">//如果子View允许ViewGroup拦截事件</span></span><br><span class="line">    <span class="comment">//调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定</span></span><br><span class="line">    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//如果子View禁止ViewGroup拦截事件</span></span><br><span class="line">    intercepted = <span class="keyword">false</span>;<span class="comment">//intercepted值为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子View通过调用getParent.requestDisallowInterceptTouchEvent(true)，来禁止ViewGroup拦截除了ACTION_DOWN以外的其他事件，这样当下一个事件到来时就会交给这个子View，</p><p>为什么是除了ACTION_DOWN以外的其他事件？因为ACTION_DOWN事件是事件序列的开始，ACTION_DOWN事件会先经过ViewGroup的onInterceptTouchEvent()方法，从<strong>ACTION_DOWN事件的处理流程 - intercepted = true</strong>我们知道，如果ViewGroup一开始在onInterceptTouchEvent()的ACTION_DOWN返回true，它就不会进入dispatchTouchEvent()方法的注释3的if语句，这样在DOWN事件下就无法找到mFirstTouchTarget，这样当同一个事件序列的其他事件到来时，mFirstTouchTarget == null，这样ViewGroup只能把事件交给自己处理，无法传递给子View，也就无法调用子View的dispatchTouchEvent()方法，这样子View在dispatchTouchEvent()方法中调用getParent.requestDisallowInterceptTouchEvent(true)就没有意义了。</p><h3 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h3><p>从ViewGroup的事件分发中得出几个结论：</p><p>1、ViewGroup如果在onInterceptTouchEvent()方法的ACTION_DOWN事件中返回true，那么整个事件序列都会交给ViewGroup处理，不再交给子View，从而导致无法调用子View的dispatchTouchEvent()方法，导致子View调用getParent.requestDisallowInterceptTouchEvent(true)失效。</p><p>2、ViewGroup如果在onInterceptTouchEvent()方法中一旦拦截除了ACTION_DOWN的事件，那么子View将会收到一个ACTION_CANCEL事件，并且接下来的事件都是交给ViewGroup处理。</p><p>3、1、2点的含义都是ViewGroup决定拦截事件，那么一旦ViewGroup决定拦截事件，那么接下来的事件都是交给ViewGroup处理，并且ViewGroup的onInterceptTouchEvent()方法在这个事件序列内不会再调用，这说明ViewGroup的onInterceptTouchEvent()方法不是每次都调用,只有ViewGroup的dispatchTouchEvent()才能保证每次调用。</p><p>3、在ViewGroup中ACTION_DOWN 事件负责寻找 target，即寻找能够消费ACTION_DOWN事件的子View，如果找到，那么接下来同一事件序列内的所有事件都会交给这个子View处理，不再交给ViewGroup；如果没有找到，有两种情况：1、ViewGroup没有子View，2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false，那么接下来同一事件序列下的所有事件都是ViewGroup自己处理。</p><p>4、子View如果不消费ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，而是交给它的父ViewGroup处理；子View一旦消费ACTION_DOWN事件，如果ViewGroup不拦截，那么同一事件序列的其他事件都会交给子View处理。</p><p>5、当调用super.dispatchTouchEvent(event)就代表ViewGroup开始自己处理事件，里面会执行ViewGroup的onTouchEvent(), 逻辑和View的事件分发一样。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>当点击事件到达ViewGroup时，它的dispatchTouchEvent()方法就会被调用，如果这个ViewGroup的onInterceptTouchEvent()方法返回true，就表示它要拦截当前事件，接下来这个事件序列内的事件都会交给它处理，即super.dispatchTouchEvent()方法得到调用；如果这个ViewGroup的onInterceptTouchEvent()方法返回false，就表示它不拦截当前事件，这时当前事件就会传递给它的子View，接着子View的dispatchTouchEvent()方法就会被调用，如果子View是一个View，那么它的处理流程就像前面介绍的View的事件分发一样，如果子View是一个ViewGroup，那么它的处理流程就又是ViewGroup的事件分发，如此递归，<strong>从上到下</strong>，直到整颗View树都收到事件，接下来递归返回，<strong>从下到上</strong>，每一层的返回值都决定是否消费本次事件，如果消费，返回true，它的上一层就无法处理这个事件，如果不消费，返回false，它的上一层又继续传给上一层，直到根视图。</p><p>View的事件分发小结和ViewGroup的事件分发小结都可以在源码中找到证明，可以自行验证一下，本文通过源码 + 流程图 说明了整个View的事件分发体制，在看的过程最好要结合上下文来看，始终记住这是在同一个事件序列内，跟着流程图的每一个分支在源码中走一遍，那样你就会有更深刻的理解。</p><p>参考资料：</p><p><a href="https://blog.csdn.net/qq_43660664/article/details/84026785" target="_blank" rel="noopener">Android事件分发完全解析之事件从何而来</a></p><p><a href="https://blog.csdn.net/u010707039/article/details/85211658#commentBox" target="_blank" rel="noopener">通过流程图来分析Android事件分发</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前几天写过一篇文章&lt;a href=&quot;https://rain9155.github.io/2019/07/22/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;View的工作原理&lt;/a&gt;，讲述的View工作的三大流程，其实与View的工作流程同样重要还有View的事件分发机制，平时我们经常通过setOnClickListener()方法来设置一个View的点击监听，那你有没有想过这个点击事件底层是怎么样传递到这个View的呢？当你自定义控件时，如果要处理滑动事件，那么到底返回true还是false？还有当你遇到了滑动嵌套的情景，你要怎么解决滑动嵌套引起的冲突？所以，本文通过 源码 + 流程图 来深入了解一个事件分发机制，当你掌握了它之后，当你遇到与滑动相关的问题时就更加的游刃有余。&lt;/p&gt;
    
    </summary>
    
    
      <category term="View机制" scheme="http://yoursite.com/categories/View%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="view" scheme="http://yoursite.com/tags/view/"/>
    
  </entry>
  
  <entry>
    <title>View的工作原理</title>
    <link href="http://yoursite.com/2019/07/22/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/22/View的工作原理/</id>
    <published>2019-07-22T11:57:11.000Z</published>
    <updated>2019-08-06T05:52:06.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Android中View一直扮演着一个很重要的角色，它是我们开发中视觉的呈现，我平常也使用着Android提供的丰富且功能强大的控件，有时候遇到一个很炫酷的自定义View的开源库，我们也是拿来主义，时间长了你就会发现你只是一个只会使用控件和依赖被人开源库的程序员，这并不是一个开发者，所以我们并不能只满足于使用，我们要理解它背后的工作原理和流程，这样才能自己做出一个属于自己的控件，一直都说自定View是Android进阶中的一道门槛，当其实自定义View当你理解了它的原理后，你就会发现它也不过如此。本文将从源码的角度探讨View工作的三大流程，对View做进一步的认识。俗话说的好：源码才是最好的老师。</p><a id="more"></a><pre><code>本文代码基于Android8.0，相关源码位置如下：frameworks/base/core/java/android/*.java(*代表View, ViewGroup, ViewRootImpl)frameworks/base/core/java/android/FrameLayout.java</code></pre><h2 id="View何时开始绘制？-requestLayout"><a href="#View何时开始绘制？-requestLayout" class="headerlink" title="View何时开始绘制？- requestLayout()"></a>View何时开始绘制？- requestLayout()</h2><p>提到View，就不得不讲起Window，在<a href="https://rain9155.github.io/2019/03/22/Window,%20WindowManager和WindowManagerService之间的关系/" target="_blank" rel="noopener">Window,WindowManager和WindowManagerService之间的关系</a>文章中讲过，Widnow是View得载体，在ViewRootImpl的setView方法中添加Winodw到WMS之前，会先调用requestLayout绘制整颗View Hierarchy的绘制，如下：</p><img src="/2019/07/22/View的工作原理/view1.png" title="view1"><p>所以我们先从requestLayout()中看起，该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        <span class="comment">//检查是否在主线程，在子线程绘制UI会抛出异常，见下方</span></span><br><span class="line">        checkThread();</span><br><span class="line">        <span class="comment">//是否measure和layout布局的开关</span></span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//1、准备开始遍历View Hierarchy绘制</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">            <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>requestLayout()中首先会检查线程的合法性，Android规定必须在主线程中操作UI，那么为什么不能在子线程中访问UI呢？这是因为Android的UI控件都不是线程安全的，如果在多线程环境下并发访问控件会导致控件处于不可预测状态。接着我们来看注释1，调用了ViewRootImpl的scheduleTraversals方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;<span class="comment">//防止同一帧绘制多次</span></span><br><span class="line">            mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//拦截同步Message，优先处理异步Message</span></span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">             <span class="comment">//1、Choreographer回调，里面执行最终会执行mTraversalRunnable中的绘制任务</span></span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Android4.1之前Android的UI流畅性很差，所以在Android4.1之后引入了Choreographer机制和Vsync机制用来解决这个问题，Choreographer管理者动画、输入和绘制的时机，Vsync叫Vertical Synchronization（垂直同步）信号，每隔 16ms Choreographer就会收到来自native层的Vsync信号，这时Choreographer就会根据事件类型进行相应的回调操作，Choreographer支持4种事件类型回调：输入(CALLBACK_INPUT)、绘制(CALLBACK_TRAVERSAL)、动画(CALLBACK_ANIMATION)、提交(CALLBACK_COMMIT)，并通过postCallback方法在对应需要同步Vsync刷新处进行注册，等待回调，关于这个细节和原理可以看<a href="https://www.jianshu.com/p/bab0b454e39e" target="_blank" rel="noopener">Android图形系统-Choreographer</a>和<a href="http://www.apkbus.com/blog-705730-61226.html" target="_blank" rel="noopener">Android垂直同步和三重缓存</a>，这里我们并不深究Choreographer机制和Vsync机制，我们看到注释1中的Choreographer的postCallback方法提交了CALLBACK_TRAVERSAL类型的回调，它对应着mTraversalRunnable绘制操作，而mTraversalRunnable是一个TraversalRunnable类型的绘制任务，最终回调会执行这个任务，mTraversalRunnable的run方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、里面会执行performTraversals()</span></span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doTraversal()里面会执行performTraversals方法，点开doTraversal方法看一下，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//移除拦截同步Message屏障</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        <span class="comment">//1、今天的主角，performTraversals()方法</span></span><br><span class="line">        performTraversals();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在doTraversal() 方法里面我们终于看到我们熟悉的方法：<strong>performTraversals()</strong>。</p><h2 id="View树绘制的起点-performTraversals"><a href="#View树绘制的起点-performTraversals" class="headerlink" title="View树绘制的起点 - performTraversals()"></a>View树绘制的起点 - performTraversals()</h2><p>performTraversals()它是整个View Hierarchy绘制的起点，它里面会执行View绘制的三大工作流程，我们先看一下精简版的performTraversals方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mView是在View与ViewRootImpl建立关联的时候被赋值的，即调用ViewRootImpl的setView方法时，它代表着View Hierarchy的根节点，即根视图</span></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line">    <span class="comment">//desiredWindowWidth和desiredWindowHeight分别代表着屏幕的宽度和高度</span></span><br><span class="line">    <span class="keyword">int</span> desiredWindowWidth;</span><br><span class="line">    <span class="keyword">int</span> desiredWindowHeight;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (mLayoutRequested) &#123;</span><br><span class="line">        <span class="keyword">final</span> Resources res = mView.getContext().getResources();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//1、这里调用了measureHierarchy方法，里面会调用performMeasure方法，执行View Hierarchy的measure流程，见下方</span></span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                                              desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(didLayout)&#123;</span><br><span class="line">          <span class="comment">//2、这里调用了performLayout方法，执行View Hierarchy的layout流程</span></span><br><span class="line">         performLayout(lp, mWidth, mHeight);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//3、这里调用了performDraw方法，执行View Hierarchy的draw流程</span></span><br><span class="line">   performDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,  <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">     <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="comment">//1.1、顶级View在调用performMeasure方法之前，会先调用getRootMeasureSpec方法来生成自身宽和高的MeasureSpec</span></span><br><span class="line">     childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">     childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">     <span class="comment">//1.2、这里调用performMeasure方法，执行View Hierarchy的measure流程</span></span><br><span class="line">     performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>performTraversals方法里面非常复杂，我们看的时候千万不要深究其中的细节，不然就走火入魔了，我们找出个整体框架就行，我们先看注释1、2、3，可以看到依此调用<strong>measureHierarchy() -&gt; performLayout() -&gt; performDraw()，</strong>而measureHierarchy()里面最终调用performMeasure()，所以performTraversals()可以看作依此调用了<strong>performMeasure() -&gt; performLayout() -&gt; performDraw()，</strong>分别对应顶级View的<strong>measure、layout和draw流程，</strong>顶级View可以理解为View Hierarchy的根节点，它一般是一个ViewGroup，就像Activity的DecorView一样。</p><blockquote><p>ps：</p><p>1、在performTraversals()方法中，performMeasure()可能会执行多次，而performLayout()和performDraw()最多执行一次。</p><p>2、本文讨论的顶级View你可以把它类比成Activity的DecorView，但是它其实就是View树的根结点，DecorView也是Activity中View树的根结点。</p></blockquote><p>接下来我们就照着performTraversals() 中的整体框架来讲解View工作的三大流程。</p><h2 id="View的测量流程-performMeasure"><a href="#View的测量流程-performMeasure" class="headerlink" title="View的测量流程 - performMeasure()"></a>View的测量流程 - performMeasure()</h2><h3 id="1、MeasureSpec"><a href="#1、MeasureSpec" class="headerlink" title="1、MeasureSpec"></a>1、MeasureSpec</h3><p>讲解View的measure流程前，不得不先讲解一下MeasureSpec的含义，MeasureSpec是一个32位的int值，它是View的一个内部类，它的高2位代表着SpecMode，表示测量模式，它的低30位表示SpecSize，表示测量大小，系统通过位运算把SpecMode和SpecSize合二为一组成一个32位int值的MeasureSpec。</p><p>下面看一下MeasureSpec的里面组成，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左移位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//位掩码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">    <span class="comment">//代表着三种SpecMode</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//makeMeasureSpec方法是把SpecMode和SpecSize通过位运算组成一个MeasureSpec并返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">            <span class="keyword">return</span> size + mode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getMode方法是从给定的MeasureSpec中取出SpecMode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getSize方法是从给定的MeasureSpec中取出SpecSize</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到MeasureSpec提供了三个工具方法分别用来组合MeasureSpec、从MeasureSpec中取出SpecMode、从MeasureSpec中取出SpecSize，其中SpecMode有三种取值，如下：</p><ul><li>UNSPECIFIED：它表示父容器对子View的绘制的大小没有任何限制，要多大给多大，这种情况一般适用于系统内部，表示一种测量状态。</li><li>EXACTLY：它表示父容器已经测量出子View需要的精确大小SpecSize，这个时候View的最终大小就是SpecSize的值，它对应于LayoutParams中match_parcent和具体的数值这两种模式。</li><li>AT_MOST：它表示父容器为子View的大小指定了一个最大值SpecSize，这个时候View的大小不能大于这个值，它对应于LayoutParams中的wrap_content这种模式。</li></ul><h4 id="1-1-如何确定View的MeasureSpec？"><a href="#1-1-如何确定View的MeasureSpec？" class="headerlink" title="1.1 如何确定View的MeasureSpec？"></a>1.1 如何确定View的MeasureSpec？</h4><p>除了顶级View，其他View的MeasureSpec都是由父容器的MeasureSpec和自身的LayoutParams共同决定的，LayoutParams就是你平时在编写View的xml属性时那些带有<strong>layout_XX</strong>前缀开头的布局属性，对于顶级View和在View树中子View的MeasureSpec的生成规则有点不一样，见下面分析：</p><h5 id="1-1-1、顶级View的MeasureSpec的创建-getRootMeasureSpec"><a href="#1-1-1、顶级View的MeasureSpec的创建-getRootMeasureSpec" class="headerlink" title="1.1.1、顶级View的MeasureSpec的创建 - getRootMeasureSpec()"></a>1.1.1、顶级View的MeasureSpec的创建 - getRootMeasureSpec()</h5><p>由于顶级View是View树的根结点，所以它没有父容器，所以它的MeasureSpec是由屏幕窗口的尺寸和自身的LayoutParams来共同决定，上面注释1.1我们讲到顶级View在调用performMeasure方法之前，会先调用ViewRootImpl的getRootMeasureSpec方法来生成自身宽和高的MeasureSpec，我们来看一下getRootMeasureSpec方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:<span class="comment">//如果是MATCH_PARENT,那么就是EXACTLY</span></span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:<span class="comment">//如果是WRAP_CONTENT,就是AT_MOST</span></span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="comment">//如果是固定的值,也是EXACTLY</span></span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>windowSize就是是传入的desiredWindowWidth或desiredWindowHeight，它表示屏幕的大小，rootDimension就是传入的屏幕窗口的LayoutParams的大小模式，对应我们平时写的layout_width或layout_height属性，该属性无非就三个值：match_parent、wrap_content和固定的数值，所以从getRootMeasureSpec方法可以看到，顶级View的MeasureSpec的创建规则如下：</p><img src="/2019/07/22/View的工作原理/view2.png" title="view2"><p>其中rootSize表示顶级View大小。</p><h5 id="1-1-2、子View的MeasureSpec的创建-getChildMeasureSpec"><a href="#1-1-2、子View的MeasureSpec的创建-getChildMeasureSpec" class="headerlink" title="1.1.2、子View的MeasureSpec的创建 - getChildMeasureSpec()"></a>1.1.2、子View的MeasureSpec的创建 - getChildMeasureSpec()</h5><p>在1中，顶级View的MeasureSpec已经创建好了，这时候就要根据这个MeasureSpec去生成子View的MeasureSpec，子View的MeasureSpec的创建是从ViewGroup的measureChildWithMargins方法开始，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="function">rotected <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed, <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到子View的margin</span></span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">    <span class="comment">//1、这里调用了getChildMeasureSpec方法，里面就是创建子View的MeasureSpec，这里创建子View宽的MeasureSpec</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);</span><br><span class="line">    <span class="comment">//同理，这里创建子View高的MeasureSpec</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,  mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height);</span><br><span class="line">    <span class="comment">//如果子View是一个ViewGroup，递归measure下去</span></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法会对子View进行measure，由注释1得知，在调用子View的measure方法前，会先调用getChildMeasureSpec方法获得子View的MeasureSpec，从getChildMeasureSpec方法的参数可以看出，子View的MeasureSpec的创建与父容器的MeasureSpec和子View本身的LayoutParams有关，此外还和View的margin及padding有关，下面我们来看ViewGroup的getChildMeasureSpec方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//取出父容器的测量模式specMode</span></span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="comment">//取出父容器的测量大小specSize</span></span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line"><span class="comment">// padding是指父容器中已占用的空间大小，因此子View最大可用大小size == 父容器剩余大小 == 父容器的尺寸减去padding </span></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:<span class="comment">//如果父容器是EXACTLY</span></span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;<span class="comment">//如果子View的LayoutParams是固定大小</span></span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<span class="comment">//如果子View的LayoutParams是MATCH_PARENT//子View的MeasureSpec为父容器剩余大小 + EXACTLY</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<span class="comment">//如果子View的LayoutParams是WRAP_CONTENT</span></span><br><span class="line">                <span class="comment">//子View的MeasureSpec为父容器剩余大小 + AT_MOST</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:<span class="comment">//如果父容器是AT_MOST</span></span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//子View的MeasureSpec为子View大小 + EXACTLY</span></span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="comment">//子View的MeasureSpec为父容器剩余大小 + AT_MOST</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">               <span class="comment">//子View的MeasureSpec为父容器剩余大小 + AT_MOST</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:<span class="comment">//如果父容器是UNSPECIFIED，这个平时开发用不到</span></span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到getChildMeasureSpec方法里面的逻辑还是很清楚的，首先根据父容器的测量模式specMode分为三大类：<strong>EXACTLY、AT_MOST和UNSPECIFIED，</strong>每一类又和子View的LayoutParams的的三种大小模式：<strong>固定大小、MATCH_PARENT和WRAP_CONTENT</strong>组合，所以总共有3 X 3 = 9种组合，所以根据getChildMeasureSpec方法可以得出子View的MeasureSpec的创建规则如下：</p><img src="/2019/07/22/View的工作原理/view3.png" title="view3"><p>其中childSize表示子View的大小，parentSize表示父容器剩余大小。</p><h3 id="2、View和ViewGroup的measure流程"><a href="#2、View和ViewGroup的measure流程" class="headerlink" title="2、View和ViewGroup的measure流程"></a>2、View和ViewGroup的measure流程</h3><p>分析完View的MeasureSpec的创建后，我们继续回到View的measure流程，大家都知道ViewGroup是继承自View的，所以View的measure流程，分为两种情况，一种是View的measure流程，一种是ViewGroup的measure流程，但是不管是View的measure流程还是ViewGroup的measure流程都是从ViewRootImpl的performMeasure()开始，并且都会先调用View的measure方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1、调用了View的measure方法</span></span><br><span class="line">    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续看View的measure方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">//1、调用了onMeasure方法</span></span><br><span class="line">      onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到measure方法是一个final方法，说明这个方法不能够被子类重写，这个方法把measure的具体过程交给了onMeasure方法去实现，所以View和ViewGroup的measure流程的差异就从这个onMeasure方法开始，见下面分析。</p><h4 id="2-1、View的measure流程"><a href="#2-1、View的measure流程" class="headerlink" title="2.1、View的measure流程"></a>2.1、View的measure流程</h4><p>从上述知道View的measure起点在View的measure方法中，并且View的measure方法会调用View的onMeasure方法，<strong>View::measure() -&gt; View::onMeasure()</strong>，所以我们直接看onMeasure方法在View中的实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、 如果View没有重写onMeasure方法，则会调用setMeasuredDimension方法设置宽高，在设置之前先调用getDefaultSize方法获取默认宽高</span></span><br><span class="line">    setMeasuredDimension(</span><br><span class="line">            getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">                         getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View中的onMeasure方法的默认实现是先调用getDefaultSize方法获取默认宽高，然后再调用调用setMeasuredDimension方法设置View的宽高，当调用setMeasuredDimension方法设置View的宽高后，就可以通过getMeasureWidth()或getMeasureHeight()获得View测量的宽高，所以我们先看一下 getDefaultSize()方法是如何获取默认的宽高，该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = size;</span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">        <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="comment">//如果specMode是UNSPECIFIED，返回的大小就是传进来的size，而这个size就是通过getSuggestedMinimumWidth()或getSuggestedMinimumHeight()方法获得的</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//如果specMode是AT_MOST或EXACTLY，返回的大小就是MeasureSpec中的specSize</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getDefaultSize方法的逻辑很简单，除了UNSPECIFIED这种模式，其他测量模式都返回MeasureSpec中的specSize，而这个specSize就等于父容器给View测量后的大小，所以我们可以得出一个结论：<strong>直接继承View写自定义控件时需要重写onMeasure方法并设置wrap_content时自定义View自身的大小，这是因为如果自定义View在xml文件写了layout_XX = wrap_content这个属性，那么在创建它的MeasureSpec时，它的specMode就会等于AT_MOST，而从getDefaultSize方法看出，如果specMode是AT_MOST或EXACTLY，它们两个返回的值是一样的，都是MeasureSpec中的specSize，通过上面所讲的子View的MeasureSpec的创建规则可知specSize是等于parentSize即父容器剩余的大小，这样就会造成这个自定义View会填充满整个父容器，效果和match_parent一样，并不按你想象那样的大小</strong>。所以以后在自定义View时，如果有wrap_content这个场景，就要重写onMeasure方法，可以参考下面的模板，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;               </span><br><span class="line">     <span class="keyword">int</span> measureWidth = MeasureSpec.getSize(widthMeasureSpec); </span><br><span class="line">     <span class="keyword">int</span> measureHeight = MeasureSpec.getSize(heightMeasureSpec);  </span><br><span class="line">     <span class="keyword">int</span> measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);   </span><br><span class="line">     <span class="keyword">int</span> measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);  </span><br><span class="line">     <span class="keyword">int</span> width, height;</span><br><span class="line">     <span class="comment">//经过计算，控件所占的宽和高分别对应width和height</span></span><br><span class="line">     <span class="comment">// …………   </span></span><br><span class="line">     <span class="comment">//我们只需要在View为wrap_content时设置我们经过计算得出的View的默认宽高width和height即可</span></span><br><span class="line">     <span class="comment">//其他模式如EXACTLY，就直接设置父容器给我们测量出来的宽高即可</span></span><br><span class="line">  setMeasuredDimension(</span><br><span class="line">         (measureWidthMode == MeasureSpec.AT_MOST) ? width : measureWidth , </span><br><span class="line">         (measureHeightMode == MeasureSpec.AT_MOST) ? height : measureHeight</span><br><span class="line">     );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲完了getDefaultSize()中AT_MOST和EXACTLY模式情况，接着讲UNSPECIFIED这种模式的情况，从getDefaultSize方法中可以看出如果specMode是UNSPECIFIED，返回的大小就是传进来的size，而这个size就是通过getSuggestedMinimumWidth()或getSuggestedMinimumHeight()方法获得的，所以我们以getSuggestedMinimumWidth方法为例子，看一些如果获取在UNSPECIFIED模式下的宽，getSuggestedMinimumHeight()方法同理，getSuggestedMinimumWidth方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据View有无背景返回大小，getMinimumWidth()见下方</span></span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Drawable.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//getIntrinsicWidth()返回Drawable的宽，默认返回-1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> intrinsicWidth = getIntrinsicWidth();</span><br><span class="line">    <span class="keyword">return</span> intrinsicWidth &gt; <span class="number">0</span> ? intrinsicWidth : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mBackground就等于View的背景，即android:background属性，mMinWidth就等于你在View的xml布局中写了“android:minWidth”这个属性，mBackground.getMinimumWidth()就是获取View的背景的宽度，所以我们得出结论：<strong>在UNSPECIFIED模式下，如果View没有设置背景，那么View的宽就等于android:minWidth，如果View设置了背景，那么View的宽就等于View的背景background的宽和android:minWidth的最大值，高度同理</strong>。</p><blockquote><p>View的onMeasure方法执行完后，就可以通过getMeasureWidth()或getMeasureHeight()获得View测量的宽高，但是有可能会不准确，因为有时候系统会进行多次measure，才能确定最终测量宽高，所以最好是在onLayout方法中去获取View的宽高。</p></blockquote><h4 id="2-2、ViewGroup的measure流程-以FrameLayout为例"><a href="#2-2、ViewGroup的measure流程-以FrameLayout为例" class="headerlink" title="2.2、ViewGroup的measure流程 (以FrameLayout为例)"></a>2.2、ViewGroup的measure流程 (以FrameLayout为例)</h4><p>从上述知道ViewGroup的measure起点也在View的measure方法中，而View的measure方法会调用View的onMeasure方法，ViewGroup继承自View，但是它是一个抽象类并没有重写View的onMeasure方法，而是由ViewGroup的子类如LinearLayout、FrameLayout等重写onMeasure方法以实现不同的measure流程，这里以FrameLayout为例，<strong>View::measure() -&gt; FrameLayout::onMeasure() </strong>，我们来看FrameLayout的onMeasure方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FrameLayout.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取子View的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//遍历所有子View，测量每个子View的大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;<span class="comment">//如果子View可见</span></span><br><span class="line">            <span class="comment">//1、调用ViewGroup的measureChildWithMargins方法，测量子View的大小</span></span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="comment">//子View测量完后，FrameLayout就可以通过View的getMeasuredWidth或getMeasuredHeight获得子View的宽高，从而得出自己的宽高</span></span><br><span class="line">            <span class="comment">//根据FrameLayout的叠加特性，它自身的测量宽高就是所有子View宽高中的最大值</span></span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                                child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                                 child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到与View的onMeasure方法不同的是，FrameLayout的onMeasure方法是遍历它所有的子View，然后逐个测量子View的大小，这个测量子View是通过注释1的measureChildWithMargins方法来完成，这个方法已经在上面子View的MeasureSpec的创建中讲过一点，measureChildWithMargins方法是在FrameLayout的父类ViewGroup中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed, <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略的这部分在上面已经讲过，主要是创建子View的MeasureSpec（childWidthMeasureSpec, childHeightMeasureSpec）</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1、调用子View的measure方法，叫子View自己测量自己</span></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>measureChildWithMargins方法中首先会根据父容器传进来的parenXXMeasureSpec来创建子View的childXXMeasureSpec，然后调用子View的measure方法，把测量子View的任务又推给了子View，这个过程又回到了2.1所讲的View的measure流程，就不再赘述，所有子View测量完后，ViewGroup就可以得出自己的测量宽高。</p><h3 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h3><p>measure流程是三大流程中最复杂的一个，它的整体流程是：从ViewRootImp的performTraversals()方法进入performMeasure()方法，开始整颗View树的测量流程，在performMeasure方法里面会调用View的measure方法，然后measure方法会调用onMeasure方法，如果是View就直接开始测量，设置View的宽高，如果是ViewGroup，则在onMeasure方法中则会对所有的子View进行measure过程，如果子View是一个ViewGroup，那么继续向下传递，直到所有的View都已测量完成。如图：</p><img src="/2019/07/22/View的工作原理/view4.png" title="view4"><p>measure过后就可以通过getMeasureWidth()或getMeasureHeight()获得View测量的宽高。</p><h2 id="View的布局流程-performLayout"><a href="#View的布局流程-performLayout" class="headerlink" title="View的布局流程 - performLayout()"></a>View的布局流程 - performLayout()</h2><p>前面讲解了View的measure过程，如果你理解了，那么View的布局过程也很容易理解的，和measure相似，View的布局过程是从ViewRootImpl的performLayout()开始的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1、调用了顶级View的layout方法</span></span><br><span class="line">     host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在performLayout中主要调用了顶级View的layout方法，顶级View的实例有可能是View也有可能是ViewGroup，但是这个layout方法是在View中，它不像measure方法那样，它不是final修饰，所以它可以被重写，并且ViewGroup重写了layout方法，我们先看一下ViewGroup中的layout方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">         <span class="comment">//1、ViewGroup中的重写的layout方法还是调用了父类即View的layout方法</span></span><br><span class="line">        <span class="keyword">super</span>.layout(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到ViewGroup重写的layout方法只是做了一些判断，然后最终还是还是调用了父类即View的layout方法，所以我们直接看View的layout方法即可。</p><h3 id="1、View和ViewGroup的layout流程"><a href="#1、View和ViewGroup的layout流程" class="headerlink" title="1、View和ViewGroup的layout流程"></a>1、View和ViewGroup的layout流程</h3><p>View的layout方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意传进来的四个参数：</span></span><br><span class="line">    <span class="comment">// l 表示子View的左边缘相对于父容器的上边缘的距离</span></span><br><span class="line">    <span class="comment">// t 表示子View的上边缘相对于父容器的上边缘的距离</span></span><br><span class="line">    <span class="comment">// r 表示子View的右边缘相对于父容器的右边缘的距离</span></span><br><span class="line">    <span class="comment">// b 表示子View的下边缘相对于父容器的下边缘的距离</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line">    <span class="comment">//1、调用setFrame方法设定View的四个顶点的位置</span></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        <span class="comment">//2、调用onlayout方法</span></span><br><span class="line">    onLayout(changed, l, t, r, b);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout方法传进来的l、t、r、b分别代表着View的上下左右四个点的坐标，这个四个点的坐标是相对于它的父容器来说的，这个layout方法主要干了两件事：</p><ul><li>1、注释1：调用View的setFrame方法设定View的四个顶点的位置，我们先看View的setFrame()方法，如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        mLeft = left;</span><br><span class="line">        mTop = top;</span><br><span class="line">        mRight = right;</span><br><span class="line">        mBottom = bottom;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，setFrame方法主要把l、t、r、b分别赋值给mLeft、mTop、mBottom、mRight，即更新View的四个顶点的位置，这个四个顶点一旦确定，那么View在父容器中的位置也就确定了。</p><ul><li>2、我们继续看注释2：调用了onLayout方法，这个方法在View中是一个空实现，如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在ViewGroup中是一个抽象方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>这是因为onLayout方法主要用途是给父容器确定子View的位置，所以如果本身就是一个View，就无需实现这个方法，但是如果是ViewGroup，它还要布局子View，所以是ViewGroup的子类就要强制实现这个方法，不同的ViewGroup具有不同的布局方式，所以不同的ViewGroup的onLayout方法的实现就不一样，我们还是以FrameLayout为例，看一下FrameLayout的onLayout方法的实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FrameLayout.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FrameLayout的onLayout方法只调用了layoutChildren方法，该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"><span class="comment">//获取padding值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"><span class="comment">//遍历所有子View，布局每个子View</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">            <span class="comment">//如果子View可见</span></span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                <span class="comment">//获得measue流程测量出来的子View的宽高</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line">                <span class="comment">//子View的左边缘位置</span></span><br><span class="line">                <span class="keyword">int</span> childLeft;</span><br><span class="line">                <span class="comment">//子View的上边缘位置</span></span><br><span class="line">                <span class="keyword">int</span> childTop;</span><br><span class="line">                <span class="comment">//下面是获取布局方向</span></span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="comment">//下面根据布局方向计算出childLeft和childTop</span></span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">   <span class="comment">//1、根据上面的计算，就算出了一个子View的左边缘位置childLeft和上边缘位置childTop</span></span><br><span class="line">                <span class="comment">//从而根据childLeft和childTop得出子View的右边缘位置childRight = childLeft + width，下边缘位置childButtom = childTop + height</span></span><br><span class="line">                <span class="comment">//然后调用子View的layout方法</span></span><br><span class="line">                child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现layoutChildren里面过程和onMeasure里面的过程很像，只是注释1中调用的是子View的layout方法而不是measure方法，如果这个子View是一个View，那么layout方法里面就可以通过setFrame方法直接确定自身的位置，如果这个子View是一个ViewGroup，除了调用setFrame方法确定自身的位置外，还要重复onLayout方法中确定子View位置的过程，最后一层一层的往下，直到全部都子View的layout完成。</p><h3 id="2、小结"><a href="#2、小结" class="headerlink" title="2、小结"></a>2、小结</h3><p>我们再来看一下layout的整体流程：从ViewRootImp的performTraversals()方法进入performLayout()方法，开始整颗View树的布局流程，在performLayout方法里面会调用layout方法，我们发现，View的布局过程其实也可想测量过程那样分为View的layout流程和ViewGroup的layout流程，对于View来说，执行layout方法时只需要直接确定自身四个顶点的位置即可，而onLayout方法是一个空实现；对于ViewGroup来说，执行layout方法时除了要确定自身的四个顶点的位置外，那么它在onLayout方法中还要对自己所有的子View进行layout，最后一层一层的往下，直到全部都layout完成。如下：</p><img src="/2019/07/22/View的工作原理/view5.png" title="view5"><p>layout过后就可以通过View的getWidth()和getHeight()来获取最终的宽高的，这个两个方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mRight - mLeft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBottom - mTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现就是通过View的四个顶点的差值来得到View的准确宽高。</p><h2 id="View的绘制流程-performDraw"><a href="#View的绘制流程-performDraw" class="headerlink" title="View的绘制流程 - performDraw()"></a>View的绘制流程 - performDraw()</h2><p>和上面两步相似，View的绘制从ViewRootImpl的performDraw()开始的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fullRedrawNeeded = mFullRedrawNeeded;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1、调用ViewRootImpl的draw方法</span></span><br><span class="line">    draw(fullRedrawNeeded);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performDraw()方法中并不是先调用View的draw方法，而是先调用ViewRootImpl的draw方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取surface绘制表面</span></span><br><span class="line">    Surface surface = mSurface;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//如果surface表面需要更新</span></span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        <span class="comment">//判断是否启用硬件加速，即是否使用GPU绘制</span></span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//使用GPU绘制</span></span><br><span class="line">            mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//1、调用drawSoftware方法，使用CPU绘制</span></span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ViewRootImpl的draw方法中首先获取需要绘制的区域，然后判断是否使用GPU进行绘制，使用硬件加速是为提高了Android系统显示和刷新的速度，是在在API 11之后引入GPU加速的支持，关于这部分知识可自行查阅资料，不是本文重点，这里我们只关心注释1，通常情况下我们使用的是CPU绘制，也就是调用ViewRootImpl的drawSoftware方法来绘制，ViewRootImpl的drawSoftware()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff, <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line">        <span class="comment">//1、获取指定区域的Canvas对象，即画布，用于绘制</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;<span class="comment">//省略catch</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//2、从View树的根节点开始绘制，触发整颗View树的绘制</span></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//3、释放Canvas锁，然后通知SurfaceFlinger更新这块区域</span></span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>drawSoftware方法中主要做了3件事：</p><ul><li>1、获取Surface对象并锁住Canvas绘图对象</li><li>2、从View树的根视图开始绘制整颗视图树</li><li>3、释放Surface对象并解锁Canvas，通知SurfaceFlinger更新视图</li></ul><h3 id="1、View和ViewGroup的draw流程"><a href="#1、View和ViewGroup的draw流程" class="headerlink" title="1、View和ViewGroup的draw流程"></a>1、View和ViewGroup的draw流程</h3><p>第1和第3点都是操作Surface的基本流程，我们主要看第二点即注释2，调用了View的draw方法，它就是一个模板方法，定义了几个固定的绘制步骤，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">                (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">         * in the appropriate order:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      1. Draw the background</span></span><br><span class="line"><span class="comment">         *      2. If necessary, save the canvas' layers to prepare for fading</span></span><br><span class="line"><span class="comment">         *      3. Draw view's content</span></span><br><span class="line"><span class="comment">         *      4. Draw children</span></span><br><span class="line"><span class="comment">         *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">         *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="comment">//1、绘制背景</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2、保存Canvas图层，为fadin做准备</span></span><br><span class="line">    saveCount = canvas.getSaveCount();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//3、 绘制自身内容，setWillNotDraw()可以控制dirtyOpaque这个标志位</span></span><br><span class="line">    <span class="keyword">if</span>(!dirtyOpaque) onDraw(canvas);</span><br><span class="line">    <span class="comment">//4、如果是ViewGroup，绘制子View</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//5、如果需要的话，绘制View的fading边缘并恢复图层</span></span><br><span class="line">    canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">//6、绘制装饰，如滚动条</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看那英文注释，它已经替我们把draw方法中的6大步骤写出来了，其中最重要的就是注释3和4，我们分别来介绍一下：</p><ul><li><strong>onDraw(canvas)</strong>：onDraw方法是用来绘制自身内容，如果你的自定义View或ViewGroup需要绘制内容，就要重写这个方法在Canvas上绘制自身内容。</li><li><strong>dispatchDraw(canvas)</strong>：如果是ViewGroup，除了绘制自身内容外，还需要绘制子View的内容，所以dispatchDraw就是把View的绘制一层一层的传递下去，直到整颗View树绘制完毕，ViewGroup重写了该方法，我们看一下它的主要源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//如果子View可见</span></span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//调用drawChild方法，见下面</span></span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//还是调用了View的draw方法</span></span><br><span class="line">     <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到，dispatchDraw方法把绘制子View的任务通过drawChild方法分发给它的子View，如果是一个ViewGroup，又会重复dispatchDraw()过程。</p><h3 id="2、onDraw-绘制开关-setWillNotDraw"><a href="#2、onDraw-绘制开关-setWillNotDraw" class="headerlink" title="2、onDraw()绘制开关 - setWillNotDraw()"></a>2、onDraw()绘制开关 - setWillNotDraw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</span><br><span class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果你不需要绘制任何内容，你可以通过View的setWillNotDraw(true)方法关闭绘制，在默认情况下，View没有启用这个优化标志位，但是ViewGroup会启用，所以<strong>当你的自定义ViewGroup需要通过onDraw来绘制内容时，需要显式的打开这个开关setWillNotDraw(false)，当你的自定义View不需要onDraw来绘制内容时，需要显式的关闭这个开关setWillNotDraw(true)</strong>。</p><h3 id="3、小结-1"><a href="#3、小结-1" class="headerlink" title="3、小结"></a>3、小结</h3><p>到这里，我们走完了View的绘制过程，我们再来看一下draw的整体流程：从ViewRootImp的performTraversals()方法进入performDraw()方法，开始整颗View树的绘制流程，在performDraw()方法中经过层层调用：<strong>ViewRootImpl :: draw() -&gt; ViewRootImpl :: drawSoftware() -&gt; View :: draw()</strong>，来到View的draw()方法，它里面定义了View绘制的6大步骤，其中对于View来说，直接调用onDraw()方法绘制自身，对于ViewGroup来说，还要通过dispatchDraw()把绘制子View的流程分发下去，一层层传递，直到所有View都绘制完毕。如图：</p><img src="/2019/07/22/View的工作原理/view6.png" title="view6"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们一直讲View的工作原理，但有没有发现ViewRootImpl也出现的很频繁，它虽然不是一个View，但它是连接View和Window之间的纽带，View三大工作流程的起点就是ViewRootImpl的performTraversals()方法，performTraversals()中依此调用了<strong>performMeasure() -&gt; performLayout() -&gt; performDraw()</strong>，分别对应顶级View的<strong>measure、layout和draw流程</strong>，然后顶级View的<strong>measure流程</strong>和<strong>layout流程</strong>又会分别调用我们熟悉的<strong>onMeasure()、onLayout()方法</strong> ，<strong>draw流程</strong>有点特别，它是通过<strong>dispatchDraw()方法</strong>来进行draw流程的传递, 而onDraw()方法只是单纯的绘制自身内容，在onMeasure()方法中会对所有child进行measure过程，同理onLayout()方法中会对所有child进行layout过程，dispatchDraw()方法中会对所有child进行draw过程，如此递归直到完成整颗View Hierarchy的遍历。</p><p>该过程如图:</p><img src="/2019/07/22/View的工作原理/view7.png" title="view7"><p>有的人说分析源码的阅读，只是追踪方法的调用链，这种过程毫无意义，但是我想说的是，要想更加深入的了解Android的机制，只有源码才能给你答案，在这个阅读过程要加入自己的思考，把它的知识点用自己的语言整理，然后有所收获，我觉得这就是它的意义所在。</p><p>参考资料：</p><p>《Android开发艺术探索》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Android中View一直扮演着一个很重要的角色，它是我们开发中视觉的呈现，我平常也使用着Android提供的丰富且功能强大的控件，有时候遇到一个很炫酷的自定义View的开源库，我们也是拿来主义，时间长了你就会发现你只是一个只会使用控件和依赖被人开源库的程序员，这并不是一个开发者，所以我们并不能只满足于使用，我们要理解它背后的工作原理和流程，这样才能自己做出一个属于自己的控件，一直都说自定View是Android进阶中的一道门槛，当其实自定义View当你理解了它的原理后，你就会发现它也不过如此。本文将从源码的角度探讨View工作的三大流程，对View做进一步的认识。俗话说的好：源码才是最好的老师。&lt;/p&gt;
    
    </summary>
    
    
      <category term="View机制" scheme="http://yoursite.com/categories/View%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="view" scheme="http://yoursite.com/tags/view/"/>
    
  </entry>
  
  <entry>
    <title>java面向对象</title>
    <link href="http://yoursite.com/2019/07/19/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/07/19/java面向对象/</id>
    <published>2019-07-19T04:29:50.000Z</published>
    <updated>2019-10-08T09:28:00.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一篇文章<a href="https://rain9155.github.io/2019/07/19/java%E5%9F%BA%E7%A1%80/#more" target="_blank" rel="noopener">java基础</a><br>本篇文章继续Java知识点的归纳，梳理一下关于面向对象的知识点，涉及到封装、继承、多态，还有接口，类之间的关系。</li></ul><a id="more"></a><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><h3 id="1、抽象类"><a href="#1、抽象类" class="headerlink" title="1、抽象类"></a>1、抽象类</h3><p>抽象类和抽象方法都用abstract关键字进行声明，抽象类不能被实例化，不能直接创建，抽象方法必须放在抽象类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类实现抽象方法，完成实际操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Warrior</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类继续声明为抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LongRange</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2、接口"><a href="#2、接口" class="headerlink" title="2、接口"></a>2、接口</h3><p>接口被认为是一种特殊的抽象类，同样不能使用new实例化，包含常量和待实现的方法，java8以后接口中可以有方法的实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eat</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、接口和抽象类的比较"><a href="#3、接口和抽象类的比较" class="headerlink" title="3、接口和抽象类的比较"></a>3、接口和抽象类的比较</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">变量</th><th style="text-align:center">成员方法</th><th style="text-align:center">构造方法</th><th style="text-align:center">使用场合</th></tr></thead><tbody><tr><td style="text-align:center">抽象类</td><td style="text-align:center">无限制</td><td style="text-align:center">无限制</td><td style="text-align:center">可以有</td><td style="text-align:center">强的“is a”关系（是一种）</td></tr><tr><td style="text-align:center">接口</td><td style="text-align:center">所有变量必须是public static final</td><td style="text-align:center">所有方法必须是public abstract</td><td style="text-align:center">无</td><td style="text-align:center">弱的“is a”关系（is kind of，是一类）</td></tr></tbody></table><p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低，而且接口可以实现多继承。</p><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h3><p>尽可能地隐藏对象内部的实现细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><h3 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h3><p>继承是一种“is a”关系，父类和子类之间必须存在“is a”关系，父类的私有属性在子类中不能直接访问，例如Cat 和 Animal 就是一种 “is a” 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><h4 id="2-1、父类构造和子类构造"><a href="#2-1、父类构造和子类构造" class="headerlink" title="2.1、父类构造和子类构造"></a>2.1、父类构造和子类构造</h4><ul><li>构造方法不可继承，使用super关键字调用父类构造</li><li>默认会先调用父类构造，再调用子类构造</li></ul><h4 id="2-2、子类调用父类信息"><a href="#2-2、子类调用父类信息" class="headerlink" title="2.2、子类调用父类信息"></a>2.2、子类调用父类信息</h4><ul><li>使用super关键字</li><li>可以调用父类的公有属性和方法</li><li>可以调用父类的protected属性和方法</li></ul><p>下面一张表给出java中访问权限修饰符的访问范围：</p><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">在同一类中可访问</th><th style="text-align:center">在同一包内可访问</th><th style="text-align:center">在子类内可访问</th><th style="text-align:center">在不同包可访问</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">可以</td><td style="text-align:center">可以</td><td style="text-align:center">可以</td><td style="text-align:center">可以</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">可以</td><td style="text-align:center">可以</td><td style="text-align:center">可以</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">可以</td><td style="text-align:center">可以</td><td style="text-align:center">–</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">可以</td><td style="text-align:center">–</td><td style="text-align:center">–</td><td style="text-align:center">–</td></tr></tbody></table><h4 id="2-3、方法重写"><a href="#2-3、方法重写" class="headerlink" title="2.3、方法重写"></a>2.3、方法重写</h4><p>在子类中提供一个对方法的新的实现。</p><ul><li>方法重写发生在通过继承而相关的不同类中</li><li>方法重写具有相同的方法签名和返回值</li><li>子类重写方法时子类方法访问权限大于父类的</li><li>子类重写方法时子类抛出的异常类型是父类抛出异常的子类。</li><li>@Overiide称为重写标注，用来保证重写的方法和原方法的签名和返回值一致</li></ul><p>ps:方法重载：方法重载是指在于同一个类中，一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。</p><h3 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a>3、多态</h3><p>同一个实体，具有多种形式，多态分为以下两种：</p><ul><li>编译时多态：主要指方法的重载</li><li>运行时多态：指程序中定义的对象引用所指向的具体类型在运行期间才确定（运行时多态有三个条件：继承，方法重写，向上转型）</li></ul><p>例如下面的代码中，子类Warrior<strong>继承</strong>父类Hero，它<strong>重写</strong>了父类的fight方法，并且在main函数中父类Hero引用子类Warrior（父类引用指向子类对象称为<strong>向上转型</strong>），在Hero引用调用fight方法时，会执行实际对象所在类的fight方法，即Warrior类的fight方法，而不是Hero的fight方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hero"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Warrior</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Warrior"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Hero warrior = <span class="keyword">new</span> Warrior();</span><br><span class="line">    warrior.fight();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：Warrior</span><br></pre></td></tr></table></figure><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>了解下面6种关系有助于看懂UML图。</p><h3 id="1、泛化关系（Generalization）"><a href="#1、泛化关系（Generalization）" class="headerlink" title="1、泛化关系（Generalization）"></a>1、泛化关系（Generalization）</h3><p>泛化关系用一条带空心箭头的直线表示，在类图中表示为类的继承关系（“is a”关系），在java中用extends关键字表示，最终代码中，泛化关系表现为继承非抽象类。例如下面ASUS继承自Laptop，ASUS是一台笔记本，ASUS与Laptop之间是泛化关系。</p><img src="/2019/07/19/java面向对象/generalization.png" title="generalization"><h3 id="2、实现关系（Realization）"><a href="#2、实现关系（Realization）" class="headerlink" title="2、实现关系（Realization）"></a>2、实现关系（Realization）</h3><p>实现关系用一条带空心箭头的虚线表示，在类图中表示实现了一个接口（在java中用implements 关键字表示），或继承抽象类，实现了抽象类中的方法。例如下面Laptop实现了IO接口，同时它继承Computer这个抽象类，Laptop是它们的具体实现。</p><img src="/2019/07/19/java面向对象/realization.png" title="realization"><h3 id="3、聚合关系（Aggregation）"><a href="#3、聚合关系（Aggregation）" class="headerlink" title="3、聚合关系（Aggregation）"></a>3、聚合关系（Aggregation）</h3><p>聚合关系用一条带空心菱形箭头的直线表示，表示整体是由部分组成的，但是整体和部分之间并不是强依赖的，整体不存在了，部分还是会存在。例如下面表示Staff聚合到Department，或者说部门是由员工组成的，部门不存在了，员工还是会存在的。</p><img src="/2019/07/19/java面向对象/aggregation.png" title="aggregation"><h3 id="4、组合关系-Composition"><a href="#4、组合关系-Composition" class="headerlink" title="4、组合关系  ( Composition )"></a>4、组合关系  ( Composition )</h3><p>组合关系是用一条带实心菱形箭头的直线表示，和聚合关系不同，组合关系中整体和部分是强依赖的，即整体不存在了部分也不存在，组合关系是一种强依赖的特殊聚合关系。例如下面表示Department组合到Company中，或者说Company是由Department组成的，但是公司不存在了，部门也将不存在。</p><img src="/2019/07/19/java面向对象/composition.png" title="composition"><h3 id="5、关联关系（Association）"><a href="#5、关联关系（Association）" class="headerlink" title="5、关联关系（Association）"></a>5、关联关系（Association）</h3><p>关联关系用一条直线表示，表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示.。例如下面学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><img src="/2019/07/19/java面向对象/association.png" title="association"><p>关联关系默认不强调方向，表示对象之间相互知道，如果要特别强调方向，如下图，表示A知道B，但是B不知道A，这又叫DirectedAssociation。</p><img src="/2019/07/19/java面向对象/directedassociation.png" title="directedassociation"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 在最终代码中，关联对象通常以成员变量的形式存在。</span><br></pre></td></tr></table></figure><h3 id="6、依赖关系（Dependency）"><a href="#6、依赖关系（Dependency）" class="headerlink" title="6、依赖关系（Dependency）"></a>6、依赖关系（Dependency）</h3><p>依赖关系用一条带箭头的虚线表示，与关联关系不同的是，他描述一个对象在运行期间会用到另一个对象的关系，是一种动态关系，并且随着运行时的变化， 依赖关系也可能发生变化。依赖也有方向，但是我们总是应该保持单向依赖，避免双向依赖的产生。例如下面表示A依赖于B，A的一个方法中使用到了B作为参数。</p><img src="/2019/07/19/java面向对象/dependency.png" title="dependency"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps: 在最终代码中，依赖关系主要表现为：</span><br><span class="line">1、A 类是 B 类方法的局部变量；</span><br><span class="line">2、A 类是 B 类方法或构造的传入参数；</span><br><span class="line">3、A 类向 B 类发送消息，从而影响 B 类发生变化;</span><br></pre></td></tr></table></figure><p>箭头的指向为调用关系。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文都是关于面向对象的一些知识，虽然简单，但是也挺繁琐的，积少成多，希望大家阅读过后有所收获。</p><p>参考资料：</p><p><a href="https://www.jianshu.com/p/00cb3c4e6336" target="_blank" rel="noopener">看懂UML类图和时序图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一篇文章&lt;a href=&quot;https://rain9155.github.io/2019/07/19/java%E5%9F%BA%E7%A1%80/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java基础&lt;/a&gt;&lt;br&gt;本篇文章继续Java知识点的归纳，梳理一下关于面向对象的知识点，涉及到封装、继承、多态，还有接口，类之间的关系。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>java线程池</title>
    <link href="http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2019/07/19/java线程池/</id>
    <published>2019-07-19T04:26:00.000Z</published>
    <updated>2019-10-08T09:27:13.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一篇文章：<a href="https://rain9155.github.io/2019/07/19/java%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">java线程</a></li></ul><p>当我们需要频繁的创建多个线程时，每次都通过new一个Thread是一种不好的操作，创建一个线程是要消耗资源，频繁的创建会导致性能较差，而且我们还要管理多个线程的状态，管理不好还可能会出现死锁，浪费资源。这时就需要java提供的线程池，它能够有效的管理、调度线程，避免过多资源的消耗，通过线程池的统一调度、管理，使得多线程开发变得更简单。本文讲解一下有关线程池的知识点。</p><a id="more"></a><h2 id="Executor、ExecutorService、Executors、ThreadPoolExecutor之间的关系"><a href="#Executor、ExecutorService、Executors、ThreadPoolExecutor之间的关系" class="headerlink" title="Executor、ExecutorService、Executors、ThreadPoolExecutor之间的关系"></a>Executor、ExecutorService、Executors、ThreadPoolExecutor之间的关系</h2><p>Executor是一个接口，里面只有一个方法execute(Runnable command)，用来提交任务到线程池执行。ExecutorService继承Executor，同样是一个接口，里面提供了更多的方法用于操作线程池，如Future&lt;?&gt; submit(Runnable task)可以提交有返回值的任务到线程池执行，shutdown()用来关闭线程池。ThreadPoolExecutor是真正的线程池的实现，它实现了上面接口的方法，还提供了一系列参数来配置线程池。Executors是一个工厂类，通过它提供的工厂方法可以创建不同的线程池。</p><p>下面一张图说明的它们之间的关系。</p><img src="/2019/07/19/java线程池/thread1.jpg" title="thread1"><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor是线程池的真正实现，它的构造方法提供了一系列的参数来配置线程池，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>下面对这几个参数进行说明：</p><h3 id="1、int-corePoolSize"><a href="#1、int-corePoolSize" class="headerlink" title="1、int  corePoolSize"></a>1、int  corePoolSize</h3><p>线程池中的核心线程数。</p><p>线程池启动后默认是空的，只有任务到来时才会创建线程以处理请求，ThreadPoolExecutor的prestartAllCoreThreads()方法可以在线程池启动后立即创建所有的核心线程以等待任务。</p><p>还有在默认情况下，核心线程一旦创建后就会在线程池中一直存活，即使它们处于空闲状态，如果设置ThreadPoolExecutor的allowCoreThreadTimeOut(boolean value)方法为true，那么空闲的核心线程在等待新任务到来时就会有超时策略，这个超时时间由keepAliveTime指定，当等待时间超过keepAliveTime后，核心线程就会被终止。</p><h3 id="2、int-maximumPoolSize"><a href="#2、int-maximumPoolSize" class="headerlink" title="2、int  maximumPoolSize"></a>2、int  maximumPoolSize</h3><p>线程池所能创建的最大线程数，它与<strong>corePoolSize</strong>、<strong>workQueue</strong>共同调整线程池中实际运行的线程数量。</p><p>当线程池中的工作线程数小于corePoolSize时，每次来任务的时候都会创建一个新的工作线程。不管工作线程集合中有没有线程是处于空闲状态。</p><p>当池中工作线程数大于等于 corePoolSize 的时候，每次任务来的时候都会首先尝试将线程放入队列，而不是直接去创建线程。</p><p>如果放入队列失败，说明队列满了，且当线程中线程数小于 maximumPoolSize 的时候，则会创建一个工作线程（非核心线程）来执行这个任务，如果线程池中的线程数大于maximumPoolSize，调用给定的拒绝策略。</p><p>如果任务成功放入队列，则看看是否需要开启新的线程来执行任务，只有当当前工作线程数为0的时候才会创建新的线程，因为之前的线程有可能因为都处于空闲状态或因为工作结束等待超时而被移除，否则就从队列中一个个取出任务给空闲的线程执行。</p><p>如图，线程池的工作流程如下:</p><h3 id="3、-long-keepAliveTime"><a href="#3、-long-keepAliveTime" class="headerlink" title="3、 long  keepAliveTime"></a>3、 long  keepAliveTime</h3><p>非核心线程空闲时的超时时长，超过这个时长，非核心线程就会被回收。</p><p>这是一种减少不必要资源消耗的策略，这个参数可以在运行时被改变，我们同样可以将这种策略应用给核心线程，我们可以通过调用 allowCoreThreadTimeout 来实现。</p><h3 id="4、TimeUnit-unit"><a href="#4、TimeUnit-unit" class="headerlink" title="4、TimeUnit  unit"></a>4、TimeUnit  unit</h3><p>指定keepAliveTime的单位，可选值有毫秒、秒、分等。</p><h3 id="5、-BlockingQueue-workQueue"><a href="#5、-BlockingQueue-workQueue" class="headerlink" title="5、 BlockingQueue   workQueue"></a>5、 BlockingQueue   workQueue</h3><p>线程池中的任务队列，用来保存等待执行任务的阻塞队列。</p><p>首先 BlockingQueue 是一个接口，这是一个很特殊的队列，如果 BlockQueue 是空的，从 BlockingQueue 取东西的操作将会被阻断进入等待状态，直到 BlockingQueue 进了东西才会被唤醒。同样，如果 BlockingQueue 是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到 BlockingQueue 里有空间才会被唤醒继续操作。</p><p>BlockingQueue 大致有四个实现类，如下：</p><ul><li>ArrayBlockingQueue：规定大小的基于数据结构的 BlockingQueue，即有界队列，其构造函数必须带一个 int 参数来指明其大小。其所含的对象是以 FIFO(先入先出)顺序排序的。如果队列满了调用给定的拒绝策略。</li><li>LinkedBlockingQueue： 大小不定的基于链表结构的 BlockingQueue，既可以有界也可以无界，若其构造函数带一个规定大小的参数，生成的 BlockingQueue 有大小限制，若不带大小参数，所生成的 BlockingQueue 的大小由 Integer.MAX_VALUE 来决定。其所含的对象是以 FIFO(先入先出)顺序排序的。所以如果该队列是无界的，则可以忽略给定的拒绝策略，因为它永远都不会满，同时还可以忽略maximumPoolSize 参数，因为起当核心线程都在忙的时候，新的任务被放在队列上，永远不会有大于 corePoolSize 的线程被创建。</li><li>PriorityBlockingQueue：类似于 LinkedBlockQueue，但其所含对象的排序不是 FIFO，而是依据对象的自然排序顺序或者是构造函数的 Comparator 决定的顺序。</li><li>SynchronousQueue：特殊的 BlockingQueue，对其的操作必须是放和取交替完成的。因为其特殊的操作，所以如果有一个任务要插入队列，那么它必须要等到另一个移除任务的操作。所以使用该队列会直接把任务提交给线程池，而不会将任务加入队列，如果线程池没有任何可用的线程处理，就调用给定的拒绝策略。</li></ul><p>BlockingQueue 的常用方法：</p><ul><li>add(anObject)：把 anObject 加到 BlockingQueue 里，即如果 BlockingQueue 可以容纳，则返回 true，否则报异常。</li><li>offer(anObject)：表示如果可能的话，将 anObject 加到 BlockingQueue 里，即如果 BlockingQueue 可以容纳，则返回 true，否则返回 false。</li><li>put(anObject)：把 anObject 加到 BlockingQueue 里，如果 BlockQueue 没有空间，则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续。</li><li>take()：取走 BlockingQueue 里排在首位的对象，若 BlockingQueue 为空，阻断进入等待状态直到 Blocking 有新的对象被加入为止。</li><li>poll(time)：取走 BlockingQueue 里排在首位的对象，若不能立即取出，则可以等 time 参数规定的时间，取不到时返回 null。</li></ul><h3 id="6、ThreadFactory-threadFactory"><a href="#6、ThreadFactory-threadFactory" class="headerlink" title="6、ThreadFactory  threadFactory"></a>6、ThreadFactory  threadFactory</h3><p>线程工厂，让用户可以定制创建线程的过程。</p><p>ThreadFactory  是一个接口，它只有一个Thread newThread(Runnable r)方法，如果没有指定threadFactory，默认的 Executors的defaultThreadFactory 将被使用，这个时候创建的线程将都属于同一个线程组，拥有同样的优先级和 daemon 状态。</p><p>我们可以扩展配置 ThreadFactory，我们可以配置线程的名字、线程组合 、daemon 状态。如果调用 ThreadFactory的newThread失败，将返回 null，executor 将不会执行任何任务。</p><h3 id="7、RejectedExecutionHandler-handler"><a href="#7、RejectedExecutionHandler-handler" class="headerlink" title="7、RejectedExecutionHandler handler"></a>7、RejectedExecutionHandler handler</h3><p>当新任务到来时，线程池被关闭或线程数和队列已经达到上限的时候，对新任务采取的处理策略。</p><p>RejectedExecutionHandler 同样是一个接口，里面只有一个rejectedExecution(Runnable r, ThreadPoolExecutor executor)方法，下面介绍一下几个默认的实现，都定义在ThreadPoolExecutor中：</p><ul><li>AbortPolicy：直接抛出 RejectedExecutionException 异常。线程池的默认实现。</li><li>CallerRunsPolicy：这个策略将会使用 Caller 线程来执行这个任务，这是一种 feedback 策略，可以降低任务提交的速度。</li><li>DiscardPolicy：这个策略将会直接丢弃任务。</li><li>DiscardOldestPolicy：这个策略将会把任务队列头部的任务丢弃，然后重新尝试执行，如果还是失败则继续实施策略。这样的结果是最后加入的任务反而更有可能被执行。</li></ul><h2 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h2><p>线程池的生命周期包含3种状态，如下：</p><h3 id="1、运行"><a href="#1、运行" class="headerlink" title="1、运行"></a>1、运行</h3><p>线程池创建后就进入运行状态，这个时候可以向线程池提交任务，可以通过ThreadPoolExecutor的execute()和submit()方法。</p><p>execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</p><p>而submit方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get方法来获取返回值，get方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程timeout时间后立即返回，这时候有可能任务没有执行完，当线程池的任务还没有执行完时，会报超时异常。</p><h3 id="2、关闭"><a href="#2、关闭" class="headerlink" title="2、关闭"></a>2、关闭</h3><p>当调用ThreadPoolExecutor的shutdown或shutdownNow方法后，便会进入关闭状态，这时意味线程池不再接受新的任务。这时isShutdown方法返回true。</p><p>调用shutdown方法会等待线程执行完毕后再关闭线程池，但是如果调用的是shutdownNow方法，则相当于调用每个线程的interrupt方法。</p><p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p><h3 id="3、终止"><a href="#3、终止" class="headerlink" title="3、终止"></a>3、终止</h3><p>在关闭状态的线程池执行完所有已经提交的任务后，就变为终止状态，这时调用isTerminated方法会返回true。</p><h2 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h2><p>通过配置ThreadPoolExecutor的构造函数的参数就可以实现不同类形的线程池，它们分别是：FixedThreadPool、CachedThreadPool、ScheduleThreadPool和SingleThreadExecutor。</p><h3 id="1、FixedThreadPool"><a href="#1、FixedThreadPool" class="headerlink" title="1、FixedThreadPool"></a>1、FixedThreadPool</h3><p>顾名思义，就是一种固定线程数量的线程池。前面讲过，创建线程池是通过工厂类来Executors创建的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到核心线程数和最大线程数相同，并且没有超时机制，而且任务队列为无界队列。</p><p>这说明当线程处于空闲状态时，它们并不会被回收，除非线程池关闭，当有新任务到来时，它能快速的处理这个任务，如果所有的线程都处于工作状态，那么新任务就会被放入等待队列，并且任务队列能容纳无限个任务。</p><h3 id="2、CachedThreadPool"><a href="#2、CachedThreadPool" class="headerlink" title="2、CachedThreadPool"></a>2、CachedThreadPool</h3><p>   与第一种相反，它是一种线程数量不定的线程池。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的核心线程数为0，最大线程数为Integer.MAX_VALUE，相当于无限大，这说明线程池中的线程足够多，每个线程的超时时间为60秒，超过60秒空闲的线程就会被回收，它的任务队列是SynchronousQueue，它是一种特殊的队列，每当有任务插入队列，它都会把它直接提交给线程池处理。</p><p>所以这个线程池适用于任务并发量比较大的场景，每当有新任务到来，如果没有空闲线程，它都会创建一个线程处理，如果有空闲线程就交给空闲线程处理。</p><h3 id="3、ScheduleThreadPool"><a href="#3、ScheduleThreadPool" class="headerlink" title="3、ScheduleThreadPool"></a>3、ScheduleThreadPool</h3><p>它的核心线程数是固定，但是非核心线程数是不定的线程池。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_KEEPALIVE_MILLIS = <span class="number">10L</span>;</span><br><span class="line"> MILLISECONDS(TimeUnit.MILLI_SCALE),</span><br></pre></td></tr></table></figure><p>它主要用于执行定时任务和具有固定周期的重复任务，下面演示一下如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建定时执行的线程池</span></span><br><span class="line">        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//参数1是执行的任务，参数2是第一次运行任务延迟的时间，参数3是定视任务的周期，参数4是单位</span></span><br><span class="line">        executor.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"工作线程： "</span> + Thread.currentThread().getName() + <span class="string">", 结果："</span> + fibc(<span class="number">10</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fibc</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fibc(n - <span class="number">1</span>) + fibc(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面设计了一个定时任务，计算10的斐波那契数，它会延时1秒后开始执行，然后每隔2秒重复执行一次。</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> ScheduledThreadPoolDemo().doWork();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">工作线程： pool-<span class="number">1</span>-thread-<span class="number">1</span>, 结果：<span class="number">55</span></span><br><span class="line">工作线程： pool-<span class="number">1</span>-thread-<span class="number">1</span>, 结果：<span class="number">55</span></span><br><span class="line">工作线程： pool-<span class="number">1</span>-thread-<span class="number">2</span>, 结果：<span class="number">55</span></span><br><span class="line">工作线程： pool-<span class="number">1</span>-thread-<span class="number">2</span>, 结果：<span class="number">55</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4、SingleThreadExecutor"><a href="#4、SingleThreadExecutor" class="headerlink" title="4、SingleThreadExecutor"></a>4、SingleThreadExecutor</h3><p>它是只有一个核心线程的线程池。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它相当于大小为一的FixedThreadPool。</p><p>因为只有一个线程用来执行任务，所以使得这些任务之间不需要处理线程同步的问题，任务都按顺序的排队执行。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有关线程池的知识先介绍到这里了，了解线程池后，才能更好得去运用它。</p><p>参考资料：</p><p><a href="https://www.jianshu.com/p/80797a141e66" target="_blank" rel="noopener">Java并发之线程池</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一篇文章：&lt;a href=&quot;https://rain9155.github.io/2019/07/19/java%E7%BA%BF%E7%A8%8B/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java线程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当我们需要频繁的创建多个线程时，每次都通过new一个Thread是一种不好的操作，创建一个线程是要消耗资源，频繁的创建会导致性能较差，而且我们还要管理多个线程的状态，管理不好还可能会出现死锁，浪费资源。这时就需要java提供的线程池，它能够有效的管理、调度线程，避免过多资源的消耗，通过线程池的统一调度、管理，使得多线程开发变得更简单。本文讲解一下有关线程池的知识点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>java线程</title>
    <link href="http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/19/java线程/</id>
    <published>2019-07-19T04:25:50.000Z</published>
    <updated>2019-10-08T09:27:44.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在java中，线程非常重要，我们要分清楚进程和线程的区别：进程是指一个内存中运行的应用程序，每个进程都拥有自己的一块独立的内存空间，进程之间的资源不共享；线程是CPU调度的最小单元，一个进程可以有多个线程，线程之间的堆空间是共享的，但栈空间是独立的，java程序的进程至少包含主线程和后台线程(垃圾回收线程)。了解这些知识后，来看下文有关线程的知识。</p><a id="more"></a><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>我们先来看一下概念：</p><ul><li>并行：指两个或多个事件在<strong>同一时刻点</strong>发生</li><li>并发：指两个或多个事件在<strong>同一时间段内发生</strong></li></ul><p>对于单核CPU的计算机来说，它是不能并行的处理多个任务，它的每一时刻只能有一个程序执行时间片（时间片是指CPU分配给各个程序的运行时间），故在微观上这些程序只是<strong>分时交替的运行</strong>，所以在宏观看来在一段时间内有多个程序在同时运行，看起来像是并行运行。</p><p>对于多核CPU的计算机来说，它就可以并行的处理多个任务，可以做到多个程序在同一时刻同时运行。</p><p>同理对线程也一样，但系统只有一个CPU时，线程会以某种顺序执行，我们把这种情况称为线程调度，所以从宏观角度上看线程是并行运行的，但是从微观角度来看，却是串行运行，即一个线程一个线程的运行。</p><h2 id="线程的创建与启动"><a href="#线程的创建与启动" class="headerlink" title="线程的创建与启动"></a>线程的创建与启动</h2><p>有3种方式使用线程。</p><h3 id="方式1：继承Thread类"><a href="#方式1：继承Thread类" class="headerlink" title="方式1：继承Thread类"></a>方式1：继承Thread类</h3><p>定义一个类继承java.lang.Thread类，重写Thread类中的run方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">     thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式2：实现Runnable接口"><a href="#方式2：实现Runnable接口" class="headerlink" title="方式2：实现Runnable接口"></a>方式2：实现Runnable接口</h3><h4 id="2-1：定义一个类实现Runnable接口"><a href="#2-1：定义一个类实现Runnable接口" class="headerlink" title="2.1：定义一个类实现Runnable接口"></a>2.1：定义一个类实现Runnable接口</h4><p>实现 Runnable只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2、使用匿名内部类"><a href="#2-2、使用匿名内部类" class="headerlink" title="2.2、使用匿名内部类"></a>2.2、使用匿名内部类</h4><p>这种方式只适用于这个线程只使用一次的情况，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式3：实现Callable接口"><a href="#方式3：实现Callable接口" class="headerlink" title="方式3：实现Callable接口"></a>方式3：实现Callable接口</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装，所以在创建Thread时，要把FutureTask 传进去，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承与实现的区别"><a href="#继承与实现的区别" class="headerlink" title="继承与实现的区别"></a>继承与实现的区别</h3><p>1、继承方式：</p><p>（1）java中类是单继承的，如果继承了Thread，该类就不能有其他父类了，但是可以实现多个接口</p><p>（2）从操作上分析，继承方式更简单，获取线程名字也简单</p><p>2、实现方式：</p><p>（1）java中类可以实现多接口，此时该类还可以继承其他类，并且还可以实现其他接口</p><p>（2）从操作上分析，实现方式稍复杂，获取线程名字也比较复杂，得通过Thread.currentThread来获取当前线程得引用</p><p>综上所述，实现接口会更好一些。</p><h2 id="线程的中断与终止"><a href="#线程的中断与终止" class="headerlink" title="线程的中断与终止"></a>线程的中断与终止</h2><h3 id="1、interrupt-、isInterrupted-、interrupted-的作用"><a href="#1、interrupt-、isInterrupted-、interrupted-的作用" class="headerlink" title="1、interrupt()、isInterrupted()、interrupted()的作用"></a>1、interrupt()、isInterrupted()、interrupted()的作用</h3><p>中断就是线程的一个标识位，它表示一个运行中的线程是否被其他线程调用了中断操作，其他线程可以通过调用线程的interrupt()方法对其进行中断操作，线程可以通过调用isInterrupted()方法判断是否被中断，线程也可以通过调用Thread的interrupted()静态方法对当前线程的中断标识位进行复位。</p><p>大家不要认为调用了线程的interrupt()方法，该线程就会停止，它只是做了一个标志位，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个死循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"InterruptThread正在执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    InterruptThread interruptThread = <span class="keyword">new</span> InterruptThread();</span><br><span class="line">    interruptThread.start();</span><br><span class="line">    interruptThread.interrupt();<span class="comment">//调用线程的interrupt()</span></span><br><span class="line">    System.out.println(<span class="string">"interruptThread是否被中断，interrupt  = "</span> + interruptThread.isInterrupted());<span class="comment">//此时isInterrupted()方法返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">interruptThread是否被中断，interrupt  = <span class="keyword">true</span></span><br><span class="line">InterruptThread正在执行</span><br><span class="line">InterruptThread正在执行</span><br><span class="line">InterruptThread正在执行</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>可以看到当你调用了线程的interrupt()方法后，此时调用isInterrupted()方法会返回true，但是该线程还是会继续执行下去。所以怎么样才能终止一个线程的运行呢？</p><h3 id="2、终止线程的运行"><a href="#2、终止线程的运行" class="headerlink" title="2、终止线程的运行"></a>2、终止线程的运行</h3><p>一个线程正常执行完run方法之后会自动结束，如果在运行过程中发生异常也会提前结束；所以利用这两种情况，我们还可以通过以下三种种方式安全的终止运行中的线程：</p><h4 id="2-1、利用中断标志位"><a href="#2-1、利用中断标志位" class="headerlink" title="2.1、利用中断标志位"></a>2.1、利用中断标志位</h4><p>前面讲到的中断操作就可以用来取消线程任务，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted())&#123;<span class="comment">//利用中断标记位</span></span><br><span class="line">            System.out.println(<span class="string">"InterruptThread正在执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当不需要运行InterruptThread线程时，通过调用InterruptThread.interrupt()使得isInterrupted()返回true，就可以让线程退出循环，正常执行完毕之后自动结束。</p><h4 id="2-2、利用一个boolean变量"><a href="#2-2、利用一个boolean变量" class="headerlink" title="2.2、利用一个boolean变量"></a>2.2、利用一个boolean变量</h4><p>利用一个boolean变量和上述方法同理，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isCancel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isCancel)&#123;<span class="comment">//利用boolean变量</span></span><br><span class="line">            System.out.println(<span class="string">"InterruptThread正在执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isCancel = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当不需要运行InterruptThread线程时，通过调用InterruptThread.cancel()使isCancel等于true，就可以让线程退出循环，正常执行完毕之后自动结束，这里要注意boolean变量要用volatile修饰保证内存的可见性。</p><h4 id="2-3、响应InterruptedException"><a href="#2-3、响应InterruptedException" class="headerlink" title="2.3、响应InterruptedException"></a>2.3、响应InterruptedException</h4><p>通过调用一个线程的 interrupt() 来中断该线程时，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程，例如当你调用Thread.sleep()方法时，通常会让你捕获一个InterruptedException异常，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);<span class="comment">//Thread.sleep会抛出InterruptedException</span></span><br><span class="line">                System.out.println(<span class="string">"InterruptThread正在执行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当不需要运行InterruptThread线程时，通过调用InterruptThread.interrupt()使得 Thread.sleep() 抛出InterruptedException，就可以让线程退出循环，提前结束。在抛出InterruptedException异常之前，JVM会把中断标识位复位，此时调用线程的isInterrupted()方法将会返回false。</p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h3 id="1、线程的6种状态"><a href="#1、线程的6种状态" class="headerlink" title="1、线程的6种状态"></a>1、线程的6种状态</h3><p>线程也是有生命周期，也就是存在不同的状态，状态之间相互转换，线程可以处于以下的状态之一：</p><h4 id="1-1、NEW-新建状态"><a href="#1-1、NEW-新建状态" class="headerlink" title="1.1、NEW(新建状态)"></a>1.1、NEW(新建状态)</h4><p>使用new创建一个线程对象，但还没有调用线程的start方法，<strong>Thread t = new Thread()</strong>，此时属于新建状态。</p><h4 id="1-2、RUNNABLE-可运行状态"><a href="#1-2、RUNNABLE-可运行状态" class="headerlink" title="1.2、RUNNABLE(可运行状态)"></a>1.2、RUNNABLE(可运行状态)</h4><p>但在新建状态下线程调用了start方法，<strong>t.start()</strong>，此时进入了可运行状态。可运行状态又分为两种状态：</p><ul><li>ready(就绪状态)：线程对象调用stat方法后，等待JVM的调度，此时线程并没有运行。</li><li>running(运行状态)：线程对象获得JVM调度，此时线程开始运行，如果存在多个CPU，那么允许多个线程并行运行。</li></ul><p>线程的start方法只能调用一次，否则报错（IllegalThreadStateException）。</p><h4 id="1-3、BLOCKED-阻塞状态"><a href="#1-3、BLOCKED-阻塞状态" class="headerlink" title="1.3、BLOCKED(阻塞状态)"></a>1.3、BLOCKED(阻塞状态)</h4><p>正在运行的线程因为某些原因放弃CPU，暂时停止运行，就会进入阻塞状态，此时JVM不会给该线程分配CPU，直到线程重新进入就绪状态，才有机会转到运行状态，阻塞状态只能先进入就绪状态，不能跳过就绪状态直接进入运行状态。线程进入阻塞状态常见的情况有：</p><ul><li>1、当A线程处于运行状态时，试图获取同步锁，却被B线程获取，此时JVM把当前A线程放到对象的锁池(同步队列)中，A线程进入阻塞状态，等待获取对象的同步锁。</li><li>2、当线程处于运行状态时，发出了IO请求，此时进入阻塞状态。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 如果是使用Synchronize关键字，那么尝试获取锁的线程会进入BLOCKED状态；如果是使用java.util.concurrent 类库中的Lock，那么尝试获取锁的线程则会进入WAITING或TIMED WAITING状态，因为java.util.concurrent 类库中的Lock是使用LockSupport来进行同步的。</span><br></pre></td></tr></table></figure><h4 id="1-4、WAITING-等待状态"><a href="#1-4、WAITING-等待状态" class="headerlink" title="1.4、WAITING(等待状态)"></a>1.4、WAITING(等待状态)</h4><p>正在运行的线程调用了无参数的wait方法，此时JVM把该线程放入对象的等待池（等待队列）中，此时线程进入等待状态，等待状态的线程只能被其他线程唤醒，否则不会被分配 CPU 时间片。下面是让线程进入等待状态的方法：</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>无Timeout参数的Object.wait()</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>无Timeout参数的Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><h4 id="1-5、TIMED-WAITING-计时等待状态"><a href="#1-5、TIMED-WAITING-计时等待状态" class="headerlink" title="1.5、TIMED WAITING(计时等待状态)"></a>1.5、TIMED WAITING(计时等待状态)</h4><p>正在运行的线程调用了有参数的wait方法，此时JVM把该线程放入对象的等待池中，此时线程进入计时等待状态，计时等待状态的线程被其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。下面是让线程进入等待状态的方法：</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>调用Thread.sleep(int timeout) 方法</td><td>时间结束</td></tr><tr><td>有Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>有Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps：阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</span><br></pre></td></tr></table></figure><h4 id="1-6、TREMINATED-终止状态"><a href="#1-6、TREMINATED-终止状态" class="headerlink" title="1. 6、TREMINATED(终止状态)"></a>1. 6、TREMINATED(终止状态)</h4><p>又称死亡状态，表示线程的终止。线程进入终止状态的情况有：</p><ul><li>1、正常执行完run方法，线程正常退出。</li><li>2、遇到异常而退出</li></ul><p>线程一旦终止了，就不能再次启动，否则报错（IllegalThreadStateException）</p><h3 id="2、线程的状态转换图"><a href="#2、线程的状态转换图" class="headerlink" title="2、线程的状态转换图"></a>2、线程的状态转换图</h3><img src="/2019/07/19/java线程/thread1.png" title="thread1"><h2 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h2><p>如果一个线程从头到尾的执行完一个任务，不需要和其他线程打交道的话，那么就不会存在安全性问题了，由于java内存模式的存在，如下：</p><img src="/2019/07/19/java线程/thread2.png" title="thread2"><p>每一个java线程都有自己的工作内存，线程之间要想协作完成一个任务，就必须通过主内存来通信，所以这里就涉及到对共享资源的竞争，在主内存中的东西都是线程之间共享，所以这里就必须通过一些手段来让线程之间完成正常通信。主要有以下两种方法：</p><h3 id="1、wait-notify-notifyAll-机制"><a href="#1、wait-notify-notifyAll-机制" class="headerlink" title="1、wait() / notify()  notifyAll() 机制"></a>1、wait() / notify()  notifyAll() 机制</h3><p>它们都是Object类中的方法，它们的主要作用如下：</p><ul><li>wait()：执行该方法的线程对象释放同步锁（这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁），然后JVM把该线程存放在等待池中，等待其他线程唤醒该线程</li><li>notify()：执行该方法的线程唤醒在等待池中等待的任意一个线程，把线程转到锁池中等待</li><li>notifyAll()：执行该方法的线程唤醒在等待池中等待的所有线程，把线程转到锁池中等待</li></ul><p>注意：上述方法只能在同步方法或者同步代码中使用，否则会报IllegalMonitorStateException异常，还有上述方法只能被同步监听锁对象来调用，不能使用其他对象调用，否则会报IllegalMonitorStateException异常。</p><p>假设A线程和B线程共同操作一个X对象，A、B线程可以通过X对象的wait方法和notify方法进行通信，流程如下：</p><p>1、当A线程执行X对象的同步方法时，A线程持有X对象的锁，则B线程没有执行同步方法的机会，B线程在X对象的锁池中等待。</p><p>2、A线程在同步方法中执行X.wait()时，A线程释放X对象的锁，进入X对象的等待池中。</p><p>3、在X对象的锁池中等待获取锁的B线程在这时获取X对象的锁，执行X对象的另一个同步方法。</p><p>4、B线程在同步方法中执行X.notify()或notifyAll()时，JVM把A线程从X对象的等待池中移到X对象的锁池中，等待获取锁。</p><p>5、B线程执行完同步方法，释放锁，A线程获取锁，从上次停下来的地方继续执行同步方法。</p><p>下面以一个ATM机存钱取钱的例子说明，ATM机要在银行把钱存进去后，其他人才能取钱，如果没钱取，只能先回家等待，等银行通知你有钱取了，再来取，如果有钱取，就直接取钱。</p><p>ATM机，存钱和取钱方法都是同步方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEmpty = <span class="keyword">true</span>;<span class="comment">//标志ATM是否有钱的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往ATM机中存钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//ATM中有钱，等待被人把钱取走</span></span><br><span class="line">            <span class="keyword">while</span> (!isEmpty)&#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中没钱了，开始存钱</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"发现ATM机没钱了，存钱中..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">this</span>.money = money;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"存钱完毕，存了"</span> + money + <span class="string">"元"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存钱完毕，把标志置为false</span></span><br><span class="line">            isEmpty = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中有钱了，通知别人取钱</span></span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从ATM机中取钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//ATM中没钱取，等待通知</span></span><br><span class="line">                <span class="keyword">while</span> (isEmpty)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"ATM机没钱，等待中..."</span>);</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//ATM中有钱了，开始取钱</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"收到通知，取钱中..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>+ <span class="string">"取出完毕，取出了"</span> + <span class="keyword">this</span>.money + <span class="string">"钱"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//取钱完毕，把标志置为true</span></span><br><span class="line">                isEmpty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//ATM没钱了，通知银行存钱</span></span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>银行， 需要传入同一个ATM示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blank</span> <span class="keyword">implements</span>  <span class="title">Runnable</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ATM mAtm;<span class="comment">//共享资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blank</span><span class="params">(ATM atm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mAtm = atm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//银行来存钱</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            mAtm.push(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小明， 需要传入同一个ATM示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ATM mAtm;<span class="comment">//共享资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(ATM atm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mAtm = atm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个人来取钱</span></span><br><span class="line">        mAtm.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端操作，我特地让小明提前来取钱，此时ATM机中是没钱的，小明要等待：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建一个ATM机</span></span><br><span class="line">       ATM atm = <span class="keyword">new</span> ATM();</span><br><span class="line">       <span class="comment">//小明来取钱</span></span><br><span class="line">       Thread tPerson = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(atm), <span class="string">"XiaoMing"</span>);</span><br><span class="line">       tPerson.start();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//银行来存钱</span></span><br><span class="line">       Thread tBlank = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blank(atm), <span class="string">"Blank"</span>);</span><br><span class="line">       tBlank.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XiaoMing:ATM机没钱，等待中...</span><br><span class="line">Blank:发现ATM机没钱了，存钱中...</span><br><span class="line">Blank:存钱完毕，存了<span class="number">100</span>元</span><br><span class="line">XiaoMing:收到通知，取钱中...</span><br><span class="line">XiaoMing:取出完毕，取出了<span class="number">100</span>钱</span><br><span class="line">Blank:发现ATM机没钱了，存钱中...</span><br><span class="line">Blank:存钱完毕，存了<span class="number">100</span>元</span><br></pre></td></tr></table></figure><p>可以看到，小明总是在收到ATM的通知后才来取钱，如果通过这个存钱取钱的例子还不了解wait/notify机制的话，可以看看这个<a href="https://mp.weixin.qq.com/s/OriB-ouTDuCzquoFmjv9Lg" target="_blank" rel="noopener">修厕所的例子</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: wait() 和 sleep() 的区别是什么，首先wait()是Object的方法，而sleep()是Thread的静态方法，其次调用wait()会释放同步锁，而sleep()不会，最后一点不同的是调用`wait`方法需要先获得锁，而调用`sleep`方法是不需要的。</span><br></pre></td></tr></table></figure><h3 id="2、await-signal-signalAll-机制"><a href="#2、await-signal-signalAll-机制" class="headerlink" title="2、await()  / signal() signalAll()机制"></a>2、await()  / signal() signalAll()机制</h3><p>从java5开始，可以使用Lock机制取代synchronized代码块和synchronized方法，使用java.util.concurrent 类库中提供的Condition 接口的await / signal() signalAll()方法取代Object的wait() / notify()  notifyAll() 方法。</p><p>下面使用Lock机制和Condition 提供的方法改写上面的那个例子，如下：</p><p>ATM2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATM2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEmpty = <span class="keyword">true</span>;<span class="comment">//标志ATM是否有钱的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock mLock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//新建一个lock</span></span><br><span class="line">    <span class="keyword">private</span> Condition mCondition = mLock.newCondition();<span class="comment">//通过lock的newCondition方法获得一个Condition对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往ATM机中存钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        mLock.lock();<span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//ATM中有钱，等待被人把钱取走</span></span><br><span class="line">            <span class="keyword">while</span> (!isEmpty)&#123;</span><br><span class="line">                mCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中没钱了，开始存钱</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"发现ATM机没钱了，存钱中..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">this</span>.money = money;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"存钱完毕，存了"</span> + money + <span class="string">"元"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存钱完毕，把标志置为false</span></span><br><span class="line">            isEmpty = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中有钱了，通知别人取钱</span></span><br><span class="line">            mCondition.signal();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            mLock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从ATM机中取钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mLock.lock();<span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中没钱取，等待通知</span></span><br><span class="line">            <span class="keyword">while</span> (isEmpty)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"ATM机没钱，等待中..."</span>);</span><br><span class="line">                 mCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中有钱了，开始取钱</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"收到通知，取钱中..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>+ <span class="string">"取出完毕，取出了"</span> + <span class="keyword">this</span>.money + <span class="string">"钱"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取钱完毕，把标志置为true</span></span><br><span class="line">            isEmpty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM没钱了，通知银行存钱</span></span><br><span class="line">            mCondition.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            mLock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到ATM2改写ATM后，把方法的synchronized去掉，因为Lock机制没有同步锁的概念，然后获取lock锁，在finally里释放lock锁，还把原本Object.wait()用Condition.await()代替，原本Object.notify()用Condition.signal()代替。</p><p>客户端操作只是把ATM换成ATM2，输出结果和上面的一样，就不在累述。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多线程通信的时候很容易造成死锁，死锁无法解决，只能避免。</p><h4 id="1、死锁是什么？"><a href="#1、死锁是什么？" class="headerlink" title="1、死锁是什么？"></a>1、死锁是什么？</h4><p>当A线程等待获取由B线程持有的锁，而B线程正在等待获取由A线程持有的锁，发生死锁现象，JVM既不检测也不会避免这种情况，所以程序员必须保证不导致死锁。</p><h4 id="2、如何避免死锁？"><a href="#2、如何避免死锁？" class="headerlink" title="2、如何避免死锁？"></a>2、如何避免死锁？</h4><p>1、当多个线程都要访问共享资源A、B、C时，保证每一个线程都按照相同的顺序去访问去访问他们，比如先访问A，接着访问B，最后访问C。</p><p>2、不要使用Thread类中过时的方法，因为容易导致死锁，所以被废弃，例如A线程获得对象锁，正在执行一个同步方法，如果B线程调用A线程的suspend()，此时A线程暂停运行，放弃CPU，但是不会放弃锁，所以B就永远不会得到A持有的锁。</p><h3 id="3、-Thread类中过时的方法"><a href="#3、-Thread类中过时的方法" class="headerlink" title="3、 Thread类中过时的方法"></a>3、 Thread类中过时的方法</h3><p>由于线程安全问题，被弃用，如下：</p><ul><li>void suspend()：暂停当前线程。</li><li>void resume()：恢复当前线程。</li><li>void stop()：结束当前线程</li></ul><p>suspend()方法在调用之后不会释放已经占有的资源(锁)，然后进入睡眠状态，这样很容易导致死锁； stop()方法直接终止线程，不会保证线程资源的正常释放，导致程序处于不确定状态。对于suspend()和 resume()可以用上面提到的等待/通知机制代替，而 stop()方法可以用上面提到的终止线程运行的3种方式代替。</p><h2 id="线程的控制操作"><a href="#线程的控制操作" class="headerlink" title="线程的控制操作"></a>线程的控制操作</h2><p>下面来看一些可以控制线程的操作。</p><h3 id="1、线程休眠"><a href="#1、线程休眠" class="headerlink" title="1、线程休眠"></a>1、线程休眠</h3><p>让执行的线程暂停等待一段时间，进入计时等待状态，使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用sleep()后，当前线程放弃CPU，在指定的时间段内，sleep所在的线程不会获得执行的机会，在此状态下该线程不会释放同步锁。</p><h3 id="2、联合线程"><a href="#2、联合线程" class="headerlink" title="2、联合线程"></a>2、联合线程</h3><p>在线程中调用另一个线程的 join() 方法，会将当前线程置于阻塞状态，等待另一个线程完成后才继续执行，原理就是等待/通知机制，使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"JoinThread执行完毕！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        JoinThread joinThread = <span class="keyword">new</span> JoinThread();</span><br><span class="line">        joinThread.start();</span><br><span class="line">        System.out.println(<span class="string">"主线程等待..."</span>);</span><br><span class="line">        joinThread.join();<span class="comment">//主线程等join线程执行完毕后才继续执行</span></span><br><span class="line">        System.out.println(<span class="string">"主线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">主线程等待...</span><br><span class="line">JoinThread执行完毕！</span><br><span class="line">主线程执行完毕</span><br></pre></td></tr></table></figure><p>对于以上代码，主线程会等join线程执行完毕后才继续执行，因此最后的结果能保证join线程的输出先于主线程的输出。</p><h3 id="3、后台线程"><a href="#3、后台线程" class="headerlink" title="3、后台线程"></a>3、后台线程</h3><p>顾名思义，在后台运行的线程，其目的是为其他线程提供服务，也称“守护线程”，JVM的垃圾回收线程就是典型的后台线程，通过<strong>t.setDaemon(true)</strong>把一个线程设置为后台线程，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeamonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//主线程不是后台线程，是前台线程</span></span><br><span class="line">        DeamonThread deamonThread = <span class="keyword">new</span> DeamonThread();</span><br><span class="line">        deamonThread.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置子线程为后台线程</span></span><br><span class="line">        deamonThread.start();</span><br><span class="line">        <span class="comment">//通过deamonThread.isDaemon()判断是否是后台线程</span></span><br><span class="line">        System.out.println(deamonThread.isDaemon());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果：<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>后台线程有以下几个特点：</p><p>1、若所有的前台线程死亡，后台线程自动死亡，若前台线程没有结束，后台线程是不会结束的。</p><p>2、前台线程创建的线程默认是前台线程，可以通过setDaemon(true)设置为后台线程，在后台线程创建的新线程，新线程是后台线程。</p><p>注意：t.setDaemon(true)方法必须在start方法前调用，否则会报IllegalMonitorStateException异常</p><h3 id="4、线程优先级"><a href="#4、线程优先级" class="headerlink" title="4、线程优先级"></a>4、线程优先级</h3><p>当线程的时间片用完时就会发生线程调度，而线程优先级就是决定线程需要多或少分配一些CPU时间片的线程属性，在java中，通过一个成员变量priority来控制优先级，在线程构建时可以通过setPriority(int)方法来修改线程的优先级，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    PriorityThread priorityThread = <span class="keyword">new</span> PriorityThread();</span><br><span class="line">    priorityThread.setPriority(Thread.MAX_PRIORITY);<span class="comment">//10</span></span><br><span class="line">    priorityThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先级范围从1到10，默认是5，优先级高的线程分配的时间片数量要多于优先级低的线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 在不同的JVM以及操作系统上，线程优先级规划会有差异，有些操作系统会忽略对线程优先级的设定，所以线程优先级不能作为程序正确性的依赖保证，因为操作系统可以完全不用理会线程优先级的设定</span><br></pre></td></tr></table></figure><h3 id="5、线程礼让"><a href="#5、线程礼让" class="headerlink" title="5、线程礼让"></a>5、线程礼让</h3><p>对静态方法 Thread.yield() 的调用，声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"已经完成重要部分，可以让其他线程获取CPU时间片"</span>);</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。也就是说，就算你执行了这个方法，该线程还是有可能继续运行下去。</p><h3 id="6、线程组"><a href="#6、线程组" class="headerlink" title="6、线程组"></a>6、线程组</h3><p>java.lang.ThreadGroup类表示线程组，可以对一组线程进行集中管理，当用户在创建线程对象时，可以通过构造器指定其所属的线程组：Thread(ThreadGroup group, String name)。</p><p>如果A线程创建B线程，如果没有设置B线程的分组，那么B线程加入到A线程的线程组，一旦线程加入某个线程组，该线程就一直存在于该线程组中直到线程死亡，不能在中途修改线程的分组。</p><p>当java程序运行时，JVM会创建名为main的线程组，在默认情况下，所以的线程都属于该线程组。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>限于篇幅，还有<strong>ThreadLocal</strong>，<strong>线程池</strong>的知识点没写，就留到下一篇了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在java中，线程非常重要，我们要分清楚进程和线程的区别：进程是指一个内存中运行的应用程序，每个进程都拥有自己的一块独立的内存空间，进程之间的资源不共享；线程是CPU调度的最小单元，一个进程可以有多个线程，线程之间的堆空间是共享的，但栈空间是独立的，java程序的进程至少包含主线程和后台线程(垃圾回收线程)。了解这些知识后，来看下文有关线程的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础</title>
    <link href="http://yoursite.com/2019/07/19/java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/07/19/java基础/</id>
    <published>2019-07-19T04:24:58.000Z</published>
    <updated>2019-08-16T01:38:50.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>万事开头难，准备从零把java相关知识点捡起来，把自己所学的Java知识点归纳，下面是关于java的一些基本知识点。</p><a id="more"></a><h2 id="java代码的运行过程"><a href="#java代码的运行过程" class="headerlink" title="java代码的运行过程"></a>java代码的运行过程</h2><img src="/2019/07/19/java基础/java1.png" title="java1"><ul><li>创建java源程序，扩展名为.java</li><li>使用javac命令编译源程序为字节码文件，扩展名为.class</li><li>使用java命令运行字节码文件，在不同平台执行<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2>下面用一张表概括：</li></ul><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">类型说明符</th><th style="text-align:center">位数</th><th style="text-align:center">字节</th></tr></thead><tbody><tr><td style="text-align:center">整形</td><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">短整型</td><td style="text-align:center">short</td><td style="text-align:center">16</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">长整形</td><td style="text-align:center">long</td><td style="text-align:center">64</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">字节型</td><td style="text-align:center">byte</td><td style="text-align:center">8</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">单精度浮点型</td><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">双精度浮点型</td><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">布尔类型</td><td style="text-align:center">boolean</td><td style="text-align:center">8</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">字符类型</td><td style="text-align:center">char</td><td style="text-align:center">16</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">字符串类型</td><td style="text-align:center">String</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">自定义类型</td><td style="text-align:center">public class …</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><p>其中java的数据类型又分为：</p><ul><li><p>基本类型/原始类型（primitive type）：用来保存简单的单个数据，如：int、short、long、byte、float、double、boolean、char共8种。</p></li><li><p>类类型/引用类型（class type or reference types）：用来保存复杂的组合数据，如String和自定义类型。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 在java中，char类型实际是一个16位的无符号整数（&lt;=65535）,可以保存中文和转义字符(`\b`,`\t`,`\n`等)。</span><br></pre></td></tr></table></figure><h2 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line"></span><br><span class="line">    数据类型 变量<span class="number">1</span>；<span class="comment">//成员变量</span></span><br><span class="line">    </span><br><span class="line">    返回值类型 方法名()&#123;</span><br><span class="line">    </span><br><span class="line">        数据类型 变量<span class="number">2</span>；<span class="comment">//局部变量</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、成员变量的作用域在整个类都是可见的。<br>2、局部变量的作用域仅在定义它们的方法中可见。<br>3、成员变量有默认的初始值（数字为0，对象为null）。<br>4、局部变量没有默认的初始值，需要赋初值再使用。<br>5、成员变量和局部变量重名时，局部变量的优先级更高。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1、String类型"><a href="#1、String类型" class="headerlink" title="1、String类型"></a>1、String类型</h3><p>在java中String是引用类型，它的构造器如下：</p><img src="/2019/07/19/java基础/java2.png" title="java2"><p>除了用以上new的方法创建一个字符串，还可以用以下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name1 = <span class="string">"rain"</span>;</span><br><span class="line">String name2 = <span class="string">"rain"</span>;</span><br></pre></td></tr></table></figure><p>那么用<code>new</code>和用<code>=</code>有什么不同的呢? new出来字符串是一个String对象，它被放在堆中，地址不一样。用=赋值的字符串是从字符串池（String Pool，保存着所有字符串字面量，这些字面量在编译时期就确定）中拿的，如果这个字符串在池中没有，就会先放进池，所以上面两个name1和name2是同一个字符串。</p><p><strong>String中常用的方法：</strong></p><img src="/2019/07/19/java基础/java3.png" title="java3"><p><strong>String的比较：</strong></p><img src="/2019/07/19/java基础/java4.png" title="java4"><p><strong>获取String的字串的方法：</strong></p><img src="/2019/07/19/java基础/java5.png" title="java5"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps: </span><br><span class="line">1、在字符串的比较中`==`是用来比较地址的，String的equals方法才是用来比较两个字符串是否相等 </span><br><span class="line">2、字符串的拼接可以使用`+`,这个运算符的底层其实是调用了String的concat方法，返回一个新的字符串</span><br><span class="line">3、在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误</span><br><span class="line">4、在 Java 8 中，String 内部使用 char 数组存储数据，在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，这些数组在都用final修饰，所以才保证String是不可变的</span><br></pre></td></tr></table></figure><h3 id="2、StringBuffer和StringBuilder"><a href="#2、StringBuffer和StringBuilder" class="headerlink" title="2、StringBuffer和StringBuilder"></a>2、StringBuffer和StringBuilder</h3><p>与String类不同的是，StringBuffer和StringBuilder的对象可以被多次修改，并且不产生新的未使用对象，而String是不可变的。StringBuilder是在JDK5中被提出来的，它和StringBuffer之间最大的不同是StringBuilder的方法都不是线程安全的，而StringBuffer的方法都是线程安全的。</p><p><strong>StringBuffer的构造方法（StringBuilder类似）：</strong></p><img src="/2019/07/19/java基础/java6.png" title="java6"><p><strong>StringBuffer的常用方法：</strong></p><img src="/2019/07/19/java基础/java7.png" title="java7"><h3 id="3、-思考："><a href="#3、-思考：" class="headerlink" title="3、 思考："></a>3、 思考：</h3><p>分别使用+、StringBuffer和StringBuilder来拼接字符串，各自的效率怎么样？</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>包装类就是将java的基本数据类型打包成对象处理，包装类都在java.lang包中，下面用一个表显示：</p><table><thead><tr><th style="text-align:center">基本数据类型</th><th style="text-align:center">包装类</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">Interger</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">Boolean</td></tr></tbody></table><p>它涉及到以下两种操作：</p><h3 id="1、装箱-boxing"><a href="#1、装箱-boxing" class="headerlink" title="1、装箱(boxing)"></a>1、装箱(boxing)</h3><p>以double装箱为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> num = <span class="number">3.14</span>；</span><br><span class="line">Double dnum1 = <span class="keyword">new</span> Double(num);<span class="comment">//1</span></span><br><span class="line">Double dnum2 = Double.valueOf(num);<span class="comment">//2</span></span><br><span class="line">Double dnum3 = num;<span class="comment">//3</span></span><br></pre></td></tr></table></figure></p><p>注释1、2都是手动装箱，注释3是自动装箱。</p><h3 id="2、拆箱-unboxing"><a href="#2、拆箱-unboxing" class="headerlink" title="2、拆箱(unboxing)"></a>2、拆箱(unboxing)</h3><p>同样上述double拆箱为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = dnum1;<span class="comment">//1</span></span><br><span class="line">num = dnum2.doubleValue;<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><p>注释1是自动拆箱，注释2是手动拆箱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps:</span><br><span class="line">1、包装类没有无参构造，所有包装类的实例都是不可变的，一旦创建对象后，它们的内部值就不能再改变。</span><br><span class="line">2、每个基本类型包装类都有常量MAX_VALUE和MIN_VALUE。</span><br><span class="line">3、每个包装类都会有一个默认大小的缓存池，例如Integer，缓存池默认大小是-128-127</span><br><span class="line">3、编译器会在自动装箱过程中会调用 valueOf() 方法，因此多个值相同，且值在缓存池范围内的包装类实例使用自动装箱来创建，那么就会引用相同的对象。</span><br></pre></td></tr></table></figure><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="1、final"><a href="#1、final" class="headerlink" title="1、final"></a>1、final</h3><p>防止扩展和重写。</p><ul><li>修饰成员变量：常量（可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量），不可更改（对于基本数据类型，final使数值不能改变，对于引用类型，final使引用不能改变，即不能引用其他对象，但引用本身可以更改）</li><li>修饰方法：不可被重写</li><li>修饰类：不可被继承</li></ul><h3 id="2、static"><a href="#2、static" class="headerlink" title="2、static"></a>2、static</h3><p>可以通过类名直接访问它修饰的属性，静态属性和方法都是优先于类的实例存在。</p><ul><li>修饰变量：称为静态变量（区别于实例变量）、类变量，类的所有实例都共享静态变量，静态变量在内存中只存在一份</li><li>修饰方法：称为静态方法，静态方法必须有实现，它不依赖于任何实例，静态方法中只能调用类的静态属性和静态方法，方法中不能有 this 和 super 关键字</li><li>修饰语句块：称为静态语句块，在类初始化时运行一次</li><li>修饰内部类：称为静态内部类，非静态内部类依赖于外部类的实例，而静态内部类不需要</li></ul><p>存在继承的情况下，初始化顺序为：</p><p>父类(静态变量、静态语句块) -&gt; 子类（静态变量、静态语句块） -&gt; 父类（实例变量、普通语句块）-&gt; 父类（构造函数）-&gt; 子类（实例变量、普通语句块） -&gt; 子类（构造函数）</p><h2 id="关于hashCode（）和equal（）方法"><a href="#关于hashCode（）和equal（）方法" class="headerlink" title="关于hashCode（）和equal（）方法"></a>关于hashCode（）和equal（）方法</h2><p>hashCode()用来返回hash值，而equal()是用来判断两个对象是否等价，所以：</p><ul><li><p>要比较两个对象是否相等，必须使用equal方法，如果相等，那么调用两个对象的 hashCode 方法必须返回相同的结果</p></li><li><p>如果两个对象根据 equals方法比较是不相等的，则 hashCode 方法不一定得返回不同的整数</p></li><li><p>对同一个对象调用多次hashcode方法必须返回相同的hash值</p></li><li><p>两个不同对象的hashcode可能相等</p></li><li><p>两个不同hashcode的对象一定不相等</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps:  在使用hashXX集合添加对象时，集合先调用该对象的equal方法查看当前集合是否有与之相等的对象，如果有，就再调用该对象的hashCode方法返回hash值，看是否与相等的对象的hashCode方法返回的hash值相等，如果相等，就不添加这个对象，否则就添加，因此在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象hash值也相等，不然会导致集合中出现重复的元素。</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常就是一种对象(Exception), 表示阻止程序正常执行的错误。异常类的层次结构如下：</p><img src="/2019/07/19/java基础/error1.png" title="error1"><ul><li>1、RuntimeException和Error以及它们的子类都称为免检异常</li><li>2、除了免检异常，其他异常都称为必检异常</li></ul><p>由于免检异常可能在程序的任何一个地方出现，为了避免过多的使用try-catch块，java语言不强制要求编写代码捕获免检异常，也不要求在方法头显示声明免检异常。</p><h3 id="1、常见的异常类型"><a href="#1、常见的异常类型" class="headerlink" title="1、常见的异常类型"></a>1、常见的异常类型</h3><img src="/2019/07/19/java基础/error2.png" title="error2"><h3 id="2、java中的异常处理机制"><a href="#2、java中的异常处理机制" class="headerlink" title="2、java中的异常处理机制"></a>2、java中的异常处理机制</h3><p>异常处理机制就是可以使程序处理非预期的情景，并继续正常执行，异常处理机制的主要组成如下：</p><ul><li>try：监控有可能产生异常的语句块</li><li>catch：以合理的方式捕获异常</li><li>finally：不管有没有异常，一定会执行的语句块（一般用来释放资源），除了遇到System.exit(0)语句</li><li>throw：手动引发异常</li><li>throws: 指定由方法引发的异常</li></ul><p>所以一个异常捕获处理语句可以如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//监控可能产生异常的语句块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception1 e)&#123;</span><br><span class="line">    <span class="comment">//捕获异常，处理异常，如打印异常信息，日志纪录</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception2 e)&#123;</span><br><span class="line">    <span class="comment">//JDK7后简化写法catch(Exception1|Exception2|Exception3|... e)</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管有无异常，一定会执行的语句，用来释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try块中的代码可能会引发多种类型的异常，当引发异常时，会按照catch的顺序进行匹配异常类型，并执行第一个匹配的catch语句</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文简单整理了一下java语言的基本知识点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;万事开头难，准备从零把java相关知识点捡起来，把自己所学的Java知识点归纳，下面是关于java的一些基本知识点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>如何获取Android应用和系统信息</title>
    <link href="http://yoursite.com/2019/07/12/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Android%E5%BA%94%E7%94%A8%E4%B8%8E%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2019/07/12/如何获取Android应用与系统信息/</id>
    <published>2019-07-12T14:36:32.000Z</published>
    <updated>2019-10-08T09:30:38.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本主要了解一下Android系统信息的获取，apk应用信息的获取。</p><a id="more"></a><pre><code>本文相关源码在文末给出</code></pre><h2 id="Android系统信息的获取"><a href="#Android系统信息的获取" class="headerlink" title="Android系统信息的获取"></a>Android系统信息的获取</h2><p>有时我们想要获取手机系统的配置信息，通常可以从以下俩方面获取：</p><ul><li><p>android.os.Build</p></li><li><p>SystemProperty</p></li></ul><h3 id="1、android-os-Build"><a href="#1、android-os-Build" class="headerlink" title="1、android.os.Build"></a>1、android.os.Build</h3><p>android.os.Build包含了系统编译时的大量设备，配置信息，它里面的字段含义如下：</p><ul><li>Build.BOARD; //主板</li><li>Build.BRAND; //Android系统指定商</li><li>supported_abis = null;//CPU指令集</li><li>Build.DEVICE;//设备参数</li><li>Build.DISPLAY;//显示屏参数</li><li>Build.FINGERPRINT;//唯一编号</li><li>Build.SERIAL;//硬件序列号</li><li>Build.ID;//修订版本列表</li><li>Build.MANUFACTURER;//硬件制造商</li><li>Build.MODEL;//版本</li><li>Build.HARDWARE;//硬件名</li><li>Build.PRODUCT;//手机产品名</li><li>Build.TAGS;//描述Build的标签</li><li>Build.TYPE;//Builder类型</li><li>Build.VERSION.CODENAME;//当前开发号</li><li>Build.VERSION.INCREMENTAL;//源码版本控制号</li><li>Build.VERSION.RELEASE;//版本字符串</li><li>Build.VERSION.SDK_INT;//版本号</li><li>Build.HOST;//Host值</li><li>Build.USER;//User名</li><li>Build.TIME;//编译时间<h3 id="2、SystemProperty"><a href="#2、SystemProperty" class="headerlink" title="2、SystemProperty"></a>2、SystemProperty</h3>SystemProperty包含许多系统，配置属性值和参数，很多与上面通过android.os.Build获取的相同,下面给出常用的信息：</li><li>System.getProperty(“os.version”);//os 版本</li><li>System.getProperty(“os.name”);//os 名称</li><li>System.getProperty(“os.arch”);//os 架构</li><li>System.getProperty(“user.home”);//Home 属性</li><li>System.getProperty(“user.name”);//Name 属性</li><li>System.getProperty(“user.dir”);//Dir 属性</li><li>System.getProperty(“user.timezone”);//时区</li><li>System.getProperty(“path.separator”);//路径分隔符</li><li>System.getProperty(“line.separator”);//行分隔符</li><li>System.getProperty(“file.separator”);//文件分隔符</li><li>System.getProperty(“java.vendor.url”);//java vender URL 属性</li><li>System.getProperty(“java.class.path”);//java Class 路径</li><li>System.getProperty(“java.class.version”);//java Class 版本</li><li>System.getProperty(“java.vendor”);//java Vender 属性</li><li>System.getProperty(“java.version”);//java 版本</li><li>System.getProperty(“java_home”);//java HOME属性<h3 id="3、实例"><a href="#3、实例" class="headerlink" title="3、实例"></a>3、实例</h3></li></ul><p>通过一个简单的示例查看如何使用（更多细节查看文末源码），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通过android.os.Build，可以直接获得一些Build提供的系统信息 */</span></span><br><span class="line">String board = Build.BOARD;</span><br><span class="line">String brand = Build.BRAND;</span><br><span class="line">Log.d(TAG, <span class="string">"android.os.Build，board："</span> + board);</span><br><span class="line">Log.d(TAG, <span class="string">"android.os.Build，brand： "</span> + brand);</span><br><span class="line"><span class="comment">/* 通过SystemProperty，要使用System.getProperty("XXX") */</span></span><br><span class="line">String os_version = System.getProperty(<span class="string">"os.version"</span>);</span><br><span class="line">String os_name = System.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">Log.d(TAG, <span class="string">"SystemProperty，os_version: "</span> + os_version);</span><br><span class="line">Log.d(TAG, <span class="string">"SystemProperty, os_name: "</span> + os_name);</span><br></pre></td></tr></table></figure><p>可以看到，获取系统信息还是很简单的。</p><h2 id="Apk应用信息的获取"><a href="#Apk应用信息的获取" class="headerlink" title="Apk应用信息的获取"></a>Apk应用信息的获取</h2><p>Apk应用信息的获取无非分为，apk包信息的获取与应用进程信息的获取。</p><h3 id="1、PackageManager"><a href="#1、PackageManager" class="headerlink" title="1、PackageManager"></a>1、PackageManager</h3><p>通过PackageManager可以获得应用的apk包信息，先看下面一张图：</p><img src="/2019/07/12/如何获取Android应用与系统信息/system1.png" title="system1"> <p>最里面的框代表了整个Activity的信息，系统提供了ActivityInfo类来进行封装，以此类推。</p><h4 id="1-1、下面列举一些常用的系统封装信息"><a href="#1-1、下面列举一些常用的系统封装信息" class="headerlink" title="1.1、下面列举一些常用的系统封装信息"></a>1.1、下面列举一些常用的系统封装信息</h4><p>下面这些封装信息与PackageManager在同一个包内。</p><ul><li><strong>ActivityInfo</strong><br>ActivityInfo 封装了在Manifest文件中\<activity>\</activity>和\<receiver>\</receiver>之间的所有信息，包括name，icon，label，launchmod等 。</li><li><strong>ServiceInfo</strong><br>和ActivityInfo类似，它封装了\<service>\</service>之间的所有信息 。</li><li><strong>ApplicationInfo</strong><br>它封装了\<application>\</application>之间的信息，特别的是，Application包含很多Flag，FLAG_SYSTEM表示为系统应用，FLAG_EXTERNAL_STORAGE表示为安装在sd卡上的应用等，通过这些FLAG可以很方便的判断应用类型 。</li><li><strong>PackageInfo</strong><br>它用于封装Manifest文件相关节点的信息，包含了所有Activity、Service等信息 。</li><li><p><strong>ResolveInfo</strong><br>这个比较特殊，它封装的是包含\<intent>信息的上一级信息，所以它可以返回ActivityInfo，ServiceInfo等包含<intent>的信息，它经常用来帮助我们找到那些包含特定intent条件的信息，如带分享，播放功能的应用。</intent></intent></p><p>  通过上面的对象，PackageManager 就可以通过调用各种方法来返回不同类型的Bean</p></li></ul><h4 id="1-2、PackageManager常用方法"><a href="#1-2、PackageManager常用方法" class="headerlink" title="1.2、PackageManager常用方法"></a>1.2、PackageManager常用方法</h4><ul><li><strong>getPackagerManager</strong>: 通过调用这个方法返回一个PackageManager对象</li><li><strong>getApplicationInfo</strong>: 以ApplicationInfo形式返回指定包名的Application</li><li><strong>getApplicationIcon</strong>：返回指定包名的icon</li><li><strong>getInstalledApplications</strong>： 以ApplicationInfo形式返回安装的应用</li><li><strong>getInstalledPackages</strong>：以PackageInfo的形式返回安装的应用</li><li><strong>queryIntentActivities</strong>: 返回指定intent的ResolveInfo对象、Activity集合</li><li><strong>queryIntentServices</strong>：返回指定intent的ResolveInfo对象、service集合</li><li><strong>resolveActivity</strong>：返回指定intent的Activity</li><li><strong>resolveService</strong>：返回指定的intentService<h4 id="1-3、实例"><a href="#1-3、实例" class="headerlink" title="1.3、实例"></a>1.3、实例</h4></li></ul><p>下面通过一个例子来了解如何通过PackageManager来选出不同类型的app，判断app类型的依据，就是利用Applicationinfo中的FLAG_SYSTEM来进行判断，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.flags &amp; Applicationinfo.FLAG_SYSTEM</span><br></pre></td></tr></table></figure><ul><li><strong>如果flags &amp; Applicationinfo.FLAG_SYSTEM ！= 0，则为系统应用</strong></li><li><strong>如果flags &amp; Applicationinfo.FLAG_SYSTEM &lt;= 0, 则为第三方应用</strong> </li><li><strong>如果flags &amp; Applicationinfo.FLAG_EXTERNAL_STORAGE != 0, 则为SD卡上的应用</strong> </li><li><strong>特殊的，当系统应用经过升级后，也将成为第三方应用：flags &amp; Applicationinfo.FLAG_UPDATED_SYSTEM_APP != 0</strong></li></ul><p>首先封装一个Bean保存我所需要的app信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PMAppInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String appName;<span class="comment">//app名称</span></span><br><span class="line">    <span class="keyword">private</span> Drawable appIcon;<span class="comment">//图标</span></span><br><span class="line">    <span class="keyword">private</span> String pkgName;<span class="comment">//所在包名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PMAppInfo</span><span class="params">(String appLabel, Drawable appIcon, String pkgName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.appName = appLabel;</span><br><span class="line">        <span class="keyword">this</span>.appIcon = appIcon;</span><br><span class="line">        <span class="keyword">this</span>.pkgName = pkgName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppLabel</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.appName = appName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drawable <span class="title">getAppIcon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appIcon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppIcon</span><span class="params">(Drawable appIcon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.appIcon = appIcon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPkgName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pkgName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPkgName</span><span class="params">(String pkgName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pkgName = pkgName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，通过上面所说的方法判断各种类型的app：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;PMAppInfo&gt; <span class="title">getAppInfoList</span><span class="params">(<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">        pm = <span class="keyword">this</span>.getPackageManager();</span><br><span class="line">        <span class="comment">//获取应用信息</span></span><br><span class="line">        List&lt;ApplicationInfo&gt; applicationInfoList = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES);</span><br><span class="line">        List&lt;PMAppInfo&gt; appInfoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//判断应用类型</span></span><br><span class="line">        <span class="keyword">switch</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">case</span> ALL_APP:</span><br><span class="line">                appInfoList.clear();</span><br><span class="line">                <span class="keyword">for</span> (ApplicationInfo app : applicationInfoList) &#123;</span><br><span class="line">                    appInfoList.add(<span class="keyword">new</span> PMAppInfo(</span><br><span class="line">                            ((String) app.loadLabel(pm)),</span><br><span class="line">                            app.loadIcon(pm),</span><br><span class="line">                            app.packageName));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SYSTEM_APP:</span><br><span class="line">                appInfoList.clear();</span><br><span class="line">                <span class="keyword">for</span> (ApplicationInfo app : applicationInfoList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((app.flags &amp; ApplicationInfo.FLAG_SYSTEM) != <span class="number">0</span>) &#123;</span><br><span class="line">                        appInfoList.add(<span class="keyword">new</span> PMAppInfo(</span><br><span class="line">                                ((String) app.loadLabel(pm)),</span><br><span class="line">                                app.loadIcon(pm),</span><br><span class="line">                                app.packageName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> THIRD_APP:</span><br><span class="line">                appInfoList.clear();</span><br><span class="line">                <span class="keyword">for</span> (ApplicationInfo app : applicationInfoList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((app.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        appInfoList.add(<span class="keyword">new</span> PMAppInfo(</span><br><span class="line">                                ((String) app.loadLabel(pm)),</span><br><span class="line">                                app.loadIcon(pm),</span><br><span class="line">                                app.packageName));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((app.flags &amp; ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != <span class="number">0</span>) &#123;</span><br><span class="line">                        appInfoList.add(<span class="keyword">new</span> PMAppInfo(</span><br><span class="line">                                ((String) app.loadLabel(pm)),</span><br><span class="line">                                app.loadIcon(pm),</span><br><span class="line">                                app.packageName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SDCARD_APP:</span><br><span class="line">                appInfoList.clear();</span><br><span class="line">                <span class="keyword">for</span> (ApplicationInfo app : applicationInfoList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((app.flags &amp; ApplicationInfo.FLAG_EXTERNAL_STORAGE) != <span class="number">0</span>) &#123;</span><br><span class="line">                        appInfoList.add(<span class="keyword">new</span> PMAppInfo(</span><br><span class="line">                                ((String) app.loadLabel(pm)),</span><br><span class="line">                                app.loadIcon(pm),</span><br><span class="line">                                app.packageName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> appInfoList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行效果图：</p><img src="/2019/07/12/如何获取Android应用与系统信息/system2.png" title="system2">  <p>如上图所示，通过点击不同的按钮，在下方显示出不同类型的apk信息。</p><h3 id="2、ActivityManager"><a href="#2、ActivityManager" class="headerlink" title="2、ActivityManager"></a>2、ActivityManager</h3><p>前面使用了PackageManager获得了应用包的信息，PackageMessager重点在于获得应用的包信息，而ActivityManager重点在于获得在运行时的应用程序的进程信息。</p><h4 id="2-1、同PackageManager一样，-ActivityManager也封装了很多Bean对象"><a href="#2-1、同PackageManager一样，-ActivityManager也封装了很多Bean对象" class="headerlink" title="2.1、同PackageManager一样， ActivityManager也封装了很多Bean对象"></a>2.1、同PackageManager一样， ActivityManager也封装了很多Bean对象</h4><p>下面的封装类都在ActivityManager的类中。</p><ul><li><p><strong>ActivityManager.MemoryInfo</strong><br>它封装了内存信息，MemoryInfo中有几个重要的字段：availMem - 系统可用内存，totalMen - 总内存，threshold - 低内存的阈值，即区分是否是低内存，lowMemory - 是否处于低内存。</p></li><li><p><strong>Debug.MemoryInfo</strong><br>android中还有一个MemoryInfo，它来自Debug.MemoryInfo,前面的MemoryInfo通常用于获取全局的内存使用信息，而它用于统计进程下的内存信息。</p></li><li><p><strong>RunningAppProcessInfo</strong><br>顾名思义，就是运行间进程信息，储存的字段自然进程相关的信息，processName - 进程名， pid - 进程pid, uid - 进程uid，pkgList - 该进程下所有的包 。 </p></li><li><p><strong>RunningServiceInfo</strong><br>RunningServiceInfo与RunningAppProcessInfo类似，用于封装运行时的服务信息，它包含了进程信息的同时还包含了其他的信息，activeSince - 第一次被激活的时间，方式，foreground - 服务是否在后台运行。</p></li></ul><h4 id="2-2、实例"><a href="#2-2、实例" class="headerlink" title="2.2、实例"></a>2.2、实例</h4><p>下面同样通过一个例子来使用ActivityManager，先封装一个Bean来保存一个我们需要的字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMProcessInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> String pid;</span><br><span class="line">    <span class="keyword">private</span> String memorySize;</span><br><span class="line">    <span class="keyword">private</span> String processName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AMProcessInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPid</span><span class="params">(String pid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pid = pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMemorySize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memorySize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemorySize</span><span class="params">(String memorySize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memorySize = memorySize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProcessName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> processName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProcessName</span><span class="params">(String processName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.processName = processName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用getRunningAppProcesses（）返回当前运行时的进程信息集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;AMProcessInfo&gt; <span class="title">getRunningProcessesInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      amProcessInfoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">//获取正在运行的进程集合</span></span><br><span class="line">      List&lt;ActivityManager.RunningAppProcessInfo&gt; appProcessList = am.getRunningAppProcesses();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; appProcessList.size(); i++) &#123;</span><br><span class="line">          ActivityManager.RunningAppProcessInfo info = appProcessList.get(i);</span><br><span class="line">          <span class="keyword">int</span> pid = info.pid;</span><br><span class="line">          <span class="keyword">int</span> uid = info.uid;</span><br><span class="line">          String processName = info.processName;</span><br><span class="line">          <span class="comment">//获取该进程下的内存</span></span><br><span class="line">          <span class="keyword">int</span>[] memoryPid = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pid&#125;;</span><br><span class="line">          Debug.MemoryInfo[] memoryInfo = am.getProcessMemoryInfo(memoryPid);</span><br><span class="line">          <span class="keyword">int</span> memorySize = memoryInfo[<span class="number">0</span>].getTotalPss();</span><br><span class="line">          AMProcessInfo processInfo = <span class="keyword">new</span> AMProcessInfo();</span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          processInfo.setPid(<span class="string">""</span> + pid);</span><br><span class="line">          processInfo.setUid(<span class="string">""</span> + uid);</span><br><span class="line">          processInfo.setMemorySize(<span class="string">""</span> + memorySize);</span><br><span class="line">          processInfo.setProcessName(processName);</span><br><span class="line">          amProcessInfoList.add(processInfo);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> amProcessInfoList;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>运行效果图： </p><img src="/2019/07/12/如何获取Android应用与系统信息/system3.png" title="system3"> <p>上图运行给出了当前运行的一个进程的pid，uid，占用内存，进程名的信息。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>PackageManager是用来获取apk包信息的，ActivityManager是用来获取运行时进程信息的，如果想要获取手机系统信息，可以通过SystemProperty和android.os.Build，本文同样是一篇学习记录，希望大家读完后和我一样有所收获。</p><p><a href="https://github.com/rain9155/AndroidMessageObtainTest" target="_blank" rel="noopener">本文相关源码位置</a></p><p>参考资料：</p><p>《android群英传》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本主要了解一下Android系统信息的获取，apk应用信息的获取。&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="ActivityManager" scheme="http://yoursite.com/tags/ActivityManager/"/>
    
      <category term="PackageManager" scheme="http://yoursite.com/tags/PackageManager/"/>
    
  </entry>
  
  <entry>
    <title>SVG入门学习</title>
    <link href="http://yoursite.com/2019/07/12/SVG%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/07/12/SVG入门学习/</id>
    <published>2019-07-12T09:39:00.000Z</published>
    <updated>2019-10-08T09:26:36.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SVG对于android开发者听起来是陌生的东西，因为它是属于前端的产物，其实Android中也是支持SVG的，语法也很简单易懂，本文就通过我自己学习的经历，和大家一起学习一下SVG。</p><a id="more"></a><h2 id="什么是SVG"><a href="#什么是SVG" class="headerlink" title="什么是SVG?"></a>什么是SVG?</h2><p>Google 在Android5.X中增加了对SVG矢量图形的支持，可以用来创建高效率的动画, 所以我们先来了解一下SVG的定义： </p><ul><li>可伸缩矢量图形（Scalable Vector Graphics）</li><li>使用XML格式定义图形</li><li>图像在放大或改变尺寸的情况下图片质量不会有所损失</li><li>android中使用vector标签表示SVG</li></ul><p>与bitmap相比，SVG最大的优点是放大不会失真，而bitmap需要为不同的分辨率准备很多套图标，而SVG则不需要，前面说了SVG要用vector表示，我们先来看看vector标签中属性的含义。</p><h2 id="vector的各个属性是什么意义？"><a href="#vector的各个属性是什么意义？" class="headerlink" title="vector的各个属性是什么意义？"></a>vector的各个属性是什么意义？</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>  //命名空间</span></span><br><span class="line"><span class="tag">    <span class="attr">android:height</span>=<span class="string">"200dp"</span>  //这个是图片的<span class="attr">intrinsic</span>高度</span></span><br><span class="line"><span class="tag">    <span class="attr">android:width</span>=<span class="string">"200dp"</span>   //这个是图片的<span class="attr">intrinsic</span>宽度</span></span><br><span class="line"><span class="tag">    <span class="attr">android:viewportHeight</span>=<span class="string">"100"</span>    //这个是为这个图片设置的纵坐标,表示将图片分为<span class="attr">100</span>等份,主要下面的<span class="attr">pathData</span>需要依赖这个坐标的划分</span></span><br><span class="line"><span class="tag">    <span class="attr">android:viewportWidth</span>=<span class="string">"100"</span>     //同上,只不过这个是横坐标, <span class="attr">heigh</span>，<span class="attr">width</span>的比例和<span class="attr">viewportHeight</span>，<span class="attr">viewportWidth</span>的比例必须保持一致，不然图形就会发生形变</span></span><br><span class="line"><span class="tag">    <span class="attr">android:alpha</span>=<span class="string">"0.2"</span>     //这个是整个图像的透明度,取值范围<span class="attr">0</span>到<span class="attr">1</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;group      //这个标签中可以放入若干个&lt;path/&gt;标签,并给它们设置一些共同的属性</span><br><span class="line">        android:name="group_name"   //这个name很有用,在设置objectAnimator的时候用来区分给那个部分施加动画</span><br><span class="line">        android:pivotY="50"     //这个设置这个group的中心点的X坐标,取值范围为0到100,在做rotation时有用</span><br><span class="line">        android:pivotX="50"     //这个设置这个group的中心点的Y坐标,取值范围为0到100,在做rotation时有用</span><br><span class="line">        android:translateX="20" //将整个group在X轴方向平移多少像素</span><br><span class="line">        android:translateY="30" //将整个group在Y轴方向平移多少像素</span><br><span class="line">        android:rotation="90"   //将整个group以中心点左边旋转的角度,360为一圈</span><br><span class="line">        android:scaleX="0.5"    //横坐标的缩放比例 , 取值1表示100%</span><br><span class="line">        android:scaleY="0.3"&gt;   //纵坐标的缩放比例,取值0.5表示50%,取值1.5表示150%</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>   //这个标签是重头戏,矢量图绘制的路径</span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"path_name"</span>    //为这个<span class="attr">path</span>标记的名字,在使用<span class="attr">objectAnimator</span>的时候用来区分给哪个部分施加动画</span></span><br><span class="line"><span class="tag">            <span class="attr">android:pathData</span>=<span class="string">"m 0,0 L50,0 L100,100 L0,100 z"</span>    //这个是<span class="attr">SVG</span>的语法,下面讲</span></span><br><span class="line"><span class="tag">            <span class="attr">android:fillColor</span>=<span class="string">"@color/red"</span>  //定义填充图形的颜色，如果没有定义则不填充路径</span></span><br><span class="line"><span class="tag">            <span class="attr">android:fillAlpha</span>=<span class="string">"1"</span>       //定义填充图形的透明度，取值范围<span class="attr">0</span>到<span class="attr">1</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:strokeAlpha</span>=<span class="string">"0.5"</span>   //定义路径的透明度,取值范围<span class="attr">0</span>到<span class="attr">1</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:strokeColor</span>=<span class="string">"#ff0000ff"</span> //定义如何绘制路径，如果没有定义则不显示路径</span></span><br><span class="line"><span class="tag">            <span class="attr">android:strokeWidth</span>=<span class="string">"20"</span>    //线段的宽度</span></span><br><span class="line"><span class="tag">            <span class="attr">android:strokeLineCap</span>=<span class="string">"butt|round|square"</span>   //线的末端形状,<span class="attr">butt</span>严格到指定的坐标就截至,<span class="attr">round</span>是圆角,<span class="attr">square</span>是方形，到指定的坐标后还会再冒出一点来</span></span><br><span class="line"><span class="tag">            <span class="attr">android:strokeLineJoin</span>=<span class="string">"round|bevel|miter"</span>  //线的连接处形状,<span class="attr">round</span>是圆角的,<span class="attr">bevel</span>和<span class="attr">miter</span>貌似看不出来有什么区别<span class="attr">....</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:trimPathStart</span>=<span class="string">"0.5"</span>    //顾名思义,从<span class="attr">path</span>开始的地方(<span class="attr">0</span>%)去除<span class="attr">path</span>,去除到指定的百分比位置,取值范围<span class="attr">0</span>到<span class="attr">1</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:trimPathEnd</span>=<span class="string">"0.5"</span>      //顾名思义,从<span class="attr">path</span>结束的地方(<span class="attr">100</span>%的地方)去除<span class="attr">path</span>,去除到指定的百分比位置,取值范围<span class="attr">0</span>到<span class="attr">1</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:trimPathOffset</span>=<span class="string">"0.5"</span>   //这个属性是和上面两个属性共同使用的,单独使用没有用,这个属性的意思是,在去除<span class="attr">path</span>的时候设置<span class="attr">path</span>原点的位置,按百分比设置,取值范围<span class="attr">0</span>到<span class="attr">1</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面就来重点讲解path标签，path标签是用来创建SVG的，就像用指令控制一只画笔，path标签所支持的指令有以下几种。</p><h2 id="path-标签中的绘图指令"><a href="#path-标签中的绘图指令" class="headerlink" title="path 标签中的绘图指令"></a>path 标签中的绘图指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">M = moveto(M X, Y): 将画笔移动到指定的位置，但未发生绘制</span><br><span class="line">L = lineto(L X, Y): 画直线到指定位置</span><br><span class="line">H = horizontal(H X): 画水平线到指定X坐标</span><br><span class="line">V = vertical lineto(V Y): 画垂直线到指定Y坐标</span><br><span class="line">C = curveto(C X1,Y1,X1,Y2,ENDX,ENDY): 画三次贝塞尔曲线</span><br><span class="line">S = smooth curveto(S X2,Y2,ENDX,ENDY): 画三次贝塞尔曲线</span><br><span class="line">Q = quadratic Belzier curve(Q X,Y,ENDX,ENDY): 二次贝塞尔曲线</span><br><span class="line">T = smooth quadratic Belzier curveto(T ENDX,ENDY): 映射前面路径后的终点</span><br><span class="line">A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y): 画弧线</span><br><span class="line">Z = closepath(): 关闭路径，把前面的路径连起来</span><br></pre></td></tr></table></figure><p>在使用以上指令时，需要注意：</p><ol><li>坐标轴以（0，0）为中心，X轴水平向右，Y轴水平向下</li><li>所有指令大小写均可。大写绝对定位，参考全局坐标系；小写相对定位，参考父容器坐标系</li><li>指令和数据间的空格可以省略，可以用逗号隔开，也可以用空格</li><li>同一指令出现多次可以只用一个</li></ol><p>SVG的指令参数非常复杂，但是在android中，不需要太多太复杂的SVG图形，所以我们先来掌握几个常用的指令，在以后的学习中，读者将会慢慢掌握更多的SVG绘制技巧和方法。</p><h3 id="常用指令讲解"><a href="#常用指令讲解" class="headerlink" title="常用指令讲解"></a>常用指令讲解</h3><ul><li>M ：类似Android绘图中path类的moveTo方法，即将画笔移动到某一点但并没有发生绘制动作，下面配合L进行讲解</li></ul><hr><ul><li>L ：画一条直线</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">      <span class="attr">...</span>省略一些代码</span></span><br><span class="line"><span class="tag">      <span class="attr">android:pathData</span>=<span class="string">"M 20 50 L 80 50"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如图：</p><img src="/2019/07/12/SVG入门学习/svg1.png" title="svg1"><p> 上面表示把画笔放在（20,50）位置，连直线到80，50点 。</p><p>同时L后面还可以跟H或V指令来绘制水平、竖直线，后面的参数是x坐标（H指令）或y坐标（V指令）,如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>省略一些代码</span></span><br><span class="line"><span class="tag">        <span class="attr">android:pathData</span>=<span class="string">"M 20 50 L 80 50 V 80 H 20"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如图：</p><img src="/2019/07/12/SVG入门学习/svg2.png" title="svg2"><hr><ul><li>A ：绘制一段弧线，且弧线不允许闭合，可以把弧线想象成椭圆的某一段，A指令有以下7个参数：</li></ul><ol><li><p>RX，RY 指所在椭圆的半轴大小</p></li><li><p>XROTATION 指椭圆的X轴与水平方向的顺时针方向夹角，可以想象成一个水平的椭圆绕中心点顺时针旋转XRORATION的额角度</p></li><li><p>FLAG1 只有俩个值，1表示大角度弧线，0表示小角度弧线</p></li><li><p>FLAG2 只有俩个值，1为顺时针，0反之</p></li><li><p>X，Y 为终点坐标  </p></li></ol><p>看代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>省略一些代码</span></span><br><span class="line"><span class="tag">        <span class="attr">android:pathData</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        M 50 50</span></span></span><br><span class="line"><span class="tag"><span class="string">        a 30 15 0 1 0 1 0"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>再看图：</p><img src="/2019/07/12/SVG入门学习/svg3.png" title="svg3"><p> <strong>图一</strong> </p><p>上面表示把画笔放在（50,50）位置；30, 15分别表示椭圆的x，y半轴大小；0表示x轴不旋转；1表示用大角度弧线绘制；0表示顺时针：1，0表示相对与以（50，50）为起始点的坐标轴的坐标，因为a是小写。<br>再看一段代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">     <span class="attr">...</span>省略一些代码</span></span><br><span class="line"><span class="tag">     <span class="attr">android:pathData</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">     M 25 50</span></span></span><br><span class="line"><span class="tag"><span class="string">     a 25 25 0 1 0 50 0"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>再看图：</p><img src="/2019/07/12/SVG入门学习/svg4.png" title="svg4"><p> <strong>图二</strong> </p><p>可以看到这里显示了一个半圆，因为这里的X，Y轴大小相等 。 </p><p>再看一段代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">      <span class="attr">...</span>省略一些代码</span></span><br><span class="line"><span class="tag">      <span class="attr">android:pathData</span>=<span class="string">"M 25 50</span></span></span><br><span class="line"><span class="tag"><span class="string">      a 25 25 0 1 0 40 0"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>再看图：</p><img src="/2019/07/12/SVG入门学习/svg5.png" title="svg5"><p> <strong>图三</strong> </p><p>这里把终点x轴坐标改为40，图中显示了圆的大部分 。 </p><p>看一段代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>省略一些代码</span></span><br><span class="line"><span class="tag">       <span class="attr">android:pathData</span>=<span class="string">"M 25 50</span></span></span><br><span class="line"><span class="tag"><span class="string">       a 25 25 0 0 0 40 0"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>再看图：</p><img src="/2019/07/12/SVG入门学习/svg6.png" title="svg6"><p> <strong>图四</strong> </p><p>这里把FLAG1改为0，与图三相比，发现弧度变小了，因为用小弧度画。 </p><p>看一段代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">      <span class="attr">...</span>省略一些代码  </span></span><br><span class="line"><span class="tag">      <span class="attr">android:pathData</span>=<span class="string">"M 25 50</span></span></span><br><span class="line"><span class="tag"><span class="string">      a 25 25 0 0 1 40 0"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>再看图：</p><img src="/2019/07/12/SVG入门学习/svg7.png" title="svg7"><p><strong>图五</strong> </p><p>这里把FLAG2改为1，与图四相比，图形翻转了，因为画的方向不一样了 ,  把A指令的几个图结合看一下，就能弄懂A这个指令了。</p><hr><p>关于贝塞尔指令的，这里就不过多介绍了，放出几个链接供大家学习：<br><a href="http://www.cnblogs.com/jay-dong/archive/2012/09/26/2704188.html" target="_blank" rel="noopener">贝塞尔曲线初探</a><br><a href="https://github.com/OCNYang/Android-Animation-Set/wiki/SVG-讲解" target="_blank" rel="noopener">SVG讲解</a> </p><hr><h2 id="VectorDrawable和AnimatedVectorDrawable"><a href="#VectorDrawable和AnimatedVectorDrawable" class="headerlink" title="VectorDrawable和AnimatedVectorDrawable"></a>VectorDrawable和AnimatedVectorDrawable</h2><p>Coogle在Android5.0X中提供了俩个API来帮助支持SVG：</p><ul><li><p>VectorDrawable</p></li><li><p>AnimatedVectorDrawable</p><p>其中VectorDrawable用于创建XML文件的SVG图形，即前面的vector标签，并结合AnimatedVectorDrawable来完成动画效果。</p><h3 id="1、-VectorDrawable"><a href="#1、-VectorDrawable" class="headerlink" title="1、 VectorDrawable"></a>1、 VectorDrawable</h3><p>在XML中创建一个静态的XMLSVG图形，通常会形成如下的树形结构：</p></li></ul><img src="/2019/07/12/SVG入门学习/svg8.png" title="svg8"><p> <strong>树形结构</strong>  </p><p>path是树形结构中最小的单位，而通过Group可以将不同的path进行组合，接下来我们使用vector标签创建SVG图形，代码如下： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:width</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:height</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:viewportWidth</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:viewportHeight</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"line"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"path1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:strokeColor</span>=<span class="string">"@android:color/holo_green_dark"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:strokeWidth</span>=<span class="string">"5"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:strokeLineCap</span>=<span class="string">"round"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pathData</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">            M 20 20</span></span></span><br><span class="line"><span class="tag"><span class="string">            L 50 20 80 20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"path2"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:strokeLineCap</span>=<span class="string">"round"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:strokeWidth</span>=<span class="string">"5"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:strokeColor</span>=<span class="string">"@android:color/holo_green_dark"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pathData</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">            M 20 80</span></span></span><br><span class="line"><span class="tag"><span class="string">            L 50 80 80 80"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码画了俩条线，每条线由三个点控制，形成初始状态，下面立马通过AnimatedVectorDrawable来实现动画效果。</p><pre><code>源码文末给出</code></pre><h3 id="2、-AnimatedVectorDrawable"><a href="#2、-AnimatedVectorDrawable" class="headerlink" title="2、 AnimatedVectorDrawable"></a>2、 AnimatedVectorDrawable</h3><p>AnimatedVectorDrawable就是通过连接静态的VectorDrawable和动态的objectAninmator来为VectorDrawable提供动画效果，分几个步骤来使用：</p><ul><li>1、在XML中通过animated-vector标签来声明对AnimatedVectorDrawable的使用，并指定它的drawable属性，target标签中的name属性和animation属性 </li></ul><p>代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animated-vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:drawable</span>=<span class="string">"@drawable/svg_path"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:animation</span>=<span class="string">"@animator/anim_path1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"path1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:animation</span>=<span class="string">"@animator/anim_path2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"path2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-vector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>android:drawable=”@drawable/svg_path”指定了上面创建的VectorDrawable即画的俩条线；target标签中的name指定了要作用动画的path或Group的name, 即俩者的name要保持一致，这样系统才能找到要实现动画的元素;taret标签中的animation指定了要作用的都动画。</p><p>在本例中，path1的动画代码如下: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:propertyName</span>=<span class="string">"pathData"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueType</span>=<span class="string">"pathType"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueFrom</span>=</span></span><br><span class="line"><span class="tag">    "<span class="attr">M</span> <span class="attr">20</span> <span class="attr">20</span></span></span><br><span class="line"><span class="tag">     <span class="attr">L</span> <span class="attr">50</span> <span class="attr">20</span> <span class="attr">80</span> <span class="attr">20</span>"</span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueTo</span>=</span></span><br><span class="line"><span class="tag">    "<span class="attr">M</span> <span class="attr">20</span> <span class="attr">20</span></span></span><br><span class="line"><span class="tag">     <span class="attr">L</span> <span class="attr">50</span> <span class="attr">50</span> <span class="attr">80</span> <span class="attr">20</span>"</span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/bounce_interpolator"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectAnimator</span>&gt;</span></span><br></pre></td></tr></table></figure><p>path2的动画代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:propertyName</span>=<span class="string">"pathData"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueType</span>=<span class="string">"pathType"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueFrom</span>=</span></span><br><span class="line"><span class="tag">    "<span class="attr">M</span> <span class="attr">20</span> <span class="attr">80</span></span></span><br><span class="line"><span class="tag">     <span class="attr">L</span> <span class="attr">50</span> <span class="attr">80</span> <span class="attr">80</span> <span class="attr">80</span>"</span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueTo</span>=</span></span><br><span class="line"><span class="tag">    "<span class="attr">M</span> <span class="attr">20</span> <span class="attr">80</span></span></span><br><span class="line"><span class="tag">     <span class="attr">L</span> <span class="attr">50</span> <span class="attr">50</span> <span class="attr">80</span> <span class="attr">80</span>"</span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/bounce_interpolator"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectAnimator</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>以上的俩个动画代码中都定义了一个pathType的属性动画，并指定了变换的初始值分别为：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//path1</span><br><span class="line"> android:valueFrom=</span><br><span class="line">    "M 20 20</span><br><span class="line">     L 50 20 80 20"</span><br><span class="line">//path2</span><br><span class="line"> android:valueFrom=</span><br><span class="line">    "M 20 80</span><br><span class="line">     L 50 80 80 80"</span><br></pre></td></tr></table></figure></p><p>结束值为:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//path1</span><br><span class="line"> android:valueTo=</span><br><span class="line">    "M 20 20</span><br><span class="line">     L 50 50 80 20"</span><br><span class="line">//path2</span><br><span class="line">  android:valueTo=</span><br><span class="line">    "M 20 80</span><br><span class="line">     L 50 50 80 80"</span><br></pre></td></tr></table></figure></p><p>这里要注意的是，SVG的路径变换属性动画中，变换前后的节点数必须相同，这也是为什么前面需要使用三个点来绘制一条直线，因为后面需要中点进行动画变换 。</p><ul><li>2、把AnimatedVectorDrawable的XML文件设置给ImageView</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/iv_path"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:src</span>=<span class="string">"@drawable/svg_path_anim"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>3、代码中启动AnimatedVectorDrawable动画</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ImageView ivPath;</span><br><span class="line">...</span><br><span class="line">ivPath = findViewById(R.id.iv_path);</span><br><span class="line">       ivPath.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line">               Drawable drawable = ivPath.getDrawable();</span><br><span class="line">               if(drawable instanceof Animatable)&#123;</span><br><span class="line">                   ((Animatable)drawable).start();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>这样俩个path就实现了动画效果，如图：</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>了解了上面SVG知识，也就基本入门了，可以用SVG来实现简单的图标，当然现在也有一些工具来生成SVG图片，不用我们手动去写xml，但是了解它背后的实现也是很重要的，在以后的深入学习中，你会发现SVG结合动画会产生非常好看的动态效果。希望大家阅读完有所收获。</p><p><a href="https://github.com/rain9155/SVGTest" target="_blank" rel="noopener">本文相关源码</a></p><p>参考资料：</p><p>《Android群英传》</p><p><a href="http://www.w3school.com.cn/svg/index.asp" target="_blank" rel="noopener">SVG教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;SVG对于android开发者听起来是陌生的东西，因为它是属于前端的产物，其实Android中也是支持SVG的，语法也很简单易懂，本文就通过我自己学习的经历，和大家一起学习一下SVG。&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="svg" scheme="http://yoursite.com/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>Activity应用窗口的添加过程</title>
    <link href="http://yoursite.com/2019/07/10/Activity%E5%BA%94%E7%94%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/10/Activity应用窗口的添加过程/</id>
    <published>2019-07-10T07:20:32.000Z</published>
    <updated>2019-10-08T09:58:04.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一篇文章<a href="https://rain9155.github.io/2019/03/22/Window,%20WindowManager%E5%92%8CWindowManagerService%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" target="_blank" rel="noopener">Window, WindowManager和WindowManagerService之间的关系</a></li></ul><p>从上一篇文章中，我们了解到了Window的体系机制，也知道了window分为三种类型，分别是应用窗口(Application Window)、子窗口(Sub Window)、系统窗口(System Window），本文通过源码以Activity为例讲解一下应用窗口的添加过程，如果没看过上一篇文章建议先看，对于不同类型的窗口的添加，它们在WindowManager中的处理过程会有一点不一样，但是对于在WMS的处理过程中，基本上都是一样的。所以本文深入讲解一下Activity窗口的添加过程，知道了这个过程，对于其他类型的窗口添加也就能举一反三了。</p><a id="more"></a><pre><code>本文基于Android8.0, 相关源码位置如下:frameworks/base/core/java/android/view/*.java（*代表Window, WindowManager,         WindowManagerImpl，WindowManagerGlobal, ViewRootImpl）frameworks/base/core/java/android/app/*.java（*代表Activity，ActivityThread）            frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java    frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java    frameworks/base/services/core/java/com/android/server/wm/Session.java</code></pre><h2 id="Activity的Window创建-Activity-attach"><a href="#Activity的Window创建-Activity-attach" class="headerlink" title="Activity的Window创建 - Activity  :: attach()"></a>Activity的Window创建 - Activity  :: attach()</h2><p>熟悉Activity的启动流程的都知道(不熟悉的可以查看这篇文章<a href="https://blog.csdn.net/Rain_9155/article/details/89961912" target="_blank" rel="noopener">Activity的启动流程</a>)的Window的创建过程是在activity的attach方法中，它在调用Activity的onCreate方法前完成一些重要数据的初始化，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">            Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">            Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">            NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1、关注这里，创建PhoneWindow</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    <span class="comment">//下面都是设置window的一些属性，如回调、软键盘模式</span></span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//这个设置Window的Callback回调</span></span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2、关注这里，把Window与WindowManager进行关联</span></span><br><span class="line">     mWindow.setWindowManager(</span><br><span class="line">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">                mToken, mComponent.flattenToString(),</span><br><span class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//把WindowManager与Activity进行关联</span></span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在attach里。跟Window无关的我都省略掉了，我们看到attach方法里，在注释1中，首先new 了一个PhoneWindow赋值mWinow，mWindow是Window类型，它是一个抽象类，所以从这里可以看出Activity的Window的具体实现类是PhoneWindow，接下来，给mWindow设置回调，传入的参数是this，说明Activity实现了这些回调接口，这样当Window接收到外界的状态变化或输入事件时就会回调Activity的方法，其中我们比较熟悉的接口回调是Window的Callback接口，它里面有我们熟悉的回调方法如：dispatchTouchEvent()、onWindowFocusChanged()、onAttachedToWindow()和onDetachedFromWindow()。</p><p>接着我们来看注释2，这里通过Window的setWindowManager方法把WanagerManger与Window进行关联，然后通过Window的getWindowManager()把WanagerManger与Activity进行关联。</p><h2 id="Window与WanagerManager的关联-Window-setWindowManager"><a href="#Window与WanagerManager的关联-Window-setWindowManager" class="headerlink" title="Window与WanagerManager的关联 - Window :: setWindowManager()"></a>Window与WanagerManager的关联 - Window :: setWindowManager()</h2><p>我们知道Window的添加、更新和删除都是要通过WanagerManager的，接下来我们看看Window与WanagerManager是如何关联的，从上面知道该过程是在Window的setWindowManager方法中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Window.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName, <span class="keyword">boolean</span> hardwareAccelerated)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//token是Window的重要属性之一，是IBinder类型，它这里等于Activity中的mToken</span></span><br><span class="line">        mAppToken = appToken;</span><br><span class="line">        <span class="comment">//应用名</span></span><br><span class="line">        mAppName = appName;</span><br><span class="line">      <span class="comment">//是否硬件加速</span></span><br><span class="line">        mHardwareAccelerated = hardwareAccelerated</span><br><span class="line">                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//获得系统级服务WMS在本地进程的代理</span></span><br><span class="line">        <span class="keyword">if</span> (wm == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//1、关注这里，调用WindowManagerImpl的createLocalWindowManager方法，创建WindowManager</span></span><br><span class="line">        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在setWindowManager方法中，是有关window的一些属性的赋值，其中mAppToken是Activity中的token，它在Activity启动的过程中从AMS中传递过来的，这里你只要记住Activity应用窗口的token值是Activity中的token值，接下来如果wm为空就获取WMS并转成WindowManager赋值给wm，wm是WindowManager，它是一个接口，它的具体实现类是WindowManagerImpl，所以接下来的注释1中wm转成WindowManagerImpl，并调用WindowManagerImpl的createLocalWindowManager方法，我们来看看WindowManagerImpl的createLocalWindowManager方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WindowManagerImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowManagerImpl <span class="title">createLocalWindowManager</span><span class="params">(Window parentWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(mContext, parentWindow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">WindowManagerImpl</span><span class="params">(Context context, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mParentWindow = parentWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单，只是简单的返回一个WindowManagerImpl对象，注意它传入了一个parentWindow参数，它是Window类型，说明此时构建的WindowManagerImpl是与具体的Window关联的，至此，在java层上Window就已经与WindowManager建立起联系。 </p><h2 id="Activity的Window的视图创建-Window-setContentView"><a href="#Activity的Window的视图创建-Window-setContentView" class="headerlink" title="Activity的Window的视图创建 - Window :: setContentView()"></a>Activity的Window的视图创建 - Window :: setContentView()</h2><p>从上一篇文章我们知道，View是依附在Window上的，在Activity的启动过程中的attach方法里已经完成了Activity的Window的创建和与WindowManager的关联，那么Activity的视图即View是在哪里创建的呢？答案是在我们熟悉的setContentView方法中，我们先来看一张图：</p><img src="/2019/07/10/Activity应用窗口的添加过程/window1.png" title="window1"><p>如图所示每一个Activity都有一个顶级View叫做DecorView，一般情况下它会包含一个竖直方向的LinearLayout，在这个LinearLayout中包含两部分(具体情况与Android的版本与主题有关)，上面是标题栏，下面是内容布局，内容布局其实是一个FrameLayout，我们平时setContentView指定的布局其实是set到了这个FrameLayout中，所以这个方法叫setContentView也是也是很贴和实际的，因为FrameLayout的id就是android.R.id.content，理解了这些知识后，我们来看Activity中的setContentView方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、关注这里，其实调用的是PhoneWindow的setContentView，setContentView里面会加载内容布局并添加进DecorView中</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    <span class="comment">//如果Activity主题是带ActionBar的话，这里面就会创建ActionBar并添加进DecorView中</span></span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看注释1，前面已经讲过Activity的Window的创建，所以这里的getWindow其实返回的是Window，而Window的实现类是PhoneWindow，所以这里调用的是PhoneWindow的setContentView，并传入了我们的内容布局id，PhoneWindow的setContentView方法的相应源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PhoneWindow.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1，根据mContentParent是否为空做出不同动作，mContentParent就是上面所讲的id为android.R.id.content的布局，用来set我们id为layoutResID的内容布局</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1.1、mContentParent为空，创建DecorView，并加载mContentParent</span></span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="comment">//1.2、mContentParent不为空，并且没有转场动画，就把mContentParent中的View视图清空，下面会重新加载</span></span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、根据是否有转场动画，做出不同的动作</span></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="comment">//2.1、有转场动画，创建Scene完成转场动画</span></span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID， getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2.2、没有转场动画，直接把我们的layoutResID的布局加载进mContentParent</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">     mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        <span class="comment">//触发Activity的onContentChanged方法, 因为Activity实现了这些回调接口</span></span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释中可以看出这个方法如果忽略转场动画的处理的话，可以分为两部分，第一部分是注释1.1的DecorView的创建和加载mContentParent，第二部分是注释2.2的把我们的layoutResID的布局加载进mContentParent，其中重点是第一部分，下面我们来分析PhoneWindow的setContentView方法的第一部分。</p><h3 id="1、PhoneWindow-installDecor"><a href="#1、PhoneWindow-installDecor" class="headerlink" title="1、PhoneWindow :: installDecor()"></a>1、PhoneWindow :: installDecor()</h3><p>我们来看PhoneWindow的installDecor方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PhoneWindow.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1、根据mDecor是否为空，做出不同动作，mDecor就是DecorView，它是继承自FrameLayout</span></span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1.1、mDecor为空，就创建mDecor</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1.2、、mDecor不为空，不用重复创建，把Window设置给DecorView</span></span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//2、如果mContentParent为空，就加载mContentParent</span></span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>installDecor()有一百多行代码，但是重点就是上面几句，因为这里我们是第一次创建mDecor，所以mDecor就为空，那么上面就分为两部分，第一部分是注释1.1的创建mDecor，第二部分是注释2的加载加载mContentParent，我们先看installDecor方法的第一部分。</p><h4 id="1-1-PhoneWindow-generateDecor"><a href="#1-1-PhoneWindow-generateDecor" class="headerlink" title="1.1 PhoneWindow  :: generateDecor()"></a>1.1 PhoneWindow  :: generateDecor()</h4><p>PhoneWindow的generateDecor()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PhoneWindow.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1、关注这里，new了一个DecorView</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到generateDecor就是简单的创建了一个DecorView并返回，其中this是Window实例，DecorView的构造方法中会把Window设置给DecorView中的mWindow。我们看一下DecorView是什么，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DecorView.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> <span class="keyword">implements</span> <span class="title">RootViewSurfaceTaker</span>, <span class="title">WindowCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到DecorView就是一个FrameLayout。</p><p>我们回到installDecor方法中，接下来我们来看installDecor方法的第二部分。</p><h4 id="1-2-PhoneWindow-generateLayout-mDecor"><a href="#1-2-PhoneWindow-generateLayout-mDecor" class="headerlink" title="1.2  PhoneWindow  :: generateLayout(mDecor)"></a>1.2  PhoneWindow  :: generateLayout(mDecor)</h4><p>PhoneWindow的generateLayout()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PhoneWindow.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里获取到当前的Activity的主题theme的属性，下面忽略的，都是根据theme的属性设置Activity的Window</span></span><br><span class="line">    TypedArray a = getWindowStyle();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//这个layoutResource是一个布局id</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="comment">//获得theme的features</span></span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">    <span class="comment">//下面根据features获得不同的layoutResource</span></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">        setCloseOnSwipeEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_LEFT_ICON) | (<span class="number">1</span> &lt;&lt; FEATURE_RIGHT_ICON))) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                R.attr.dialogTitleIconsDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title_icons;</span><br><span class="line">        &#125;</span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_PROGRESS) | (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != <span class="number">0</span></span><br><span class="line">               &amp;&amp; (features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) == <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_progress;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_CUSTOM_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                R.attr.dialogCustomTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_custom_title;</span><br><span class="line">        &#125;</span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                R.attr.dialogTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) != <span class="number">0</span>) &#123;</span><br><span class="line">            layoutResource = a.getResourceId(</span><br><span class="line">                R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                R.layout.screen_action_bar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1、我们选取这个 R.layout.screen_simple 布局作为例子看一下</span></span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.startChanging();</span><br><span class="line">    <span class="comment">//2、将上面获取到的layoutResource对应的布局加载进DecorView中</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//3、因为layoutResource对应的布局已经加载进DecorView中了，所以这里可以通过findViewById获取android.R.id.content的布局</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mDecor.finishChanging();</span><br><span class="line"><span class="comment">//返回id为android.R.id.content的布局，赋值给mContentParent</span></span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>generateLayout()这个方法非常长，但是它里面的逻辑很简单，这个方法的主要作用是根据当前的Activity的theme的属性设置Activity的Window，并把根据features获取到的布局加载进传进来的DecorView，并从DecorView中获取android.R.id.content的布局返回给mContentParent，我们只要看懂注释<strong>1~3</strong>就清楚了。</p><p>首先我们看注释1，因为if…else…的语句非常多，所以我就选了最后一个else语句的layoutResource对应的布局文件讲解，它的位置在：<strong>/frameworks/base/core/res/res/layout/screen_simple.xml</strong>，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 还记得上面那张图吗，DecorView一般情况下它会包含一个竖直方向的LinearLayout --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ViewStub是一个按需加载的View，它在用到时才会加载，而且只能加载一次，这里它的layout指向的是一个ActionBar的布局文件，所以这里把ViewStub看作一个ActionBar就行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">"@+id/action_mode_bar_stub"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">"@+id/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">"@layout/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">"?attr/actionBarTheme"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个就是id为android.R.id.content得布局，用来放置我们平时setContentView时set得内存布局 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">"@android:id/content"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundInsidePadding</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundGravity</span>=<span class="string">"fill_horizontal|top"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foreground</span>=<span class="string">"?android:attr/windowContentOverlay"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>screen_simple.xml文件就是一个布局文件，大家把这个布局对应一下上面得那张图，就会有一种恍然大悟得感觉了，所以我们紧接着来看注释2，它就是把上面这个screen_simple.xml布局文件加载进DecorView中。</p><p>我们再看注释3，ID_ANDROID_CONTENT就是android.R.id.content的常量，看一下findViewById方法的源码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PhoneWindow.java  </span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends View&gt; <span class="function">T <span class="title">findViewById</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//getDecorView()就是获得到Window中的DecorView</span></span><br><span class="line">        <span class="keyword">return</span> getDecorView().findViewById(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到findViewById方法中获取到DecorView，然后调用DecorView的findViewById方法，因为在注释2中我们已经把layoutResource对应的布局加载进DecorView中了，所以这时就获取到android.R.id.content的布局。在generateLayout方法的最后，把android.R.id.content的布局返回给mContentParent。</p><p>我们再回到installDecor方法中，至此我们已经创建好<strong>DecorView</strong>，也通过DecorView获取到<strong>mContentParent, 即android.R.id.content的布局</strong>。</p><p>我们来分析PhoneWindow的setContentView方法的第二部分。</p><h3 id="2、mLayoutInflater-inflate-layoutResID-mContentParent"><a href="#2、mLayoutInflater-inflate-layoutResID-mContentParent" class="headerlink" title="2、mLayoutInflater.inflate(layoutResID, mContentParent)"></a>2、mLayoutInflater.inflate(layoutResID, mContentParent)</h3><p>layoutResID就是我们setContentView传进来的内容布局id，所以这里就把内容布局加载进mContentParent中了。至此Window的setContentView分析完毕。</p><p>这个过程如下图：</p><img src="/2019/07/10/Activity应用窗口的添加过程/window2.jpg" title="window2"><p>我们回到Activity的setContentView方法，其实到这里Activity的视图，也可以是说Activity的Window的视图DecorView就创建好了，接下来就是把这个DecorView显示到屏幕上。</p><h2 id="Activity的Window的视图添加-WindowManager-addView"><a href="#Activity的Window的视图添加-WindowManager-addView" class="headerlink" title="Activity的Window的视图添加  - WindowManager :: addView()"></a>Activity的Window的视图添加  - WindowManager :: addView()</h2><p>熟悉Activity的启动流程的都知道，Activity会在handleResumeActivity方法中把DecorView显示出来，而添加一个Winow是通过WindowManager的addView方法实现的，但是Window只是View的载体，并不是真实存在的，所以addView其实就是添加一个View，这个View是依附在Window上，并且这个View是 View Hierarchy 最顶端的根 View，而Activity的的顶级View是DecorView, 所以添加Activity的Window就是添加DecorView。我们来看一下handleResumeActivity方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,  <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ActivityClientRecord里面保存了Activity的信息</span></span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//这个方法里面最终会回调Activity的onResume方法</span></span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">    <span class="comment">//所以下面都是在执行onResume方法后的行为</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//得到Activity</span></span><br><span class="line">        <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//面if（r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible）&#123;&#125;分支里面的逻辑主要是把Activity的Window的DecorView添加到WMS中</span></span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//获取前面Activit创建的Window</span></span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">//获取前面Window创建的DecorView</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            <span class="comment">//先把DecorView设为不可见</span></span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">//Activity关联的WindowManager</span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            <span class="comment">//下面设置Window的布局参数</span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            <span class="comment">//窗口的类型是TYPE_BASE_APPLICATION，应用类型窗口</span></span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//1、关注这里，调用WindowManager的addView方法</span></span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//面if（r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible）&#123;&#125;分支里面的逻辑主要是把DecorView显示出来</span></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">            &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="comment">//2、关注这里，上面已经把Window添加到WMS中了，所以里面会把DecorView显示出来, 见下面Activity.java</span></span><br><span class="line">                r.activity.makeVisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="comment">//把DecorView设为可见</span></span><br><span class="line">   mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的注释已经写的很清楚了，重点就是一句话：<strong>获取Activity的Window中的DecorView并调用WindowManager的addView方法添加DecorView，然后把DecorView设置为可见</strong>。到这里视图的添加已经转移到WindowManager中，阅读过上一篇文章的知道，WindowManager的实现类是WindowManagerImp，WindowManagerImp会把大部分操作转发给WindowManagerGlobal。</p><h3 id="1、WindowManagerGlobal-addView"><a href="#1、WindowManagerGlobal-addView" class="headerlink" title="1、WindowManagerGlobal :: addView()"></a>1、WindowManagerGlobal :: addView()</h3><p>所以我们直接看方法WindowManagerGlobal的addView()就行，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WindowManagerGlobal.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">//获取Window的LayoutParams</span></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">//这里的parentWindow不为空，因为从上面的Window与WanagerManager的关联可知，会调用createLocalWindowManager(this)来创建一个WanagerManagerImpl，这个this代表的PhoneWindow实例会传进WanagerManagerImpl构造中赋值给mParentWindow</span></span><br><span class="line">    <span class="comment">//1、调整窗口布局参数</span></span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果有设置父窗口，会通过adjustLayoutParamsForSubWindow()来调整params</span></span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//2、构建ViewRootimpl</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        <span class="comment">//3、把View、ViewRootimpl、LayoutParams保存</span></span><br><span class="line">        <span class="comment">//把上面调整好的params设置给待添加的View</span></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        <span class="comment">//把待添加的View添加到View列表中</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        <span class="comment">//把ViewRootimpl对象root添加到ViewRootimpl列表中</span></span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        <span class="comment">//把params添加到params列表中</span></span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//4、调用ViewRootImpl的setView将View显示到手机窗口上</span></span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法主要分为4个部分，我们先来看WindowManagerGlobal的addView传进来的4个参数，其中view、params和display三者是必不可少的，view就代表待添加的View，这里是DecorView，params就代表窗口布局参数，diaplay代表的是表示要输出的显示设备，而parentWindow表示父窗口，这里的父窗口并不一定是真正意义上的父窗口，有可能就是描述一个窗口的对象本身。在上述分析Activity的 WindowManager创建时就提到parentWindow就是PhoneWindow本身。</p><h4 id="1-1、adjustLayoutParamsForSubWindow-wparams"><a href="#1-1、adjustLayoutParamsForSubWindow-wparams" class="headerlink" title="1.1、adjustLayoutParamsForSubWindow(wparams)"></a>1.1、adjustLayoutParamsForSubWindow(wparams)</h4><p>接下来我们来看这个方法，这个方法被分为4部分，其中第一部分是注释1，重点是Window的adjustLayoutParamsForSubWindow方法，用来调整params，该方法主要源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Window.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustLayoutParamsForSubWindow</span><span class="params">(WindowManager.LayoutParams wp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;<span class="comment">//如果它是子窗口</span></span><br><span class="line">        <span class="keyword">if</span> (wp.token == <span class="keyword">null</span>) &#123;</span><br><span class="line">            View decor = peekDecorView();</span><br><span class="line">            <span class="keyword">if</span> (decor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//可以看到子窗口的token为顶级View的WindowToken</span></span><br><span class="line">                wp.token = decor.getWindowToken();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wp.type &gt;= WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW &amp;&amp; wp.type &lt;= WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123;<span class="comment">//如果它是系统窗口</span></span><br><span class="line">        <span class="comment">//系统窗口没有为token赋值，因为系统窗口的生命周期不依赖于app，当app退出了，系统窗口不会受到影响，它还是能显示和接收外界的输入事件</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果它是应用窗口</span></span><br><span class="line">        <span class="keyword">if</span> (wp.token == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//可以看到应用窗口的token为Activity的mAppToken</span></span><br><span class="line">            wp.token = mContainer == <span class="keyword">null</span> ? mAppToken : mContainer.mAppToken;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是为Window的token赋值，如果是应用窗口且wp.token==null，就会给它赋值mAppToken，而这个mAppToken就是我们上面在Activity的attach()方法中传入的mToken，而系统窗口的token为null，原因注释中说了，我们再分析子窗口的token，接上面的decor.getWindowToken()，该方法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">getWindowToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mAttachInfo != <span class="keyword">null</span> ? mAttachInfo.mWindowToken : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到子窗口的token就是View中mAttachInfo的mWindowToken，那么mAttachInfo是什么？它在哪里被赋值？我们先留一个疑问。</p><h4 id="1-2、创建ViewRootImpl"><a href="#1-2、创建ViewRootImpl" class="headerlink" title="1.2、创建ViewRootImpl"></a>1.2、创建ViewRootImpl</h4><p>我们回到addView()方法继续看注释2，注释2构建了一个ViewRootimpl，WindowManagerGlobal会为每一个待添加的View创建一个ViewRootImpl，我们看ViewRootImpl的构造方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    <span class="comment">//1、记住这个mWindowSession，待会用到</span></span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">    mDisplay = display;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2、创建了一个W对象，继承自IWindow.Stub，是一个IBinder类型，用来接收WMS的通知</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//3、创建了一个mAttachInfo，这个mAttachInfo就是上面View中mAttachInfo，它在这里被创建，见下面View.AttachInfo的构造方法</span></span><br><span class="line">    mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>,</span><br><span class="line">                                      context);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//View.java</span></span><br><span class="line"> AttachInfo(IWindowSession session, IWindow window, Display display,  ViewRootImpl viewRootImpl, Handler handler, Callbacks effectPlayer) &#123;</span><br><span class="line">     mSession = session;</span><br><span class="line">     mWindow = window;</span><br><span class="line">     <span class="comment">//mWindowToken本质就是ViewRootImpl中的W类，只是调用asBinder转化了一下</span></span><br><span class="line">     mWindowToken = window.asBinder();</span><br><span class="line">     mDisplay = display;</span><br><span class="line">     mViewRootImpl = viewRootImpl;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ViewRootImpl的构造方法中，关键的就是上面三个注释，注释1下面会解释，注释2创建了一个W类对象，它是一个IBinder类型，它在后面会通过Binder IPC传送到WMS中，WMS就是通过这个W类对象和Activity所在进程交互，注释3创建了一个AttachInfo类对象，ViewRootImpl为每一个待添加的View创建一个AttachInfo类对象mAttachInfo，当这个待添加的View与ViewRootImpl建立联系(mView被赋值)后，ViewRootImpl就会调用performTraversal()方法遍历这颗View Hierarchy 把其mAttachInfo赋值给这颗View Hierarchy 中的每一个View的mAttachInfo，所以上面的<strong>decor.getWindowToken()</strong>中的mAttachInfo就不为空，这样子窗口的token就是mAttachInfo中的mWindowToken，从AttachInfo构造可以看出，传入的W类通过asBinder转化了一下赋值给mWindowToken，所以现在可以得出结论：<strong>子窗口的token就是ViewRootImpl中的W类</strong>。</p><h4 id="1-3、-把View、ViewRootimpl、LayoutParams保存到列表"><a href="#1-3、-把View、ViewRootimpl、LayoutParams保存到列表" class="headerlink" title="1.3、 把View、ViewRootimpl、LayoutParams保存到列表"></a>1.3、 把View、ViewRootimpl、LayoutParams保存到列表</h4><p>我们回到addView()方法继续看注释3，第三部分就是把待添加的View、新创建ViewRootimpl、待添加的View的LayoutParams分别保存到3个列表，这三个列表在WindowManagerGlobal中，这三个列表的含义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WindowManagerGlobal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerGlobal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();<span class="comment">//mViews存储的是所有Window所对应的顶级View（即View Hierarchy最顶端的View）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();<span class="comment">//mRoots存储着所有Window所对应的ViewRootImpl</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams = <span class="keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();<span class="comment">//mParams存储着所有Window所对应的布局参数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4、通过ViewRootImpl-的setView-方法把DecorView显示到窗口上"><a href="#1-4、通过ViewRootImpl-的setView-方法把DecorView显示到窗口上" class="headerlink" title="1.4、通过ViewRootImpl 的setView()方法把DecorView显示到窗口上"></a>1.4、通过ViewRootImpl 的setView()方法把DecorView显示到窗口上</h4><p>我们回到addView()方法继续看注释4，注释4就是调用ViewRootImpl的setView方法，它里面会请求View Hierarchy的绘制，并请求WMS显示待添加的View，我们看一下该方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//ViewRootImpl与待添加的View建立联系</span></span><br><span class="line">            mView = view;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//接收WMS添加后的返回结果</span></span><br><span class="line">           <span class="keyword">int</span> res；</span><br><span class="line">            <span class="comment">//1、请求绘制View Hierarchy</span></span><br><span class="line">           requestLayout();</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    <span class="comment">//2、向通过mWindowSession向WMS发起显示当前Window的请求</span></span><br><span class="line">                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                 <span class="comment">//...</span></span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">//下面这些异常都是由于添加Window错误而抛出</span></span><br><span class="line">            <span class="keyword">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">                        <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN:</span><br><span class="line">                        <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                                    <span class="string">"Unable to add window -- token "</span> + attrs.token</span><br><span class="line">                                    + <span class="string">" is not valid; is your activity running?"</span>);</span><br><span class="line">                        <span class="keyword">case</span> WindowManagerGlobal.ADD_NOT_APP_TOKEN:</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                                    <span class="string">"Unable to add window -- token "</span> + attrs.token</span><br><span class="line">                                    + <span class="string">" is not for an application"</span>);</span><br><span class="line">                      <span class="comment">//...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setView方法中，我们先看注释1，在向WMS发起将View显示到手机窗口上前，先调用requestLayout绘制整颗View Hierarchy，这个方法里面会通过Choreographer的postCallback方法注册对应的绘制回调(CALLBACK_TRAVERSAL)，等待vsync信号，然后会触发整个View树的绘制操作，也就是performTraversal()方法的执行。我们来看注释2，到这里Activity的Window的添加就交给了mWindowSession，它是一个IWindowSession类型，IWindowSession是一个AIDL接口文件，需要编译后才生成IWindowSession.java接口，mWindowSession是在上面的ViewRootImpl的构造中被赋值的：<strong>mWindowSession = WindowManagerGlobal.getWindowSession();</strong>，关于这部分的已经在上一篇文章讲解过了，所以注释2其实最终调用的Session的addToDisplay()方法，在addToDisplay()中返回了WMS的addWindow()的返回结果,所以从这里开始<strong>添加Window的过程转移到WMS进程</strong>中去。</p><h3 id="2、WMS-addWindow"><a href="#2、WMS-addWindow" class="headerlink" title="2、WMS :: addWindow()"></a>2、WMS :: addWindow()</h3><p>我们就简单的过一遍WMS的addWindow()方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">            WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">                     InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span>[] appOp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//如果窗口时系统窗口，还要进行权限检查</span></span><br><span class="line">    <span class="keyword">int</span> res = mPolicy.checkAddPermission(attrs, appOp);</span><br><span class="line">    <span class="keyword">if</span> (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> type = attrs.type;</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        <span class="comment">//省略的是检查Display显示信息,</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//如果是子窗口</span></span><br><span class="line">        <span class="keyword">if</span> (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">            <span class="comment">//通过windowForClientLocked()方法还要检查其父窗口是否存在</span></span><br><span class="line">            parentWindow = windowForClientLocked(<span class="keyword">null</span>, attrs.token, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//如果父窗口不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (parentWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果父窗口还是子窗口，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW</span><br><span class="line">                &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="comment">//检查token</span></span><br><span class="line">        AppWindowToken atoken = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">////是否有父窗口</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasParent = parentWindow != <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果它有父窗口，就使用父窗口的token，如果没有，就是使用自己的token</span></span><br><span class="line">        WindowToken token = displayContent.getWindowToken(</span><br><span class="line">            hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        <span class="comment">//如果它有父窗口，就使用父窗口的type，如果没有，就是使用自己的type  </span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> rootType = hasParent ? parentWindow.mAttrs.type : type;</span><br><span class="line">         <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;<span class="comment">//如果是应用窗口，但是它的token为空，返回错误</span></span><br><span class="line">                 <span class="comment">//...</span></span><br><span class="line">                 <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;<span class="comment">//如果是应用窗口，但是它的token不是mAppToken（mApptoken是从AMS传过来的），返回错误</span></span><br><span class="line">                atoken = token.asAppWindowToken();</span><br><span class="line">                <span class="keyword">if</span> (atoken == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//...</span></span><br><span class="line">                  <span class="keyword">return</span> WindowManagerGlobal.ADD_NOT_APP_TOKEN;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (atoken.removed) &#123;</span><br><span class="line">                   <span class="comment">//...</span></span><br><span class="line">                   <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//这里省略的是，一些系统窗口的token 不能为空，并且通过token检索到的WindowToken的类型不能是其本身对应的类型</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token.asAppWindowToken() != <span class="keyword">null</span>) &#123; <span class="comment">//某些系统窗口的token应该为空，但是却不为空，所以这里把token清空</span></span><br><span class="line">                attrs.token = <span class="keyword">null</span>;</span><br><span class="line">                token = <span class="keyword">new</span> WindowToken(<span class="keyword">this</span>, client.asBinder(), type, <span class="keyword">false</span>, displayContent,</span><br><span class="line">                        session.mCanAddInternalSystemWindow);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//经过一系列的检查后，会创建一个WindowState</span></span><br><span class="line">        <span class="keyword">final</span> WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token, parentWindow,</span><br><span class="line">                    appOp[<span class="number">0</span>], seq, attrs, viewVisibility, session.mUid,</span><br><span class="line">                    session.mCanAddInternalSystemWindow);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//走到这里证明没有任何错误发生，res = ADD_OKAY</span></span><br><span class="line">        res = WindowManagerGlobal.ADD_OKAY;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//WindowState的attach方法创建了一个SurfaceSession对象用于与SurfaceFlinger服务通信</span></span><br><span class="line">        win.attach();</span><br><span class="line">        <span class="comment">//client就是Activity进程那边传过来的ViewRootImpl中的W类，这里用asBinder转化了一下，所以这里以W类为Key，WindowState为Value建立映射存放进mWindowMap中，它是一个WindowHashMap类型</span></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很长，但是里面的逻辑还是很有规律，建议对照着注释跟源码看一遍，这里总结一下这个方法的过程：</p><ul><li>1、首先如果是系统窗口要进行权限检查，mPolicy是一个PolicyWindowManager类型，如果想知道哪些系统窗口是需要权限的可以查看这个PolicyWindowManager的checkAddPermission()方法，这个方法检查如果不是系统类型的窗口就会返回一个ADD_OKAY表示检查通过，否则表示检查不通过，代表着这个系统窗口没有在Manifest.xml文件中声明权限。</li><li>2、如果是子窗口类型，就通过windowForClientLocked()方法还要检查其父窗口是否存在，子窗口一定要有父窗口。</li><li>3、根据类型type检查token是否有效，应用窗口和子窗口的token是一定要赋值的，否则创建窗口会抛异常，且应用窗口中的token必须是某个有效的 Activity 的 mToken。而子窗口中的token必须是父窗口的 ViewRootImpl 中的 W 对象。对于部分系统窗口其token也要赋值，有些系统窗口的token不需要赋值。这个token赋值规则可以对照上面的adjustLayoutParamsForSubWindow(wparams)的方法解说。</li><li>4、通过WindowState的attach方法，WMS把渲染Window视图的任务交给了SurfaceFlinger。</li><li>5、一系列的检查后，WMS会为每一个Window会创建一个WindowState，并以传过来的W类为Key，新创建的WindowState为Value建立映射存放进WindowHashMap中，这个WindowState维护着窗口的状态以及根据适当的机制来调整窗口的状态。</li></ul><p>这个添加过程如下图：</p><img src="/2019/07/10/Activity应用窗口的添加过程/window3.jpg" title="window3"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是Activity的Window的添加过程，我们发现添加一个Window最重要的是View、type和token，至于其他类型窗口的添加相似的，一图总结本文，如下：</p><img src="/2019/07/10/Activity应用窗口的添加过程/window4.png" title="window4"><p>从图中可以看到，添加一个Window，会涉及到两个进程的交互，一个是Activity所在的应用进程，一个是WMS所在的系统服务进程，所以绿色的那部分就代表着IPC，ViewRootImpl通过WindonManagerGlobal的静态变量sWindowSession负责与WMS通信，它是Session类型，在ViewRootImpl构造中被赋值，WMS中的每个Window的WindowState的mClient负责与Activity所在的应用进程通信，它是W类型，在创建WindowState构造中被赋值，在Activity所在的应用进程的WindonManagerGlobal中会为每一个添加的Window中的View创建一个ViewRootImpl，所以多个Window就对应多个ViewRootImpl，而在WMS中，Window对应着一个View，它会为每一个Window创建一个WindowState以维护Window的状态，所以多个Window就多个WindowState。</p><p>从应用窗口的添加过程中，对Window的机制也有了一些了解，以后如果遇到有关于Window的添加的异常也懂得去哪里找原因。</p><p>参考资料：</p><p><a href="https://blog.csdn.net/qian520ao/article/details/78555397#viewrootimpl" target="_blank" rel="noopener">Android Window 机制探索</a></p><p><a href="https://mp.weixin.qq.com/s/jhTIMQ_yu5DXM7Vz8OQwGg" target="_blank" rel="noopener">浅析 Android 的窗口</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一篇文章&lt;a href=&quot;https://rain9155.github.io/2019/03/22/Window,%20WindowManager%E5%92%8CWindowManagerService%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Window, WindowManager和WindowManagerService之间的关系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上一篇文章中，我们了解到了Window的体系机制，也知道了window分为三种类型，分别是应用窗口(Application Window)、子窗口(Sub Window)、系统窗口(System Window），本文通过源码以Activity为例讲解一下应用窗口的添加过程，如果没看过上一篇文章建议先看，对于不同类型的窗口的添加，它们在WindowManager中的处理过程会有一点不一样，但是对于在WMS的处理过程中，基本上都是一样的。所以本文深入讲解一下Activity窗口的添加过程，知道了这个过程，对于其他类型的窗口添加也就能举一反三了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Window机制" scheme="http://yoursite.com/categories/Window%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="window" scheme="http://yoursite.com/tags/window/"/>
    
      <category term="windowManager" scheme="http://yoursite.com/tags/windowManager/"/>
    
      <category term="WMS" scheme="http://yoursite.com/tags/WMS/"/>
    
      <category term="activity" scheme="http://yoursite.com/tags/activity/"/>
    
  </entry>
  
  <entry>
    <title>Activity的启动流程（2）</title>
    <link href="http://yoursite.com/2019/05/19/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/05/19/Activity的启动流程（2）/</id>
    <published>2019-05-19T08:12:34.000Z</published>
    <updated>2019-08-06T05:49:59.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一篇文章<a href="https://rain9155.github.io/2019/05/19/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89/" target="_blank" rel="noopener">Activity的启动流程（1）</a></li></ul><p>上一篇文章讲了应用进程请求AMS启动Activity过程和Activity在AMS中的启动过程，然后Activity启动的代码逻辑就从AMS所在进程，又重新回到了应用进程所在的ApplicationThread中。我们还留下了一个问题，<strong>Activity的生命周期方法是如何被回调的？</strong>，下面我们就带着这个疑问，去走一遍源码，看一下在应用进程中ApplicationThread启动Activity的过程。</p><a id="more"></a><pre><code>本文基于android8.0，本文相关源码文件位置如下：frameworks/base/core/java/android/app/Activity.javaframeworks/base/core/java/android/app/ActivityThread.javaframeworks/base/core/java/android/app/Instrumentation.java</code></pre><h2 id="ApplicationThread-scheduleLaunchActivity"><a href="#ApplicationThread-scheduleLaunchActivity" class="headerlink" title="ApplicationThread::scheduleLaunchActivity()"></a>ApplicationThread::scheduleLaunchActivity()</h2><p>上文结尾讲到在ActivityStackSupervisor的realStartActivityLocked()中调用了ApplicationThread中的scheduleLaunchActivity方法，这里是Activity启动的开始。ApplicationThread是ActivityThread的内部类，实现了IApplicationThread.stub接口。ActivityThread代表应用程序进程的主线程，它管理着当前应用程序进程的线程。</p><p>我们来看一下scheduleLaunchActivity的相关源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread::ApplicationThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">       ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">            r.token = token;</span><br><span class="line">            r.ident = ident;</span><br><span class="line">            r.intent = intent;</span><br><span class="line">            r.referrer = referrer;</span><br><span class="line">            r.voiceInteractor = voiceInteractor;</span><br><span class="line">            r.activityInfo = info;</span><br><span class="line">            r.compatInfo = compatInfo;</span><br><span class="line">            r.state = state;</span><br><span class="line">            r.persistentState = persistentState;</span><br><span class="line"></span><br><span class="line">            r.pendingResults = pendingResults;</span><br><span class="line">            r.pendingIntents = pendingNewIntents;</span><br><span class="line"></span><br><span class="line">            r.startsNotResumed = notResumed;</span><br><span class="line">            r.isForward = isForward;</span><br><span class="line"></span><br><span class="line">            r.profilerInfo = profilerInfo;</span><br><span class="line"></span><br><span class="line">            r.overrideConfig = overrideConfig;</span><br><span class="line">            updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">            sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述方法中只是简单的把从AMS传过来的有关启动Activity的参数，封装成ActivityClientRecord，然后调用sendMessage向H发送LAUNCH_ACTIVITY的消息，并且将ActivityClientRecord作为参数传了过去，H是ActivityThread中的内部类，是Handler类型，有关Activity的启动消息都交给这个Handler处理，为什么这里要进行切换到主线程处理消息呢？因为此时这里还运行在Binder的线程池中，不能进行Activity的启动，所以要切换到主线程中才能进行Activity的生命周期的方法回调。</p><p>下面我们来看看sendMessage方法。</p><h3 id="1、ApplicationThread-sendMessage"><a href="#1、ApplicationThread-sendMessage" class="headerlink" title="1、ApplicationThread::sendMessage()"></a>1、ApplicationThread::sendMessage()</h3><p>该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread::ApplicationThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">        sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = what;</span><br><span class="line">        msg.obj = obj;</span><br><span class="line">        msg.arg1 = arg1;</span><br><span class="line">        msg.arg2 = arg2;</span><br><span class="line">        <span class="keyword">if</span> (async) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到，sendMessage方法中将H.LAUNCH_ACTIVITY与ActivityClientRecord封装成一个Message，然后调用mH的sendMessage方法，mH就是H的实例，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br></pre></td></tr></table></figure><p>熟悉android消息机制的都知道(不了解的，可以看这一篇文章<a href="https://rain9155.github.io/2019/02/21/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/" target="_blank" rel="noopener">Android消息机制java层</a>)，Handler发送消息后，都会统一到handlerMessage方法中处理。</p><p>我们来看一下Handler H对消息的处理。</p><h3 id="2、H-handleMessage（）"><a href="#2、H-handleMessage（）" class="headerlink" title="2、H::handleMessage（）"></a>2、H::handleMessage（）</h3><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAUNCH_ACTIVITY         = <span class="number">100</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAUSE_ACTIVITY          = <span class="number">101</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESUME_ACTIVITY         = <span class="number">107</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DESTROY_ACTIVITY        = <span class="number">109</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIND_APPLICATION        = <span class="number">110</span>;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                    <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">                    r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                    handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>H中有很多关于四大组件的消息处理的字段，如Activity的启动，这里我们只关心前面发送过来的LAUNCH_ACTIVITY字段的消息处理，可以看到这里首先把msg中的obj字段转换为ActivityClientRecord，然后为ActivityClientRecord的packageInfo赋值，packageInfo是LoadedApk类型，它表示已加载的APK文件，接下来调用了外部类ActivityThread的handleLaunchActivity方法。</p><p>接下来我们来看一下ActivityThread的handleLaunchActivity方法。</p><h2 id="ActivityThread-handleLaunchActivity（）"><a href="#ActivityThread-handleLaunchActivity（）" class="headerlink" title="ActivityThread::handleLaunchActivity（）"></a>ActivityThread::handleLaunchActivity（）</h2><p>该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//最终回调Activity的onConfigurationChanged方法</span></span><br><span class="line">    handleConfigurationChanged(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//这里面获取WindowManager系统服务的本地代理</span></span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">    <span class="comment">//1、关注这里，启动Activity，调用了ActivityThread的performLaunchActivity方法，会最终回调Activity的onCreate，onStart方法</span></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//2、关注这里，调用了ActivityThread的handleResumeActivity方法，会最终回调Activity的onResume方法</span></span><br><span class="line">         handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果出错了，这里会告诉AMS停止启动Activity  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                                Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文的重点是Activity的生命周期如何被回调，所以上面我们只需要关注注释1、2。注释1中调用了ActivityThread的performLaunchActivity方法，该方法最终完成了Activity对象的创建和启动过程，如果启动出错就会通知AMS停止启动Activity，并且在注释2中ActivityThread通过handleResumeActivity将被启动的Activity置为Resume状态。</p><p>我们首先看注释1的performLaunchActivity方法。</p><h3 id="1、ActivityThread-performLaunchActivity"><a href="#1、ActivityThread-performLaunchActivity" class="headerlink" title="1、ActivityThread::performLaunchActivity()"></a>1、ActivityThread::performLaunchActivity()</h3><p>该方法相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从ActivityClientRecord中获取ActivityInfo。</span></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="comment">//获取packageInfo，packageInfo是前面讲到的LoadedApk类型</span></span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                                       Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取ComponentName</span></span><br><span class="line">     ComponentName component = r.intent.getComponent();</span><br><span class="line">        <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">            component = r.intent.resolveActivity(</span><br><span class="line">                mInitialApplication.getPackageManager());</span><br><span class="line">            r.intent.setComponent(component);</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                    r.activityInfo.targetActivity);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//创建要启动Activity的上下文环境</span></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    <span class="comment">//构造Activity对象，并设置参数</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//获取类加载器</span></span><br><span class="line">            java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">         <span class="comment">//通过Instrumentation，用类加载创建该Activity实例</span></span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            <span class="comment">//设置相关参数准备初始化Activity</span></span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">//初始化Activity失败</span></span><br><span class="line">          <span class="comment">//....</span></span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//创建Application</span></span><br><span class="line">         Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">         <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//构造Configuration对象</span></span><br><span class="line">              Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">             <span class="comment">//...</span></span><br><span class="line">             <span class="comment">//把该Activity和ContextImpl关联</span></span><br><span class="line">             appContext.setOuterContext(activity);</span><br><span class="line">             <span class="comment">//通过attach方法将上述创建的信息保持到Activity内部，用来完成对Activity的初始化，如ContextImpl，Application，Configuration</span></span><br><span class="line">             activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">             <span class="comment">//...</span></span><br><span class="line">             <span class="comment">//获取Activity的主题并设置</span></span><br><span class="line">             <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">             <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                    activity.setTheme(theme);</span><br><span class="line">             &#125;</span><br><span class="line">              activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">//1、根据是否需要持久化，调用Instrumentation的callActivityOnCreate方法通知Activity已经被创建，里面最终会调用Activity的onCreate方法</span></span><br><span class="line">              <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//关注这里，走这个分支</span></span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                   <span class="comment">//...</span></span><br><span class="line">                  <span class="comment">//无法调用Activity的onCreate方法，抛出异常</span></span><br><span class="line">                &#125;</span><br><span class="line">              r.activity = activity;</span><br><span class="line">              r.stopped = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                  <span class="comment">//2、里面最终会调用Activity的onStart方法</span></span><br><span class="line">                  activity.performStart();</span><br><span class="line">                  r.stopped = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                    <span class="comment">//根据是否需要持久化，调用Instrumentation的callActivityOnRestoreInstanceState方法通知Activity已经被创建，里面最终会调用Activity的onRestoreInstanceState方法</span></span><br><span class="line">                    <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                    r.persistentState);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             <span class="comment">//...</span></span><br><span class="line">         &#125;</span><br><span class="line">          r.paused = <span class="keyword">true</span>;</span><br><span class="line">         <span class="comment">//把ActivityClientRecord缓存起来，以便在以后使用。mActivities的定义：ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new ArrayMap&lt;&gt;();</span></span><br><span class="line"> mActivities.put(r.token, r);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="comment">//抛异常，无法启动Activity</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的主要代码都贴出来了，并做了注释，它主要做了以下事情：</p><ul><li>1、从ActivityClientRecord中获取待启动的Activity的组件信息，如ActivityInfo，ComponentName。</li></ul><p>ActivityInfo类用于存储代码中AndroidManifes设置的activity节点信息，ComponentName类中保存了该Activity的包名和类名</p><ul><li>2、通过createBaseContextForActivity方法创建要启动Activity的上下文环境ContextImp，并在下面作为参数传进attach方法中。</li></ul><p>ContextImp是Context的具体实现，Context中的大部分逻辑都是交给ContextImpl来完成，Context中定义了许多与四大组件启动、系统级服务获取、类加载、资源获取等有密切关系的方法，而Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，ContextWrapper继承自Context，ContextWrapper内部有一个Context类型的mBase引用，而在Activity的attach方法中会调用attachBaseContext方法把该ContextImp赋值给mBase，所以Activity是ContextImpl的包装类，Activity扩展了Context中的方法。（这里就是一个<a href="https://blog.csdn.net/Rain_9155/article/details/89250729" target="_blank" rel="noopener">装饰者模式</a>）</p><ul><li>3、通过LoadedApk的makeApplication方法创建Application。</li></ul><p>makeApplication方法里面最终是通过Instrumentation的newApplication方法用类加载器创建Application，如果Application已经被创建过了，那么就不会重复创建，如果创建成功，会紧接着通过Instrumentation的callApplicationOnCreate来调用Application的onCreate方法。</p><ul><li>4、通过Instrumentation的newActivity方法用类加载器创建Activity对象。</li></ul><p>Instrumentation是一个用来监控应用程序与系统交互的类，通过它可以创建Activity、Applicationd实例，还与Activity生命周期的回调有关，所以在下文看到mInstrumentation.callActivityOnXX, 一般都是要回调某个Activity的生命周期方法。</p><ul><li>5、通过Activity的attach方法来完成一些重要数据的初始化，如ContextImpl，Application，Configuration等。</li></ul><p>在attach方法中会创建Window对象（PhoneWindow）并与Activity自身进行关联，这样当Window接收到外部的输入事件后就可以将事件传递给Activity。第2点讲过，还会把ContextImpl与Activity关联。</p><ul><li>6、调用Instrumentation的callActivityOnCreate方法，里面最终会调用Activity的onCreate方法。</li></ul><p>这里就是重点关注的注释1，注释还写到这里会根据是否需要持久化来调用不同参数的mInstrumentation的callActivityOnCreate方法，这个持久化是什么？其实这是在API 21后，Activity新增的一个”<strong>persistableMode</strong>“属性，在AndroidManifest.xml的activity节点将他它设为<strong>android:persistableMode=”persistAcrossReboots</strong>，Activity就有了持久化的能力，这时候我们可以数据保存在<strong>outPersistentState</strong>（Bundle类型），那么即使是关机，仍然可以恢复这些数据。关于PersistableMode更多信息可以看这篇文章<a href="https://www.rainng.com/android-persistablemode/" target="_blank" rel="noopener">PersistableMode使Activity数据持久化保存</a>，这不是本文的重点。</p><p>所以一般情况下我们没有使用这个属性，就会走到else分支，调用 mInstrumentation.callActivityOnCreate(activity, r.state)方法。</p><h4 id="1-1、Instrumentation-callActivityOnCreate"><a href="#1-1、Instrumentation-callActivityOnCreate" class="headerlink" title="1.1、Instrumentation::callActivityOnCreate()"></a>1.1、Instrumentation::callActivityOnCreate()</h4><p>该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Instrumentation.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">        prePerformCreate(activity);</span><br><span class="line">    <span class="comment">//1、关注这里，调用了Activity的performCreate方法</span></span><br><span class="line">        activity.performCreate(icicle);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们看注释1，调用了activity的performCreate方法，见名知意。</p><h5 id="1-1-1、Activity-performCreate"><a href="#1-1-1、Activity-performCreate" class="headerlink" title="1.1.1、Activity::performCreate()"></a>1.1.1、Activity::performCreate()</h5><p>该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity.java </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">        restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    <span class="comment">//1、看到我们的主角吧！onCreate方法</span></span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">        mActivityTransitionState.readState(icicle);</span><br><span class="line">        performCreateCommon();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看注释1，调用了我们熟悉的onCreate方法，我们平时一般在这里面进行Activity的控件、资源等初始化操作。</p><p>下面继续回到ActivityThread的performLaunchActivity方法，接着上面的第6点。</p><ul><li>7、调用Activity的performStart方法，里面最终会调用Activity的onStart方法。</li></ul><p>这里也就是重点关注的注释2，下面看一下performStart方法。</p><h4 id="1-2、Activity-performStart"><a href="#1-2、Activity-performStart" class="headerlink" title="1.2、Activity::performStart()"></a>1.2、Activity::performStart()</h4><p>我们继续点进去看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//1、关注这里，调用了Instrumentation的callActivityOnStart方法</span></span><br><span class="line">    mInstrumentation.callActivityOnStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">             <span class="comment">//...</span></span><br><span class="line">             <span class="comment">//无法调用Activity的onStart方法，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释1，该方法还是一样的套路，调用 mInstrumentation.callActivityOnStart方法，我们看一下 Instrumentation的callActivityOnStart方法：</p><h5 id="1-2-1、Instrumentation-callActivityOnStart"><a href="#1-2-1、Instrumentation-callActivityOnStart" class="headerlink" title="1.2.1、Instrumentation::callActivityOnStart()"></a>1.2.1、Instrumentation::callActivityOnStart()</h5><p>该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Instrumentation.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnStart</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//看到我们的主角吧！onStart方法</span></span><br><span class="line">        activity.onStart();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>很简单的一句代码，调用了我们熟悉的onStart方法。</p><p>继续回到我们的ActivityThread的performLaunchActivity方法，还有一点没分析完，接下来到了根据需要调用Instrumentation的callActivityOnRestoreInstanceState方法，里面最终会调用Activity的onRestoreInstanceState方法，关于这个方法的作用已经不是本文的重点，但我们可以得出一个结论，onRestoreInstanceState方法的调用时机是在onStart方法之后。最后ActivityThread把ActivityClientRecord缓存起来。</p><p>分析完这个长长的方法，其实跟本文有关也就第6、7点。我们跳出ActivityThread::performLaunchActivity方法，回到ActivityThread的handleLaunchActivity方法。现在我们的Activity已经回调了onCreate和onStart方法，接下来应该是onResume方法。</p><p>下面我们我们接着来看handleLaunchActivity方法中注释2的handleResumeActivity方法。</p><h3 id="2、ActivityThread-handleResumeActivity"><a href="#2、ActivityThread-handleResumeActivity" class="headerlink" title="2、ActivityThread::handleResumeActivity()"></a>2、ActivityThread::handleResumeActivity()</h3><p>该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从缓存中拿出ActivityClientRecord</span></span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1、主要关注这里，调用了performResumeActivity方法，这里最终会调用Activity的onResume方法</span></span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、下面if（r ！= null）&#123;&#125;分支里面的逻辑都是把Activity显示出来</span></span><br><span class="line"><span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//拿到Activity</span></span><br><span class="line">        <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">boolean</span> willBeVisible = !a.mStartedActivity;</span><br><span class="line">        <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    willBeVisible = ActivityManager.getService().willActivityBeVisible(</span><br><span class="line">                            a.getActivityToken());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//得到Activity关联的Window</span></span><br><span class="line">             r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">//得到Activity的DecorView，即Activity的顶级View</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            <span class="comment">//先把DecorView设为不可见</span></span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">//得到ViewManager，用于添加DecorView</span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            <span class="comment">//得到布局参加</span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            <span class="comment">//下面设置布局参数</span></span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">             <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                     a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                     <span class="comment">//用ViewManager添加DecorView</span></span><br><span class="line">                     wm.addView(decor, l);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//...</span></span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//此时用于承载DecorView的Window已经被WM添加了，但是还处于INVISIBLE状态,所以下面就把它值为VISIBLE</span></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">             <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                 <span class="comment">//把Activity显示出来</span></span><br><span class="line">                 r.activity.makeVisible();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//Activity不能够Resume，通知AMS结束掉该Activity</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleResumeActivity方法里面的代码也有点长，这个方法主要是把Activity置为Resume状态，并把Activity显示出来，所以我们只关注注释1，注释2是把Activity值为VISIBLE状态，大家要明白的是Activity其实也可以说是一个View，它的顶级View叫做DecorView，但系统回调完Activity的onResume函数时，只是说明Activity1已经完成所有的资源准备工作，Activity已经做好显示给用户的准备，所以还要通过类似于setVisible的方式把它显示出来，这个过程涉及到WindowManage的相关知识，为什么要这样做？大家可以看这篇文章<a href="https://rain9155.github.io/2019/03/22/Window,%20WindowManager%E5%92%8CWindowManagerService%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" target="_blank" rel="noopener">Window,WindowManager和WindowManagerService之间的关系</a>了解一下，所以注释2不是本文重点就不讲了。</p><p>下面我们来看注释1的performResumeActivity方法。</p><h4 id="2-1-ActivityThread-performResumeActivity"><a href="#2-1-ActivityThread-performResumeActivity" class="headerlink" title="2.1 ActivityThread::performResumeActivity()"></a>2.1 ActivityThread::performResumeActivity()</h4><p>该方法主要源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ActivityClientRecord <span class="title">performResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       <span class="keyword">boolean</span> clearHide, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从缓存中拿到ActivityClientRecord</span></span><br><span class="line">     ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class="line">         <span class="keyword">if</span> (clearHide) &#123;</span><br><span class="line">                r.hideForNow = <span class="keyword">false</span>;</span><br><span class="line">                r.activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//1、主要关注这里，调用了Activity的performResume方法</span></span><br><span class="line">            r.activity.performResume();</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">             r.paused = <span class="keyword">false</span>;</span><br><span class="line">             r.stopped = <span class="keyword">false</span>;</span><br><span class="line">             r.state = <span class="keyword">null</span>;</span><br><span class="line">             r.persistentState = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">             <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//抛异常，无法resume Activity</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要关注注释1，调用了Activity的performResume，和上面的performCreate，performStart很相似。</p><p>下面我们来看Activity的performResume方法。</p><h5 id="2-1-1-Activity-performResume"><a href="#2-1-1-Activity-performResume" class="headerlink" title="2.1.1 Activity::performResume()"></a>2.1.1 Activity::performResume()</h5><p>该方法主要源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里处理Activity生命周期中的Restart流程</span></span><br><span class="line">    performRestart();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">mCalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//1、关注这里，调用Instrumentation的callActivityOnResume方法</span></span><br><span class="line">    mInstrumentation.callActivityOnResume(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//抛异常，无法调用Activity的onResume方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中我们看到了 performRestart()方法，这个是根据情况处理Restart流程，里面会执行onReStart() -&gt; onStart() ，到这里就执行onResume()， 所以我们看到注释1会Instrumentation的callActivityOnResume方法，这个和上面的callActivityOnCreate()、callActivityOnStart（）类似。</p><p>本着执着的态度，我们还是看一下Instrumentation的callActivityOnResume方法。</p><h6 id="2-1-2、Instrumentation-callActivityOnResume"><a href="#2-1-2、Instrumentation-callActivityOnResume" class="headerlink" title="2.1.2、Instrumentation::callActivityOnResume()"></a>2.1.2、Instrumentation::callActivityOnResume()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Instrumentation.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnResume</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.mResumed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//又看到了我们的主角之一，onResume方法</span></span><br><span class="line">    activity.onResume();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法先把Activity的mResumed 赋值为true，然后回调了我们熟悉的onResume方法。</p><p>我们跳出ActivityThread的handleResumeActivity方法，回到handleLaunchActivity方法，至此handleLaunchActivity方法分析完，Activity已经显示到用户面前。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到目前为止我们已经回调了Activity的三个生命周期方法：onCreate -&gt; onStart -&gt; onResume，onRestart也介绍了一下，可以说开头那个问题已经解解决了一半，我先来看一下本文的时序图：</p><img src="/2019/05/19/Activity的启动流程（2）/activity1.jpg" title="activity1"><p>所以现在我们知道了在应用进程中ApplicationThread启动Activity的过程。</p><p>那么还有三个方法：onPause -&gt; onStop -&gt; onDestory 什么时候被回调呢？大家都知道Activity有7个生命周期方法，除去onRestart，其他3个都是一 一对应的，结合前面那篇文章<a href="https://rain9155.github.io/2019/05/19/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89/" target="_blank" rel="noopener">Activity的启动流程（1）</a>我们知道：</p><ul><li><p>1、在AMS中含有ApplicatiThread的本地代理，所以AMS所在进程可以通过这个代理与ActivityThread的主线程通信，也就能调用ApplicatiThread的一些方法。</p></li><li><p>2、在应用进程中也含有系统服务AMS的本地代理对象，所以应用进程可以通过这个代理与AMS通信，可以请求AMS启动一个Activity。</p></li><li><p>3、双方都含有双方的代理，通过Binder，也就建立起双方的通信通道。</p></li></ul><p>每个应用都有自己专属Activity任务栈，Activity任务栈的管理是在AMS那边，在本文的情况下，一个Activity已经被启动了，该Activity被加入到栈顶中去，如果此时我按back键返回上一个Activity，那么该Activity就会调用相应的回调onPause -&gt; onStop -&gt; onDestory方法，这个过程在AMS那边对应一个出栈动作，此时AMS也就像启动Activity调用scheduleLaunchActivity方法那样调用ApplicationThread中schedulePauseActivity、scheduleStopActivity、scheduleDestroyActivity方法来结束掉这个Activity，这个调用过程是IPC，所以大家通过本文举一反三也就明白了Activity的其他生命周期是如何被回调的，这个过程离不开与AMS的交互。</p><p>至此我们已经走完startActivity后发生的流程。在这整个过程中也发现了自己平常很多遗落的知识点，让我更进一步的认识了Activity。希望大家也有所收获。</p><p>参考资料：</p><p><a href="https://www.jianshu.com/p/91984327690e" target="_blank" rel="noopener">Activity生命周期回调是如何被回调的</a></p><p><a href="http://liuwangshu.cn/framework/component/7-activity-start-2.html" target="_blank" rel="noopener">Android8.0 根Activity启动过程（后篇）</a></p><p>《Android源码分析与实战》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一篇文章&lt;a href=&quot;https://rain9155.github.io/2019/05/19/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Activity的启动流程（1）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上一篇文章讲了应用进程请求AMS启动Activity过程和Activity在AMS中的启动过程，然后Activity启动的代码逻辑就从AMS所在进程，又重新回到了应用进程所在的ApplicationThread中。我们还留下了一个问题，&lt;strong&gt;Activity的生命周期方法是如何被回调的？&lt;/strong&gt;，下面我们就带着这个疑问，去走一遍源码，看一下在应用进程中ApplicationThread启动Activity的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="四大组件" scheme="http://yoursite.com/categories/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="activity" scheme="http://yoursite.com/tags/activity/"/>
    
  </entry>
  
  <entry>
    <title>Activity的启动流程（1）</title>
    <link href="http://yoursite.com/2019/05/19/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2019/05/19/Activity的启动流程（1）/</id>
    <published>2019-05-19T08:11:17.000Z</published>
    <updated>2019-08-06T05:49:49.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Activity的启动流程有俩种过程，一种是根Activity的启动过程，即在Launch界面点击一个应用图标启动应用程序，根Activity指的是应用程序启动的第一个Activity；另一种是普通Activity的启动流程，即我们平时调用startActivity方法来启动一个Activity。本文讨论第二种，startActivity方法大家都知道是用来启动一个Activity的，那么大家有没有想过它在底层是怎么启动的呢？Activity的生命周期方法是如何被回调的？它启动过程中涉及到多少个进程？接下来我们通过撸一篇源码来了解Activity的大概启动流程，然后解答这几个问题。</p><a id="more"></a><pre><code>本文源码基于Android8.0，本文涉及的源码文件位置如下：frameworks/base/core/java/android/app/Activity.javaframeworks/base/services/core/java/com/android/server/am/*.java(*代表ActivityManagerService，ActivityStack，ActivityStarter，ActivityStackSupervisor，ActivityStack)</code></pre><h2 id="Activity-startActivity"><a href="#Activity-startActivity" class="headerlink" title="Activity::startActivity()"></a>Activity::startActivity()</h2><p>startActivity有好几种重载方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//我们一般没有传options参数给startActivity，所以options为空，就会走到这个分支</span></span><br><span class="line">            <span class="comment">//第二参数requestCode为-1，表示不需要知道Activity启动的结果</span></span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//发现两个参数的startActivityForResult方法最终还是调用三个参数的startActivityForResult方法，options参数传入null</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        startActivityForResult(intent, requestCode, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以发现startActivity最终都会调用到startActivityForResult方法。</p><h3 id="1、Activity-startActivityForResult"><a href="#1、Activity-startActivityForResult" class="headerlink" title="1、Activity::startActivityForResult()"></a>1、Activity::startActivityForResult()</h3><p>这里我们来到了具有三个参数的startActivityForResult方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mParent一直为空</span></span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//1、关注这里，调用Instrumentation的execStartActivity方法</span></span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//此时requestCode为-1</span></span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在上面的的代码中，会进入mParent==null的这个分支里，mParent是Activity类型，它只会在LocalActivityManger构造中被赋值，在我们startActivity过程中一直为空（关于为甚么mParent一直为空，可以查看这篇文章<a href="https://www.jianshu.com/p/3141d2c0194c" target="_blank" rel="noopener">StartActivity路上的mParent</a>）。这里我们只关注注释1，调用Instrumentation的execStartActivity方法，Instrumentation是一个用来监控应用程序与系统交互的类，我们还要注意传入execStartActivity方法的两个参数：</p><ul><li>1、mMainThread.getApplicationThread()：ApplicationThread类型，mMainThread是ActivityThread类型，它是应用程序的入口类，而mMainThread.getApplicationThread()就是获得一个<strong>ApplicationThread</strong>，它是ActivityThread的内部类，它实现了IApplicationThread.Stub，如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java::ApplicationThread</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">IApplicationThread</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IApplicationThread.java类是在编译时由IApplicationThread.aidl通过AIDL工具自动生成的，IApplicationThread的内部会自动生成一个 IApplicationThread.Stub类，它继承自Binder类，而Binder实现了IBinder接口，并且 IApplicationThread.Stub实现了IActivityManager接口。要想进行进程间通信，ApplicationThread只需要继承IApplicationThread.Stub类并实现相应的方法就可以，这样主线程ActivityThread就可以通过ApplicationThread就能对外提供远程服务。要记住这个<strong>ApplicationThread</strong>，他在Activity的启动过程中发挥重要作用。</p><ul><li>2、mToken： 它的类型为IBinder，代表着当前Activity的token，它保存自己所处Activity的ActivityRecord信息</li></ul><h3 id="2、Instrumentation-execStartActivity"><a href="#2、Instrumentation-execStartActivity" class="headerlink" title="2、Instrumentation::execStartActivity()"></a>2、Instrumentation::execStartActivity()</h3><p>我们继续看Instrumentation的execStartActivity方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Instrumentation.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//还记得上面提到的ApplicationThread吗，这里把它转成了IApplicationThread，并在下面作为startActivity方法的参数</span></span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//1、关注这里，这里实际调用的是ActivityManagerService的startActivity方法</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                           intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                           token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                           requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        <span class="comment">//检查启动Activity的结果，无法正确启动一个Activiy时，这个方法抛出异常</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看注释1，ActivityManager.getService()返回的是ActivityManagerService（下面简称AMS）在应用进程的本地代理，该方法在ActivityManager中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//IActivityManagerSingleton是Singleton类型，Singleton是一个单例的封装类</span></span><br><span class="line">    <span class="comment">//第一次调用它的get方法时它会通过create方法来初始化AMS这个Binder对象，在后续调用中返回之前创建的对象</span></span><br><span class="line">        <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">            <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//ServiceManager是服务大管家，这里通过getService获取到了IBinder类型的AMS引用</span></span><br><span class="line">                    <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                    <span class="comment">//这通过asInterface方法把IBinder类型的AMS引用转换成AMS在应用进程的本地代理</span></span><br><span class="line">                    <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                    <span class="keyword">return</span> am;</span><br><span class="line">                &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>上面出现的IActivityManager.java类的意义类似于前面提到的ApplicationThread.java。要想进行进程间通信，AMS只需要继承IActivityManager.Stub类并实现相应的方法就可以，这样AMS就能对外提供远程服务，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityManagerService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">IActivityManager</span>.<span class="title">Stub</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以继续回到Instrumentation的execStartActivity方法中，ActivityManager.getService()返回的是AMS的本地代理，注意AMS是在系统进程SystemServer中，所以注释1这里通过<strong>Binder的IPC</strong>，调用的其实是AMS的startActivity方法。</p><p><strong>在这里开始，Activity的启动过程从应用进程转移到AMS中去</strong>。</p><h2 id="AMS-startActivity"><a href="#AMS-startActivity" class="headerlink" title="AMS::startActivity()"></a>AMS::startActivity()</h2><p>AMS的startActivity方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AMS.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">             resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">             UserHandle.getCallingUserId());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>简单的return了startActivityAsUser方法，该方法在最后多了个 UserHandle.getCallingUserId()参数，AMS根据这个确定调用者权限。我们再来看看其他参数：</p><ul><li>caller：IApplicationThread类型，还记得上面提到的ApplicationThread吗？到这里它已经被转成了ApplicationThread的本地代理，这个转换的过程发生在上面讲到的Binder的IPC中，就像上面提到的AMS本地代理转换一样。</li><li>callingPackage：前面一直传过来的，代表调用者Activity所在的包名</li><li>intent：前面startActivity时传递过来的intent</li><li>resolvedType：从上面传过来，intent.resolveTypeIfNeeded()</li><li>resultTo：IBinder类型，还记得上面提到的mToken吗？就是从上面一直传过来的，保存着的调用者Activity的ActivityRecord信息</li><li>resultWho：String类型，调用者Activity的mEmbeddedID，前面一直传过来的</li><li>requestCode：从上面一直传过来的，一直为-1</li><li>startFlags：从上面传过来，为0</li><li>profilerInfo：ProfilerInfo类型，从上面传过来，等于null</li><li>bOptions：Bundle类型，从上面传过来，等于null</li></ul><p>下面继续看AMS的startActivityAsUser方法。</p><h3 id="1、AMS-startActivityAsUser"><a href="#1、AMS-startActivityAsUser" class="headerlink" title="1、AMS::startActivityAsUser()"></a>1、AMS::startActivityAsUser()</h3><p>startActivityAsUser方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AMS.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">             resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">             profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, bOptions, <span class="keyword">false</span>, userId, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">             <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>省略了两个判断，1、判断调用者进程是否被隔离，2、判断调用者是否有权限，这些都不是重点。下面继续简单的return了mActivityStarter.startActivityMayWait方法，mActivityStarter是ActivityStarter类型，它是AMS中加载Activity的控制类，会收集所有的逻辑来决定如何将Intent和Flags转换为Activity，并将Activity和Task以及Stack相关联。传入startActivityMayWait方法的参数又多了几个，看一下几个：</p><ul><li>callingUid：第二个参数，等于-1</li><li>inTask：倒数第二个参数，TaskRecord类型，代表要启动的Activity所在的栈，这里为null，表示还没创建</li><li>reason：倒数第一个参数，值为”startActivityAsUser”，代表启动的理由</li><li>其他的参数有一些传入null，有一些是从上面传过来的</li></ul><p>下面看ActivityStarter中的startActivityMayWait方法。</p><h3 id="2、ActivityStarter-startActivityMayWait"><a href="#2、ActivityStarter-startActivityMayWait" class="headerlink" title="2、ActivityStarter::startActivityMayWait()"></a>2、ActivityStarter::startActivityMayWait()</h3><p>来看看这个方法的源码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityStarter.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, Bundle bOptions, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">int</span> userId, IActivityContainer iContainer, TaskRecord inTask, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//把上面传进来的intent再构造一个新的Intent对象，这样即便intent被修改也不受影响</span></span><br><span class="line">    intent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);</span><br><span class="line">    <span class="keyword">if</span>(rInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析这个intent，收集intent指向的Activity信息</span></span><br><span class="line">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord[] outRecord = <span class="keyword">new</span> ActivityRecord[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//1、主要关注这里，调用了本身的startActivityLocked方法</span></span><br><span class="line">    <span class="keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask, reason);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityInfo里面收集了要启动的Activity信息（关于ResolveInfo与ActivityInfo可以看这篇<a href="https://blog.csdn.net/Rain_9155/article/details/89286415" target="_blank" rel="noopener">如何获取Android应用与系统信息</a>），主要还是关注注释1，这里又调用了ActivityStarter中的startActivityLocked方法。传入startActivityLocked方法的参数又多了几个（callingPid等）。关于pid于与uid的介绍可以看这篇文章<a href="https://blog.csdn.net/jiaoli_82/article/details/49802613" target="_blank" rel="noopener">Android手机中UID、PID作用及区别</a>。</p><p>下面来看一下startActivityLocked方法。</p><h4 id="2-1、ActivityStarter-startActivityLocked"><a href="#2-1、ActivityStarter-startActivityLocked" class="headerlink" title="2.1、ActivityStarter::startActivityLocked()"></a>2.1、ActivityStarter::startActivityLocked()</h4><p>该方法的相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityStarter.java</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags, ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask, String reason)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//这里对上面传进来值为"startActivityAsUser"理由参数判空</span></span><br><span class="line">         <span class="keyword">if</span> (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Need to specify a reason."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       mLastStartReason = reason;</span><br><span class="line">       mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">       mLastStartActivityRecord[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//1、主要关注这里，调用了本身的startActivity方法</span></span><br><span class="line">       mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">                container, inTask);</span><br><span class="line">      <span class="keyword">if</span> (outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            outActivity[<span class="number">0</span>] = mLastStartActivityRecord[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> mLastStartActivityResult;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里主要关注注释1，调用了ActivityStarter中的startActivity方法，该方法多了一个参数，最后一个mLastStartActivityRecord，mLastStartActivityRecord是一个ActivityRecord数组类型，ActivityRecord是用来保存一个Activity的所有信息的类。</p><p>下面来看ActivityStarter中的startActivity方法。</p><h4 id="2-2、ActivityStarter-startActivity"><a href="#2-2、ActivityStarter-startActivity" class="headerlink" title="2.2、ActivityStarter::startActivity()"></a>2.2、ActivityStarter::startActivity()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//ActivityStarter.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags, ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> err = ActivityManager.START_SUCCESS;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="comment">//获取调用者所在进程记录的对象，caller就是上面一直强调的代表调用者进程的ApplicationThread对象</span></span><br><span class="line">     ProcessRecord callerApp = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//这里调用AMS的getRecordForAppLocked方法获得代表调用者进程的callerApp</span></span><br><span class="line">         callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">         <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">//获取调用者进程的pid与uid并赋值</span></span><br><span class="line">             callingPid = callerApp.pid;</span><br><span class="line">             callingUid = callerApp.info.uid;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//下面startActivity方法的参数之一，代表调用者Activity的信息</span></span><br><span class="line">     ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="comment">//创建即将要启动的Activity的信息描述类ActivityRecord</span></span><br><span class="line">      ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">                callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">                resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="keyword">null</span>,</span><br><span class="line">                mSupervisor, container, options, sourceRecord);</span><br><span class="line">     <span class="comment">//outActivity是ActivityRecord[]类型，从上面传进来，这里把ActivityRecord赋值给了它，下面会作为参数传进startActivity方法中</span></span><br><span class="line">     <span class="keyword">if</span> (outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">         outActivity[<span class="number">0</span>] = r;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="comment">//1、关注这里，调用了本身的另一个startActivity方法</span></span><br><span class="line"><span class="keyword">return</span> startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, <span class="keyword">true</span>,</span><br><span class="line">                options, inTask, outActivity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的startActivity代码非常长，省略了很多，上面讲的调用者进程，在这里等价于应用程序进程，ProcessRecord是用来描述一个应用进程的信息，ActivityRecord上面也讲过了，就是用来记录一个要启动的Activity的所有信息，在注释1处的调用了ActivityStarter的startActivity方法，这个方法参数少了很多，大多数有关要启动的Activity的信息都被封装进了ActivityRecord类中，作为参数r传了进去。</p><p>下面来看ActivityStarter的startActivity方法。</p><h4 id="2-3、ActivityStarter-startActivity"><a href="#2-3、ActivityStarter-startActivity" class="headerlink" title="2.3、ActivityStarter::startActivity()"></a>2.3、ActivityStarter::startActivity()</h4><p>该方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//ActivityStarter.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">                           IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> result = START_CANCELED;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">            mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">         <span class="comment">//1、主要关注这里，调用本身的startActivityUnchecked方法</span></span><br><span class="line">            result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                    startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">           mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里主要调用了ActivityStarter的startActivityUnchecked方法。</p><h4 id="2-4、ActivityStarter-startActivityUnchecked"><a href="#2-4、ActivityStarter-startActivityUnchecked" class="headerlink" title="2.4、ActivityStarter::startActivityUnchecked()"></a>2.4、ActivityStarter::startActivityUnchecked()</h4><p>该方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityStarter.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把上面传进来的参数除了outActivity都传进去了，主要是把这些参数赋值给ActivityStarter的成员变量，如mDoResume = doResume, mStartActivity = r</span></span><br><span class="line">    <span class="comment">//mStartActivity就是即将要启动的Activity的信息</span></span><br><span class="line">     setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">                voiceInteractor);</span><br><span class="line">    <span class="comment">//计算出启动Activity的模式，并赋值给mLaunchFlags</span></span><br><span class="line">    computeLaunchingTaskFlags();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//设置启动模式</span></span><br><span class="line">     mIntent.setFlags(mLaunchFlags);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">boolean</span> newTask = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//1、下面会进行判断，到底需不需要创建一个新的Activity任务栈</span></span><br><span class="line">    <span class="keyword">int</span> result = START_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.resultTo == <span class="keyword">null</span> &amp;&amp; mInTask == <span class="keyword">null</span> &amp;&amp; !mAddingToTask</span><br><span class="line">        &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//1.1走这里就会在setTaskFromReuseOrCreateNewTask方法内部创建一个新的Activity任务栈</span></span><br><span class="line">        newTask = <span class="keyword">true</span>;</span><br><span class="line">        result = setTaskFromReuseOrCreateNewTask(</span><br><span class="line">            taskToAffiliate, preferredLaunchStackId, topStack);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1.2走这里就会在setTaskFromSourceRecord方法内部获得调用者Activity的的任务栈赋值给mTargetStack</span></span><br><span class="line">        result = setTaskFromSourceRecord();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1.3走这里就会在setTaskFromInTask方法内部直接把mInTask赋值给mTargetStack，前面已经说过mInTask等于null</span></span><br><span class="line">        result = setTaskFromInTask();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1.4、就是前面的条件都不满足了，但是这种情况很少发生</span></span><br><span class="line">        setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//mDoResume等于上面传进来的doResume，为true</span></span><br><span class="line">     <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                    mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">            <span class="keyword">if</span> (!mTargetStack.isFocusable()</span><br><span class="line">                    || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">              <span class="comment">//走这里不会显示Activity，因为Activity还没有获取焦点或者Activity的栈溢出</span></span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//正常的话会走到这里</span></span><br><span class="line">                <span class="keyword">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                    mTargetStack.moveToFront(<span class="string">"startActivityUnchecked"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//2、主要关注这里调用mSupervisor的resumeFocusedStackTopActivityLocked方法</span></span><br><span class="line">                mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                        mOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的startActivityUnchecked方法也是很长，这个方法主要处理Activity栈管理相关的逻辑，如果对于这方面信息不熟悉的话可以查看这两篇文章<a href="https://blog.csdn.net/guolin_blog/article/details/41087993" target="_blank" rel="noopener">Android任务和返回栈完全解析</a>、<a href="http://liuwangshu.cn/framework/ams/2-activitytask.html" target="_blank" rel="noopener">ActivityTask和Activity栈管理</a>。一个或多个ActivityRecord会组成一个TaskRecord，TaskRecord用来记录Activity的栈，而ActivityStack包含了一个或多个TaskRecord。上面代码的mTargetStack就是ActivityStack类型，我们先来看注释1，注释1会根据mLaunchFlags等条件到底需不需要创建一个新的Activity任务栈，而本文所讨论的条件限定在从一个应用程序调用Activity的startActivity去启动另外一个Activity的情景，而且默认Activity的启动模式是standard，并不会创建一个新的任务栈，所以就会走到1.2的条件分支，然后我们再来看注释2，这里会调用mSupervisor.resumeFocusedStackTopActivityLocked方法，mSupervisor是ActivityStackSupervisor类型，ActivityStackSupervisor主要用来管理ActivityStack。启动Activity的过程从ActivityStack来到了ActivityStackSupervisor。</p><p>下面我们来看ActivityStackSupervisor的resumeFocusedStackTopActivityLocked方法。</p><h3 id="3、ActivityStackSupervisor-resumeFocusedStackTopActivityLocked"><a href="#3、ActivityStackSupervisor-resumeFocusedStackTopActivityLocked" class="headerlink" title="3、ActivityStackSupervisor::resumeFocusedStackTopActivityLocked()"></a>3、ActivityStackSupervisor::resumeFocusedStackTopActivityLocked()</h3><p>该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityStackSupervisor.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//获取要启动的Activity所在栈的栈顶的ActivityRecord</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    <span class="comment">//1、r是否null或是否为RESUMED状态</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.state != RESUMED) &#123;</span><br><span class="line">            <span class="comment">//2、关注这里，调用ActivityStack的resumeTopActivityUncheckedLocked方法</span></span><br><span class="line">            mFocusedStack.resumeTopActivityUncheckedLocked(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state == RESUMED) &#123;</span><br><span class="line">            mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先这里会获取要启动的Activity所在栈的栈顶的ActivityRecord赋值给r，因为要启动的Activity的还没有启动，所以此时栈顶就是调用者Activity，调用者Activity启动Activity，肯定会从RESUME状态转到其他状态如STPO，所以注释1满足r.state != RESUMED的条件，此时就是走带注释2，注释2调用了mFocusedStack的resumeTopActivityUncheckedLocked方法，mFocusedStack就是ActivityStack类型。启动Activity的过程从ActivityStackSupervisor又回到到了ActivityStack。</p><p>下面我们来看ActivityStack的resumeTopActivityUncheckedLocked方法。</p><h4 id="3-1、ActivityStack-resumeTopActivityUncheckedLocked"><a href="#3-1、ActivityStack-resumeTopActivityUncheckedLocked" class="headerlink" title="3.1、ActivityStack:: resumeTopActivityUncheckedLocked()"></a>3.1、ActivityStack:: resumeTopActivityUncheckedLocked()</h4><p>该方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityStack.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、关注这里，这里调用了本身的resumeTopActivityInnerLocked方法</span></span><br><span class="line">            result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们来看注释1，简单的调用了resumeTopActivityInnerLocked方法。</p><h5 id="3-1-1、-ActivityStack-resumeTopActivityInnerLocked"><a href="#3-1-1、-ActivityStack-resumeTopActivityInnerLocked" class="headerlink" title="3.1.1、 ActivityStack:: resumeTopActivityInnerLocked()"></a>3.1.1、 ActivityStack:: resumeTopActivityInnerLocked()</h5><p>该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityStack.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//获得将要启动的Activity的信息</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>)</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//1、关注这里，调用了ActivityStackSupervisor的startSpecificActivityLocked方法</span></span><br><span class="line">            mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>topRunningActivityLocked方法获得将要启动的Activity的信息next，因为此时要启动的Activity还不属于任何进程，故它的ProcessRecord为空成立，就会走到else分支，所以注释1这里调用了ActivityStackSupervisor的startSpecificActivityLocked方法，又回到了ActivityStackSupervisor中。</p><p>下面来看ActivityStackSupervisor的startSpecificActivityLocked方法。</p><h4 id="3-2、ActivityStackSupervisor-startSpecificActivityLocked"><a href="#3-2、ActivityStackSupervisor-startSpecificActivityLocked" class="headerlink" title="3.2、ActivityStackSupervisor::startSpecificActivityLocked()"></a>3.2、ActivityStackSupervisor::startSpecificActivityLocked()</h4><p>该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityStackSupervisor.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取要启动的Activity的所在应用程序进程</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">        r.getStack().setLaunchTime(r);</span><br><span class="line">        <span class="comment">//要启动的Activity的所在应用程序进程存在</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="comment">//1、关注这里，调用了本身的realStartActivityLocked方法</span></span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里首先会获取要启动的Activity所在的应用进程app，当app进程已经运行时，就会调用注释1处的realStartActivityLocked方法，注意这里多了一个参数，把代表应用进程的app传了进去。</p><p>下面来看ActivityStackSupervisor的realStartActivityLocked方法。</p><h4 id="3-3、ActivityStackSupervisor-realStartActivityLocked"><a href="#3-3、ActivityStackSupervisor-realStartActivityLocked" class="headerlink" title="3.3、ActivityStackSupervisor::realStartActivityLocked()"></a>3.3、ActivityStackSupervisor::realStartActivityLocked()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1、把应用所在进程信息赋值给要启动的Activity的ActivityRecord</span></span><br><span class="line">    r.app = app;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//2、关注这里，app是ProcessRecord类型，app.thread是IApplicationThread类型</span></span><br><span class="line">        <span class="comment">//app.thread是应用进程的ApplicationThread在AMS的本地代理，前面已经讲过</span></span><br><span class="line">        <span class="comment">//所以这里实际调用的是ApplicationThread的scheduleLaunchActivity方法</span></span><br><span class="line">        app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                   System.identityHashCode(r), r.info,</span><br><span class="line">                   mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                   mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                   r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                   r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                   mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如这方法名所示，realStartActivity，兜兜转转，这里就是真正启动Activity的地方，注释1处app指的是传入的要启动的Activity的所在的应用程序进程，是从前面传过来的，这里把它赋值给了要启动的Activity的ActivityRecord的app字段去，这样就可以说要启动的Activity属于应用进程，我们再来看注释2这里，app.thread就是我们上面一直强调的ApplicationThread，所以这里通过<strong>Binder的IPC</strong>其实调用的是ApplicationThread中的scheduleLaunchActivity方法。</p><p><strong>当前的代码逻辑执行在AMS所在进程，从这里开始Activity的启动流程最终又回到了应用进程所在的ApplicationThread中。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来一篇文章写完Activity的启动，写到这里才发现，篇幅太长，所以<strong>Activity在应用进程中的启动过程</strong>就放到下一篇文章。本文简单的介绍了<strong>应用进程请求AMS启动Activity过程和Activity在AMS中的启动过程</strong>，现在让我们来回答一下开头给出的几个问题：</p><ul><li><strong>1、Activity的启动流程是怎样的？</strong></li></ul><p>从应用调用一个startActivity方法开始，应用进程开始请求AMS启动Activity，然后在AMS中Activity完成它的一系列准备，最后再回到应用进程中开始回调Activity的生命周期，本文回答了一半这个问题，即本文讲解了应用进程开始请求AMS启动Activity，然后在AMS中完成它的一系列准备的过程，这个过程用时序图表示如下：</p><img src="/2019/05/19/Activity的启动流程（1）/activity3.jpg" title="activity3"><ul><li><strong>2、Activity的生命周期方法是如何被回调的？</strong></li></ul><p>本文并没有解答这个问题，这个问题要到下一篇文章才能有答案。</p><ul><li><strong>3、它启动过程中涉及到多少个进程？</strong></li></ul><p>答案是2个，前言已经讲过本文讨论的是普通Activity的启动流程，<strong>即我们平时调用startActivity方法来启动一个Activity</strong>，所以本文这个过程涉及的进程可以可以用下面这个图表示：</p><img src="/2019/05/19/Activity的启动流程（1）/activity1.png" title="activity1"><p>图中AppProcess代表应用所在进程，systemServer代表AMS所在进程，两个进程之间通过Binder进行通信，实现了XX.Stub的类就可以进行Binder通信，如本文的ApplicationThread和AMS都实现了各自的Stub类，所以应用进程startActivity时请求AMS启动Activity，AMS准备好后，再发送scheduleLaunchActivity请求告诉应用可以开始启动Activity了。</p><p>那么如果是前言所讲的第一种启动Activity的过程，<strong>即在Launch界面点击一个应用图标启动应用程序</strong>，那么会涉及多少个进程？答案是4个，如图：</p><img src="/2019/05/19/Activity的启动流程（1）/activity2.png" title="activity2"><p>可以看到会涉及Launcher进程、SystemServer进程、App进程、Zygote进程。关于这些进程的简单信息可以看这篇<a href="https://blog.csdn.net/Rain_9155/article/details/88831678" target="_blank" rel="noopener">从进程的角度看Android的系统架构</a></p><p>阅读源码真的是一个漫长的过程，又时候看别人写的那么简单，但是当自己去写，才发现要考虑的东西很多，所以这是一个日积月累的过程，所以阅读源码的时候，最好跟着前人的文章阅读，这样理解的更快。</p><p>参考文章：</p><p>《Android开发艺术探索》</p><p><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a></p><p><a href="http://liuwangshu.cn/framework/component/6-activity-start-1.html" target="_blank" rel="noopener">Android8.0 根Activity启动过程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Activity的启动流程有俩种过程，一种是根Activity的启动过程，即在Launch界面点击一个应用图标启动应用程序，根Activity指的是应用程序启动的第一个Activity；另一种是普通Activity的启动流程，即我们平时调用startActivity方法来启动一个Activity。本文讨论第二种，startActivity方法大家都知道是用来启动一个Activity的，那么大家有没有想过它在底层是怎么启动的呢？Activity的生命周期方法是如何被回调的？它启动过程中涉及到多少个进程？接下来我们通过撸一篇源码来了解Activity的大概启动流程，然后解答这几个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="四大组件" scheme="http://yoursite.com/categories/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="activity" scheme="http://yoursite.com/tags/activity/"/>
    
  </entry>
  
  <entry>
    <title>Window,WindowManager和WindowManagerService之间的关系</title>
    <link href="http://yoursite.com/2019/03/22/Window,%20WindowManager%E5%92%8CWindowManagerService%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2019/03/22/Window, WindowManager和WindowManagerService之间的关系/</id>
    <published>2019-03-22T14:36:32.000Z</published>
    <updated>2019-07-26T07:19:53.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上面3个名词在开发中经常听到，在Android开发中，Window是所有视图的载体，如Activity，Dialog和Toast的视图，我们想要对Window进行添加和删除就要通过WindowManager来操作，而WindowManager就是通过Binder与WindowManagerService进行跨进程通信，把具体的实现工作交给WindowManagerService（下面简称WMS）。下面分别介绍它们，理清它们的基本脉络。<br><a id="more"></a></p><pre><code>本文基于Android8.0, 相关源码位置如下:frameworks/base/core/java/android/view/*.java（*代表Window, WindowManager, ViewManager, WindowManagerImpl，WindowManagerGlobal, ViewRootImpl）frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java    frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java    frameworks/base/services/core/java/com/android/server/wm/Session.java</code></pre><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><h4 id="1、Window是什么"><a href="#1、Window是什么" class="headerlink" title="1、Window是什么"></a>1、Window是什么</h4><p>Window在Android开发中是一个窗口的概念，它是一个抽象类，我们打开Window，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEATURE_NO_TITLE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEATURE_CONTENT_TRANSITIONS = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> View <span class="title">getDecorView</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">     <span class="keyword">public</span> &lt;T extends View&gt; <span class="function">T <span class="title">findViewById</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDecorView().findViewById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面有我们熟悉的一些字段和方法，以Activity对应的Window为例，具体的实现类是PhoneWindow，在PhoneWindow中有一个顶级View—DecorView，继承自FrameLayout，我们可以通过getDecorView()获得它，当我们调用Activity的setContentView时，其实最终会调用Window的setContentView，当我们调用Activity的findViewById时，其实最终调用的是Window的findViewById，这也间接的说明了Window是View的直接管理者。但是Window并不是真实存在的，它更多的表示一种抽象的功能集合，View才是Android中的视图呈现形式，绘制到屏幕上的是View不是Window，但是View不能单独存在，它必需依附在Window这个抽象的概念上面，Android中需要依赖Window提供视图的有Activity，Dialog，Toast，PopupWindow，StatusBarWindow（系统状态栏），输入法窗口等，因此Activity，Dialog等视图都对应着一个Window。</p><h4 id="2、Window的类型（应用窗口，子窗口，系统窗口-与层级"><a href="#2、Window的类型（应用窗口，子窗口，系统窗口-与层级" class="headerlink" title="2、Window的类型（应用窗口，子窗口，系统窗口)与层级"></a>2、Window的类型（应用窗口，子窗口，系统窗口)与层级</h4><p>Window的类型type被定义在WindowManager中的静态内部类LayoutParams中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WindowManager</span> <span class="keyword">extends</span> <span class="title">ViewManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span>.<span class="title">LayoutParams</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//应用程序窗口type值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_APPLICATION_WINDOW = <span class="number">1</span>;<span class="comment">//代表应用程序窗口的起始值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_BASE_APPLICATION   = <span class="number">1</span>;<span class="comment">//窗口的基础值，其他窗口的type值要大于这个值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION        = <span class="number">2</span>;<span class="comment">//普通应用程序窗口，token必须设置为Activity的token来指定窗口属于谁</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_STARTING = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_DRAWN_APPLICATION = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_APPLICATION_WINDOW = <span class="number">99</span>;<span class="comment">//代表应用程序窗口的结束值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//子窗口type值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SUB_WINDOW = <span class="number">1000</span>;<span class="comment">//代表子窗口的起始值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA_OVERLAY  = FIRST_SUB_WINDOW + <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SUB_WINDOW = <span class="number">1999</span>;<span class="comment">//代表子窗口的结束值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//系统窗口的type值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SYSTEM_WINDOW     = <span class="number">2000</span>;<span class="comment">//代表系统窗口的起始值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_STATUS_BAR         = FIRST_SYSTEM_WINDOW;<span class="comment">//系统状态栏</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SEARCH_BAR         = FIRST_SYSTEM_WINDOW+<span class="number">1</span>;<span class="comment">//搜索条窗口</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_PHONE              = FIRST_SYSTEM_WINDOW+<span class="number">2</span>;<span class="comment">//通话窗口</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SYSTEM_WINDOW      = <span class="number">2999</span>;<span class="comment">//代表系统窗口结束值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LayoutParams中以TYPE开头的值有很多，但总体可以分为3类：</p><ul><li>应用程序窗口：type值范围是1~99，Activity就是一个典型的应用程序窗口，type值是TYPE_BASE_APPLICATION，WindowManager的LayoutParams默认type值是TYPE_APPLICATION。</li><li>子窗口：type值范围是1000~1999，PupupWindow就是一个典型的子窗口，type值是TYPE_APPLICATION_PANEL，子窗口不能独立存在，必须依附于父窗口</li><li>系统窗口：type值范围是2000~2999,系统窗口的类型很多，上面并没有全部列举出来，系统状态栏就是一个典型的系统窗口，type值是TYPE_STATUS_BAR，与应用程序窗口不同的是，系统窗口的创建是需要声明权限的。</li></ul><p>type值决定了决定了Window显示的层级（z-ordered），即在屏幕Z轴方向的显示次序，一般情况下type值越大，则窗口显示的越靠前，在Window的3种类型中，应用程序窗口的层级范围是1~99，子窗口的层级范围是1000~1999，系统窗口的层级范围是2000~2999，层级范围对应着type值，如果想要Window位于所有的Window上，采用较大的层级即可，例如系统层级。</p><h4 id="3、Window的属性"><a href="#3、Window的属性" class="headerlink" title="3、Window的属性"></a>3、Window的属性</h4><p>Window的类型flag同样被定义在WindowManager中的静态内部类LayoutParams中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WindowManager</span> <span class="keyword">extends</span> <span class="title">ViewManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span>.<span class="title">LayoutParams</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_ALLOW_LOCK_WHILE_SCREEN_ON     = <span class="number">0x00000001</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_DIM_BEHIND        = <span class="number">0x00000002</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_BLUR_BEHIND        = <span class="number">0x00000004</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_NOT_FOCUSABLE      = <span class="number">0x00000008</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_NOT_TOUCHABLE      = <span class="number">0x00000010</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_NOT_TOUCH_MODAL    = <span class="number">0x00000020</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_KEEP_SCREEN_ON     = <span class="number">0x00000080</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LayoutParams中定义的flag属性同样很多，这里挑几个常见的讲解：</p><ul><li>FLAG_ALLOW_LOCK_WHILE_SCREEN_ON：只要窗口对用户可见，就允许在屏幕开启状态下锁屏。</li><li>FLAG_KEEP_SCREEN_ON： 只要窗口对用户可见，屏幕就一直亮着。</li><li>FLAG_SHOW_WHEN_LOCKED：窗口可以在锁屏的界面上显示。</li><li>FLAG_NOT_FOCUSABLE：窗口不能获取焦点，也不能接受任何输入事件，此标志同时会启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层的具有焦点的窗口。</li><li>FLAG_NOT_TOUCH_MODAL：当前窗口区域以外的触摸事件会传递给底层的窗口，当前窗口区域内的触摸事件则自己处理，一般来说都要开启此标记，否则其他Window将无法收到单机事件。</li><li>FLAG_NOT_TOUCHABLE：窗口不接收任何触摸事件</li></ul><p>可以看到LayoutParams中的type和flag非常重要，可以控制Window的显示特性。知道了Window的相关信息，就能更好的了解WindowManager。</p><h2 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h2><p>WindowManager是一个接口，里面常用的方法有：添加View，更新View和删除View，WindowManager继承自ViewManager，这三个方法定义在ViewManager中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这些方法传入的参数是View，不是Window，说明WindowManager管理的是Window中的View，我们通过WindowManager操作Window就是在操作Window中的View。WindowManager的具体实现类是WindowManagerImp，我们看一下相应方法的实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title">WindowManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Window mParentWindow;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WindowManagerImpl</span><span class="params">(Context context, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mParentWindow = parentWindow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        mGlobal.updateViewLayout(view, params);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        mGlobal.removeView(view, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到WindowManagerImp也没有做什么，它把3个方法的操作都委托给了WindowManagerGlobal这个单例类，我们还看到了mParentWindow这个字段，它是Window类型，是从构造中被传入，所以WindowManager会持有Window的引用，这样WindowManager就可以对Window做操作了。比如<strong>mGlobal.addView</strong>，我们可以理解为往window中添加View，在WindowManagerGlobal中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);<span class="comment">//注释1</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会走到ViewRootlmp的setView中, 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//这里会进行View的绘制流程</span></span><br><span class="line">    requestLayout();</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//通过session与WMS建立通信</span></span><br><span class="line">     res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                                getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                                mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                                mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ViewRootlmp的setView中，首先通过requestLayout()发起View绘制流程，然后在mWindowSession的addToDisplay中通过Binder与WMS进行跨进程通信，请求显示窗口上的视图，至此View就会显示到屏幕上。这个mWindowSession是一个IWindowSession.AIDL接口类型，用来实现跨进程通信，在WMS内部会为每一个应用的请求保留一个单独的Session，同样实现了IWindowSession接口，应用与WMS之间的通信就通过这个Session。那么这个mWindowSession什么时候被赋值的呢？就在上面的注释1中，我们打开ViewRootlmp的构造函数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到mWindowSession是通过WindowManagerGlobal的单例类的getWindowSession()获得的，我们打开WindowManagerGlobal的getWindowSession()，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">           <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">                   <span class="comment">//1、首先获取WMS的本地代理</span></span><br><span class="line">                   IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                   <span class="comment">//2、通过WMS的本地代理的openSession来获取Session</span></span><br><span class="line">                   sWindowSession = windowManager.openSession(</span><br><span class="line">                           <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimatorScaleChanged</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">                                   ValueAnimator.setDurationScale(scale);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;,</span><br><span class="line">                           imm.getClient(), imm.getInputContext());</span><br><span class="line">               &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> sWindowSession;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们首先看1，getWindowManagerService()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowManager <span class="title">getWindowManagerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sWindowManagerService == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//获取WMS的本地代理对象</span></span><br><span class="line">                sWindowManagerService = IWindowManager.Stub.asInterface(</span><br><span class="line">                        ServiceManager.getService(<span class="string">"window"</span>));</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sWindowManagerService;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到， ServiceManager.getService(“window”)就是获得WMS，然后通过IWindowManager.Stub.asInterface()转换成WMS在应用进程的本地代理，getWindowManagerService()就是返回WMS在本地应用进程的代理。（这里涉及到Binder知识）</p><p>然后看2，通过WMS的本地代理的openSession来获取Session，我们可以在WMS中找到这个函数实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IWindowSession <span class="title">openSession</span><span class="params">(IWindowSessionCallback callback, IInputMethodClient client,</span></span></span><br><span class="line"><span class="function"><span class="params">          IInputContext inputContext)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">//为每个窗口请求创建一个Session并返回</span></span><br><span class="line">      Session session = <span class="keyword">new</span> Session(<span class="keyword">this</span>, callback, client, inputContext);</span><br><span class="line">      <span class="keyword">return</span> session;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此建立起与WMS的通信的桥梁。然后WindowManager就间接的通过Session向WMS发起显示窗口视图的请求，WMS会向应用返回和窗口交互的信息。至于mGlobal.updateViewLayout和mClobal.removeView也是类似的过程，可自行研究。</p><h2 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h2><p>WindowManagerService是一个系统级服务，由SystemService启动，实现了IWindowManager.AIDL接口，它的主要功能分为以下俩方面:</p><h3 id="1、窗口管理"><a href="#1、窗口管理" class="headerlink" title="1、窗口管理"></a>1、窗口管理</h3><p>它负责窗口的启动，添加和删除，它还负责窗口的层级显示（z-orderes）和维护窗口的状态。我们继续上面的<strong>mGlobal.addView</strong>，上面讲到这个方法是向WMS发起一个显示窗口视图的请求，最终会走到mWindowSession.addToDisplay()方法，我们可以在Session中找到这个函数实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">           Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//返回WMS中addWindow所返回的结果</span></span><br><span class="line">       <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">               outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到addToDisplay方法中最终返回了WMS中addWindow所返回的结果，Window的添加请求就交给WMS去处理，addWindow的实现在WMS中，里面代码很长，这里就不再深究了（留在下一篇文章从一个例子分析），addWindow主要做的事情是先进行窗口的权限检查，因为系统窗口需要声明权限，然后根据相关的Display信息以及窗口信息对窗口进行校对，再然后获取对应的WindowToken，再根据不同的窗口类型检查窗口的有效性，如果上面一系列步骤都通过了，就会为该窗口创建一个WindowState对象，以维护窗口的状态和根据适当的时机调整窗口状态，最后就会通过WindowState的attach方法与SurfaceFlinger通信。因此SurfaceFlinger能使用这些Window信息来合成surfaces,并渲染输出到显示设备。</p><h3 id="2、输入事件的中转站"><a href="#2、输入事件的中转站" class="headerlink" title="2、输入事件的中转站"></a>2、输入事件的中转站</h3><p>当我们的触摸屏幕时就会产生输入事件，在Android中负责管理事件的输入是<strong>InputManagerService</strong>，在启动IMS的时候会在native层创建NativeInputManager，在NativeInputManager的构造中会创建<strong>InputManager和Eventhub（监听/dev/input/设备节点中所有事件的输入）</strong>，在InputManager构造中会依此创建<strong>InputDispatcher、InputReader、InputReaderThread、InputDispatcherThread</strong>。</p><p>InputReader运行在InputReaderThread中，它会不断循环从EventHub中读取原始输入事件，InputReader将这些原始输入事件加工后就交给运行在InputDispatcherThread中的InputDispatcher，而InputDispatcher它会寻找一个最合适的窗口来处理输入事件，WMS是窗口的管理者，WMS会把所有窗口的信息更新到InputDispatcher中，这样InputDispatcher就可以将输入事件派发给合适的Window，Window就会把这个输入事件传给顶级View，然后就会涉及我们熟悉的事件分发机制。</p><p>我们来再来看在ViewRootImp的setView中调用mWindowSession.addToDisplay方法时传入的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">   mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//通过session与WMS建立通信,同时通过InputChannel接收输入事件回调</span></span><br><span class="line">     res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                                getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                                mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                                mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">         <span class="comment">//处理输入事件回调</span></span><br><span class="line">         mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel, Looper.myLooper());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个传入的mInputChannel参数，它实现了Parcelable接口，用于接受WMS返回来的输入事件。</p><p>它们之间的类图关系如下：</p><img src="/2019/03/22/Window,%20WindowManager和WindowManagerService之间的关系/window1.jpg" title="Window,WindowManager, WMS之间的关系"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面简单的介绍，我们知道Window是View的载体，我们想要对Window进行删除，添加，更新View就得通过WindowManager，WindowManager与WMS通过Session进行通信，具体的实现就交给了WMS处理，WMS会为每一个Window创建一个WindowState并管理它们，具体的渲染工作WMS就交给SurfaceFinger处理。本文所讨论的WMS系统相关结构如下：</p><img src="/2019/03/22/Window,%20WindowManager和WindowManagerService之间的关系/window2.jpg" title="WMS系统结构"><p>参考资料：</p><p>《Anddroid开发艺术探索》</p><p>《Android源码设计模式》</p><p><a href="http://liuwangshu.cn/tags/WindowManager/" target="_blank" rel="noopener">Android解析WindowManager</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上面3个名词在开发中经常听到，在Android开发中，Window是所有视图的载体，如Activity，Dialog和Toast的视图，我们想要对Window进行添加和删除就要通过WindowManager来操作，而WindowManager就是通过Binder与WindowManagerService进行跨进程通信，把具体的实现工作交给WindowManagerService（下面简称WMS）。下面分别介绍它们，理清它们的基本脉络。&lt;br&gt;
    
    </summary>
    
    
      <category term="Window机制" scheme="http://yoursite.com/categories/Window%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="window" scheme="http://yoursite.com/tags/window/"/>
    
      <category term="windowManager" scheme="http://yoursite.com/tags/windowManager/"/>
    
      <category term="WMS" scheme="http://yoursite.com/tags/WMS/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView之观察者模式</title>
    <link href="http://yoursite.com/2019/03/09/RecyclerView%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/09/RecyclerView之观察者模式/</id>
    <published>2019-03-09T09:39:00.000Z</published>
    <updated>2019-10-08T09:28:35.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RecyclerView是Android开发中的一个重要的模式，通常我们往RecyclerView添加数据时，都会调用Adapter的notifiyXX函数，这是为什么呢，今天我们就从源码来探究一下，对观察者模式不熟悉的读者，可以看一下这一篇博客<a href="https://blog.csdn.net/Rain_9155/article/details/83004247" target="_blank" rel="noopener">观察者模式</a>, RecyclerView在更新数据时也算是对观察者模式的一种应用。<br><a id="more"></a></p><pre><code>本文源码基于Android8.0, 相关源码位置如下frameworks/support/v7/recyclerview/src/android/support/v7/widget/RecyclerView.javaframeworks/base/core/java/android/database/Observable.java</code></pre><h2 id="Adapter-notifyDataSetChange"><a href="#Adapter-notifyDataSetChange" class="headerlink" title="Adapter.notifyDataSetChange()"></a>Adapter.notifyDataSetChange()</h2><p>我们来看一下我们平常可能使用到的notifyXX方法：<br><img src="/2019/03/09/RecyclerView之观察者模式/rv5.png" title="rv5"><br>可以看到，RecyclerView可ListView相比多了很多notifyItemXX方法，说明RecyclerView支持定向刷新，如果只有部分itemView数据发生变化，在使用ListView时我们没得选择只能使用notifyDataSetChange()方法来对整体itemView更新数据，但是在RecyclerView中，我们可以只对发生数据变化的itemView更新，当样也可以整体更新，而且相信大家现在在使用RecyclerView更新itemView时使用最多的方法还是Adapter.notifyDataSetChange()吧。那我们就以这个方法为例，该方法的源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notifyDataSetChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           mObservable.notifyChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个mObservable是声明在Adapter中的AdapterDataObservable对象，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>&lt;<span class="title">VH</span> <span class="keyword">extends</span> <span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdapterDataObservable mObservable = <span class="keyword">new</span> AdapterDataObservable();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而AdapterDataObservable定义在RecyclerView中，Adapter.notifyDataSetChange()调用了AdapterDataObservable.notifyChanged()方法，该方法源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterDataObservable</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">AdapterDataObserver</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mObservers.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            mObservers.get(i).onChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到该方法做的事情是遍历mObservers集合，然后逐个调用onChanged()方法，那么mObservers是什么东西？mObservers其实就是一个观察者列表，而mObservable就是一个被观察者，每个Adapter中只有一个被观察者，被观察者中有一个观察者列表，当有数据更新时，被观察者就会调用遍历调用注册到观察者列表中观察者的onChanged方法，来通知观察者更新数据。<br>mObservers其实是一个ArrayList，它定义在AdapterDataObservable的父类Observable中，Observable的定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ArrayList&lt;T&gt; mObservers = <span class="keyword">new</span> ArrayList&lt;T&gt;();<span class="comment">//观察者集合列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(T observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        mObservers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取消该观察者的注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterObserver</span><span class="params">(T observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        mObservers.remove(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消所有观察者的注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mObservers) &#123;</span><br><span class="line">            mObservers.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Observable中只有几个简单的方法，所以我们要向观察者列表中注册一个观察者，才能接受到更新通知，那么RecyclerView是怎么注册一个观察者的吗？其实是通过RecyclerView.setAdapter()方法实现的。</p><h2 id="RecyclerView-setAdapter"><a href="#RecyclerView-setAdapter" class="headerlink" title="RecyclerView.setAdapter()"></a>RecyclerView.setAdapter()</h2><p>我们每次使用RecyclerView都要调用setAdapter()设置一个Adapter，不然数据就无法展示，该方法的源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(@Nullable Adapter adapter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    setAdapterInternal(adapter, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在setAdapter又调用了setAdapterInternal(), 该方法相关源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAdapterInternal</span><span class="params">(@Nullable Adapter adapter, <span class="keyword">boolean</span> compatibleWithPrevious, <span class="keyword">boolean</span> removeAndRecycleViews)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、移除旧的Adapter，并注销观察者</span></span><br><span class="line">    <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAdapter.unregisterAdapterDataObserver(mObserver);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、compatibleWithPrevious为false，表示不使用旧的Adapter中ViewHolder，所以调用removeAndRecycleViews方法把ViewHolder旧的Adapter中的ViewHolder回收复用</span></span><br><span class="line">    <span class="keyword">if</span> (!compatibleWithPrevious || removeAndRecycleViews) &#123;</span><br><span class="line">        removeAndRecycleViews();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、更新Adapter并注册一个观察者</span></span><br><span class="line">    <span class="keyword">final</span> Adapter oldAdapter = mAdapter;</span><br><span class="line">    mAdapter = adapter;</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//注册一个观察者</span></span><br><span class="line">        adapter.registerAdapterDataObserver(mObserver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>setAdapterInternal()方法中就主要做了上面3件事，而且上面Adapter中调用的registerXX或unregisterXX最终调用mObservable的方法, 如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>&lt;<span class="title">VH</span> <span class="keyword">extends</span> <span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAdapterDataObserver</span><span class="params">(@NonNull AdapterDataObserver observer)</span> </span>&#123;</span><br><span class="line">        mObservable.registerObserver(observer);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterAdapterDataObserver</span><span class="params">(@NonNull AdapterDataObserver observer)</span> </span>&#123;</span><br><span class="line">        mObservable.unregisterObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这些方法的含义已经在上面讲解Observable时解释过了。那么在setAdapterInternal()中注册的观察者mObserver是什么呢？它其实就是一个RecyclerViewDataObserver类型，定义在RecyclerView中，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> <span class="keyword">implements</span> <span class="title">ScrollingView</span>, <span class="title">NestedScrollingChild2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RecyclerViewDataObserver mObserver = <span class="keyword">new</span> RecyclerViewDataObserver();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而RecyclerViewDataObserver是AdapterDataObserver的子类，它定义在RecyclerView中，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerViewDataObserver</span> <span class="keyword">extends</span> <span class="title">AdapterDataObserver</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (!mAdapterHelper.hasPendingUpdates()) &#123;</span><br><span class="line">                <span class="comment">//请求重新布局</span></span><br><span class="line">                requestLayout();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到我们熟悉的onChange方法，RecyclerViewDataObserver重写了它，当满足一定条件时就会重新布局从而从可以从Adapter中获取更新数据并绑定数据到itemView,达到更新itemView的目的。<br>所以RecyclerView在设置Adapter是时，会注册一个观察者mObserver到Adapter的被观察者mObservable中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们来整理一下这个过程，RecyclerView中有一个观察者mObserver，是RecyclerViewDataObserver类型，在RecyclerView设置Adapter时会把它注册到Adapter中，而Adapter中包含一个被观察者mObservable，是AdapterDataObservable类型，注册到Adapter中的观察最终会注册到mObservable的mObservers列表中，当我们手动调用Adapter的notifyXX函数时，notifyXX函数实际上会调用AdapterDataObservable的notifyXX函数，该函数会遍历所有观察者的onChange函数，在RecyclerViewDataObserver的onChange函数中会要求RecyclerView调用requestLayout()重新布局,更新用户界面。如图：<br><img src="/2019/03/09/RecyclerView之观察者模式/rv6.png" title="rv6"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;RecyclerView是Android开发中的一个重要的模式，通常我们往RecyclerView添加数据时，都会调用Adapter的notifiyXX函数，这是为什么呢，今天我们就从源码来探究一下，对观察者模式不熟悉的读者，可以看一下这一篇博客&lt;a href=&quot;https://blog.csdn.net/Rain_9155/article/details/83004247&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;观察者模式&lt;/a&gt;, RecyclerView在更新数据时也算是对观察者模式的一种应用。&lt;br&gt;
    
    </summary>
    
    
      <category term="recyclerView" scheme="http://yoursite.com/categories/recyclerView/"/>
    
    
      <category term="recyclerView" scheme="http://yoursite.com/tags/recyclerView/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView之缓存设计</title>
    <link href="http://yoursite.com/2019/03/08/RecyclerView%E4%B9%8B%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/03/08/RecyclerView之缓存设计/</id>
    <published>2019-03-08T06:56:50.000Z</published>
    <updated>2019-08-06T05:51:15.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一篇文章<a href="https://rain9155.github.io/2019/03/01/RecyclerView之布局设计" target="_blank" rel="noopener">RecyclerView之布局设计</a></li></ul><p>RecyclerView，见名之义，这个View代表了可循环使用的视图集合控件，封装了View的缓存逻辑判断，RecyclerView的基本单元是ViewHolder，里面有一个itemView代表了视图上的子View，所以RecyclerView的缓存基本单元也是ViewHolder。本文将从源码的角度来讲解RecyclerView的缓存设计。<br><a id="more"></a></p><pre><code>本文相关源码基于Android8.0，相关源码位置如下:frameworks/support/v7/recyclerview/src/android/support/v7/widget/RecyclerView.javaframeworks/support/v7/recyclerview/src/android/support/v7/widget/LinearLayoutManager.java</code></pre><h2 id="Recycler"><a href="#Recycler" class="headerlink" title="Recycler"></a>Recycler</h2><p>这里首先介绍一下Recycler，它定义在RecyclerView中，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Recycler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//缓存着在屏幕中显示的ViewHolder</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> ArrayList&lt;ViewHolder&gt;();<span class="comment">//缓存着已经滚动出屏幕的ViewHolder,即屏幕外的ViewHolder</span></span><br><span class="line">    RecycledViewPool mRecyclerPool;<span class="comment">//ViewHolder的缓存池，屏幕外缓存的mCachedViews已满时，会将ViewHolder缓存到RecycledViewPool中。</span></span><br><span class="line">    <span class="keyword">private</span> ViewCacheExtension mViewCacheExtension;<span class="comment">//自定义缓存，自己实现ViewCacheExtension类来实现缓存。</span></span><br><span class="line">    ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="keyword">null</span>;<span class="comment">//屏幕内缓存，缓存着数据已经改变的ViewHolder</span></span><br><span class="line">    <span class="keyword">int</span> mViewCacheMax = DEFAULT_CACHE_SIZE;<span class="comment">//mCachedViews默认缓存数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CACHE_SIZE = <span class="number">2</span>;<span class="comment">//默认缓存数量为2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mRequestedCacheMax = DEFAULT_CACHE_SIZE; <span class="comment">//可以设置mCachedViews的最大缓存数量，默认为2。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Recycler是RecyclerView的核心类，是RecyclerView的缓存实现类，它有着四级缓存：</p><ul><li>1、mAttachedScrap<br>当我们调用notifiXX函数重新布局时，在布局之前，LayoutManager会调用detachAndScrapAttachedViews(recycler)把在RecyclerView中显示的ViewHolder一个个的剥离下来,然后缓存在mAttachedScrap中，等布局时会先从mAttachedScrap查找，再把ViewHolder一个个的放回RecyclerView中去，而mAttachedScrap中的ViewHolder并不会参与回收复用，只是单纯的为了从RecyclerView中剥离下来，再重新放回RecyclerView，如果还有剩余的ViewHolder没有参加新布局，会从mAttachedScrap移到mCachedViews中。</li><li>2、mCachedViews<br>在RecyclerView滚动时，对于那些不在RecyclerView中显示的ViewHolder，LayoutManager会调用removeAndRecycleAllViews(recycler)把这些已经移除的ViewHolder缓存在mCacheViews中，它的默认大小是2，当它满了的时候，就会利用先进先出原则，把老的ViewHolder移到mRecyclerPool中。mCachedViews也不参与回收复用，它只是缓存最新被移除的ViewHolder。</li><li>3、mViewCacheExtension<br>自定义缓存实现，一般而言，我们不会自定义缓存实现，使用Recycler提供的3级缓存足够。</li><li>4、mRecyclerPool<br>其实真正参与回收复用的是mRecyclerPool，通过前面1、2可以知道，真正废弃的ViewHolder最终移到mRecyclerPool，当我们向RecyclerView申请一个HolderView来使用的时，如果在mAttachedScrap、mCachedViews匹配不到，即使他们中有ViewHolder也不会返回给我们使用，而是会到mRecyclerPool中去拿一个废弃的ViewHolder返回。mRecyclerPool内部维护了一个SparseArray，在mRecyclerPool中会根据每个ViewType把ViewHolder分别存储在不同的列表中，每个ViewType默认缓存5个ViewHolder。RecyclerViewPool大概结构如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RecycledViewPool</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_SCRAP = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrapData</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> mMaxScrap = DEFAULT_MAX_SCRAP;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        SparseArray&lt;ScrapData&gt; mScrap = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>而且RecyclerViewPool也可以是多个RecyclerView之间的ViewHolder的缓存池，只要通过RecyclerView.setRecycledViewPool(RecycledViewPool)设置同一个RecycledViewPool，设置时，不需要自己去new 一个 RecyclerViewPool，每个RecyclerView默认都有一个RecyclerViewPool，只需要通过mRecyclerView.getRecycledViewPool()获取。</p><p>所以我们从Recycler中获取一个ViewHolder时，是这样的顺序：mAttachedScrap -&gt; mCachedViews -&gt; mViewCacheExtension -&gt; mRecyclerPool,当上述步骤都找不到了，就会调用Adapter的creat函数创建一个ViewHolder。那这里为什么省略mChangedScrap不讲呢？因为mChangedScrap是跟RecyclerView的预布局有关，缓存着RecyclerView中数据改变过的ViewHolder，而预布局默认为false，一般是RecyclerView执行动画时才会为true，我们上一篇文章也没有讨论执行动画的时候的布局过程，所以这里就不分析mChangedScrap。</p><h2 id="Recycler-getViewForPosition"><a href="#Recycler-getViewForPosition" class="headerlink" title="Recycler.getViewForPosition()"></a>Recycler.getViewForPosition()</h2><p>在上篇文章中，提到在layoutChunk函数中，首先会调用LayoutState对象的next函数获取到一个itemView，然后布局这个itemView，我们来看LayoutState的next函数相关实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">next</span><span class="params">(RecyclerView.Recycler recycler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略了一个mScrapList，属于LayoutManager，跟执行动画时的缓存有关，这里不分析</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//这里才是核心，调用Recycler中的getViewForPosition获取itemView</span></span><br><span class="line">    <span class="keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">    <span class="comment">//把itemView索引移到下一个位置</span></span><br><span class="line">    mCurrentPosition += mItemDirection;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码实际是调用RecyclerView.Recycler对象的getViewForPosition方法获取itemView，而该函数最终会获取一个ViewHolder，从而返回ViewHolder中的itemView，我们来看该函数相关调用和实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getViewForPosition(position, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以看到最终返回的是ViewHolder中的itemView</span></span><br><span class="line">     <span class="keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个ViewHolder</span></span><br><span class="line"><span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun, <span class="keyword">long</span> deadlineNs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Recycler的getViewForPosition方法最终会调用到tryGetViewHolderForPositionByDeadline方法，tryGetViewHolderForPositionByDeadline方法的意图是通过给定的position从Recycler的scrap, cache，RecycledViewPool获取一个ViewHolder或者通过Adapter直接创建一个ViewHolder。我们来看tryGetViewHolderForPositionByDeadline方法相关源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数解释：</span></span><br><span class="line"><span class="comment">//position：要获得哪个位置的ViewHolder</span></span><br><span class="line"><span class="comment">//dryRun: 代表position的ViewHolder是否已经从scrap或cache列表中移除，这里为false，表示没有，因为布局函数layoutChildren中一定会调用detachAndScrapAttachedViews(recycler)函数，表示把ViewHolder放入scrap列表中</span></span><br><span class="line"><span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun, <span class="keyword">long</span> deadlineNs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略了跟预布局有关的mChangedScrap获取ViewHolder，mChangedScrap不属于常规缓存</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    ViewHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//1、第一次查找，通过position从scrap或hidden或cache中找ViewHolder</span></span><br><span class="line">         holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">            <span class="comment">//如果找到ViewHolder，检查ViewHolder的合法性</span></span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//检查ViewHolder的是否被移除，position是否越界等，如果检查通过返回true，失败返回false</span></span><br><span class="line">                <span class="keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;</span><br><span class="line">                    <span class="comment">//检查不通过</span></span><br><span class="line">                    <span class="comment">//上述讲过dryRun为false</span></span><br><span class="line">                    <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">                        <span class="comment">//设置这个ViewHolder为无效标志</span></span><br><span class="line">                        holder.addFlags(ViewHolder.FLAG_INVALID);</span><br><span class="line">                        <span class="comment">//把这个ViewHolder从scrap列表中移除</span></span><br><span class="line">                        <span class="keyword">if</span> (holder.isScrap()) &#123;</span><br><span class="line">                            removeDetachedView(holder.itemView, <span class="keyword">false</span>);</span><br><span class="line">                            holder.unScrap();</span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                        <span class="comment">//把这个ViewHolder放入cache列表中或mRecyclerPool中</span></span><br><span class="line">                        recycleViewHolderInternal(holder);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//置空不匹配的ViewHolder，进入下一步查找</span></span><br><span class="line">                    holder = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//检查通过了</span></span><br><span class="line">                    fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        <span class="comment">//这里可以看到我们熟悉的Adapter中的getItemViewType方法，重写此方法可以让RecyclerView显示多种type的itemView</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果mAdapter.hasStableIds()为true，就进入第2次查找，默认返回false</span></span><br><span class="line">         <span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">            <span class="comment">//2、第2次查找，根据ViewHolder的type和id从scrap或cached列表查找</span></span><br><span class="line">            holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                    type, dryRun);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123; <span class="comment">//找到了</span></span><br><span class="line">                <span class="comment">//更新ViewHolder的位置</span></span><br><span class="line">                holder.mPosition = offsetPosition;</span><br><span class="line">                fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3、第3次查找，从自定义缓存中查找，一般我们不会重写ViewCacheExtension</span></span><br><span class="line">            <span class="keyword">final</span> View view = mViewCacheExtension.getViewForPositionAndType(<span class="keyword">this</span>, position, type);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//4、第4次查找，从RecycledViewPool中查找，可以看到这里会根据type返回一个使用过的ViewHolder给你</span></span><br><span class="line">            holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;<span class="comment">//找到了</span></span><br><span class="line">                <span class="comment">//重置ViewHolder中的信息</span></span><br><span class="line">                holder.resetInternal();</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//前面的4次还找不到合适的ViewHolder，就重新创建一个</span></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">//...</span></span><br><span class="line">             <span class="comment">//5、这里会调用Adapter中的OnCreateViewHolder方法</span></span><br><span class="line">             holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">boolean</span> bound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//这里会根据情况调用Adapter中的OnBindViewHolder方法</span></span><br><span class="line">    <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        <span class="comment">//这里最终调用Adapter中的OnBindViewHolder方法</span></span><br><span class="line">        bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起来函数很长但是步骤还是很清晰的，我们一步步来看：</p><h3 id="注释1：getScrapOrHiddenOrCachedHolderForPosition"><a href="#注释1：getScrapOrHiddenOrCachedHolderForPosition" class="headerlink" title="注释1：getScrapOrHiddenOrCachedHolderForPosition()"></a>注释1：getScrapOrHiddenOrCachedHolderForPosition()</h3><p>注释1中通过position从scrap或hidden或cache中找ViewHolder，我们来看getScrapOrHiddenOrCachedHolderForPosition方法的关键源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">ViewHolder <span class="title">getScrapOrHiddenOrCachedHolderForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//1.1、第一次尝试，从mAttachedScrap找到一个精确，没有失效的ViewHolder并返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrapCount = mAttachedScrap.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scrapCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewHolder holder = mAttachedScrap.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position</span><br><span class="line">                &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved()))&#123;</span><br><span class="line">            <span class="comment">//标志这个ViewHolder是从mAttachedScrap取出并返回的</span></span><br><span class="line">            holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.2、第二次尝试，dryRun为false，从RecyclerView中隐藏的itemView中找，如果找到合适的View，就让它显示并把它从RecyclerView中剥离，然后根据这个View的LayoutParam获取ViewHolder，最后把这个ViewHolder放入mAttachedScrap并返回</span></span><br><span class="line">    <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">        View view = mChildHelper.findHiddenNonRemovedView(position);</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取ViewHolder</span></span><br><span class="line">            <span class="keyword">final</span> ViewHolder vh = getChildViewHolderInt(view);</span><br><span class="line">            <span class="comment">//显示这个View</span></span><br><span class="line">            mChildHelper.unhide(view);</span><br><span class="line">            <span class="comment">//从RecyclerView剥离这个View</span></span><br><span class="line">            mChildHelper.detachViewFromParent(layoutIndex);</span><br><span class="line">            <span class="comment">//把这个ViewHolder放入mAttachedScrap</span></span><br><span class="line">            scrapView(view);</span><br><span class="line">            vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP</span><br><span class="line">                    | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">            <span class="comment">//返回</span></span><br><span class="line">            <span class="keyword">return</span> vh;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.3、第三次尝试，从mCachedViews找到没有失效的ViewHolder并返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = mCachedViews.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cacheSize; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewHolder holder = mCachedViews.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">                mCachedViews.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到注释1的第一次查找，里面分为3步：</p><ul><li>1.1、从mAttachedScrap找。</li><li>1.2、如果上一步没有得到合适的缓存，从HiddenViews找。</li><li>1.3、如果上一步没有得到合适的缓存，从mCachedViews找。</li></ul><p>从上面3个步骤之一找到，就返回ViewHolder，然后检查ViewHolder的有效性，如果无效，则从mAttachedScrap中移除，并加入到mCacheViews或者mRecyclerPool中，并且将ViewHolder置为null，走到下一步。</p><h3 id="注释2：getScrapOrCachedViewForId"><a href="#注释2：getScrapOrCachedViewForId" class="headerlink" title="注释2：getScrapOrCachedViewForId()"></a>注释2：getScrapOrCachedViewForId()</h3><p>下一步就是注释2，如果我们通过Adapter.setHasStableIds(boolean)设置为true，就会进入,里面根据ViewHolder的type和id从scrap或cached列表查找ViewHolder，我们来看一下相关源码该方法的相关源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ViewHolder <span class="title">getScrapOrCachedViewForId</span><span class="params">(<span class="keyword">long</span> id, <span class="keyword">int</span> type, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1、第一次尝试，从mAttachedScrap找到一个id相同并且没有从mAttachedScrap取出并返回过的ViewHolder，还要type相同的ViewHolder返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mAttachedScrap.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewHolder holder = mAttachedScrap.get(i);</span><br><span class="line">        <span class="keyword">if</span> (holder.getItemId() == id &amp;&amp; !holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">            <span class="comment">//id相同type相同</span></span><br><span class="line">            <span class="keyword">if</span> (type == holder.getItemViewType()) &#123;</span><br><span class="line">                holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">                <span class="comment">//id相同但type不同</span></span><br><span class="line">                <span class="comment">//从mAttachedScrap移除这个ViewHolder</span></span><br><span class="line">                mAttachedScrap.remove(i);</span><br><span class="line">                removeDetachedView(holder.itemView, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//把这个ViewHolder放入caches或RecyclerViewPool</span></span><br><span class="line">                quickRecycleScrapView(holder.itemView);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.2、第2次尝试，从mCachedViews中找到一个id相同并且type相同的ViewHolder返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = mCachedViews.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cacheSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewHolder holder = mCachedViews.get(i);</span><br><span class="line">        <span class="keyword">if</span> (holder.getItemId() == id) &#123;</span><br><span class="line">            <span class="comment">//id相同并且type相同</span></span><br><span class="line">            <span class="keyword">if</span> (type == holder.getItemViewType()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">                    <span class="comment">//从cache中移除</span></span><br><span class="line">                    mCachedViews.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">                <span class="comment">//id相同type不相同</span></span><br><span class="line">                <span class="comment">//把这个ViewHolder从cache中移除并放入RecyclerViewPool中</span></span><br><span class="line">                recycleCachedViewAt(i);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到注释2的第二次查找，里面分为2步：</p><ul><li>2.1、从mAttachedScrap找。</li><li>2.2、如果上一步没有得到合适的缓存，从mCachedViews找。</li></ul><p>第二次查找跟第一次不同的是，它是通过Adapter.getItemId(position)获得该位置ViewHolder的id，来查找ViewHolder，我们可以重写Adapter.getItemId(position)返回每个position的ViewHolder的id，默认返回RecyclerView.NO_ID。从上面2个步骤之一找到，就返回ViewHolder，如果找不到就进入下一步。</p><h3 id="注释3：mViewCacheExtension"><a href="#注释3：mViewCacheExtension" class="headerlink" title="注释3：mViewCacheExtension"></a>注释3：mViewCacheExtension</h3><p>注释3的第三次查找是从自定义缓存中查找，这个没什么好说，可以直接到下一步。</p><h4 id="注释4："><a href="#注释4：" class="headerlink" title="注释4："></a>注释4：</h4><p>下一步就是第4次查找，从RecyclerdViewPool中查找，可以看到这里先使用getRecyclerViewPool获得Recycler中的RecyclerViewPool，然后调用RecyclerViewPool的getRecycledView(type)根据type获取一个ViewHolder，我们来看该方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">getRecycledView</span><span class="params">(<span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据type取出ScrapData</span></span><br><span class="line">    <span class="keyword">final</span> ScrapData scrapData = mScrap.get(viewType);</span><br><span class="line">    <span class="keyword">if</span> (scrapData != <span class="keyword">null</span> &amp;&amp; !scrapData.mScrapHeap.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//取出ScrapData中的ViewHolder列表</span></span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;</span><br><span class="line">        <span class="comment">//返回一个ViewHolder并从pool中删除</span></span><br><span class="line">        <span class="keyword">return</span> scrapHeap.remove(scrapHeap.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mScrap是SparseArray类型，它会根据type把ViewHolder存放在不同ScrapData中，ScrapData中有一个mScrapHeap，是ArrayList类型，它会存放RecyclerViewPool中放进来的ViewHolder。所以上面这个方法首先会根据type取出ScrapData，然后取出mScrapHeap，如果mScrapHeap有元素，就返回并删除，然后重置这个ViewHolder让它复用，如果没有就进入下一步。</p><h3 id="注释5：Adapter-createViewHolder"><a href="#注释5：Adapter-createViewHolder" class="headerlink" title="注释5：Adapter.createViewHolder()"></a>注释5：Adapter.createViewHolder()</h3><p>既然缓存中没有就创建一个，该方法的相关源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> VH <span class="title">createViewHolder</span><span class="params">(@NonNull ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> VH holder = onCreateViewHolder(parent, viewType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，调用了我们熟悉的onCreateViewHolder方法，该方法就是用来创建ViewHolder。</p><pre><code>ps：从上面知道当缓存中不能提供ViewHolder就会调用adapter的onCreateViewHolder创建一个，那么我们同样熟悉的OnBindViewHolder方法是什么时候执行的呢？bind方法是用来绑定数据，对于从mAttachedScrap和mCachedViews中拿出来的ViewHolder是不用重新bind的，而对于从mRecyclerPool拿出和通过Create方法创建的ViewHolder是需要重新bind的，所以前面说RecyclerViewPool才是真正用来回收复用ViewHolder的。</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文中源码角度简单的分析RecyclerView布局一个itemView时是怎样通过Recycler来获取一个ViewHolder，从而获取itemView，如图：<br><img src="/2019/03/08/RecyclerView之缓存设计/rv4.png" title="rv"><br>准确的来说，Recycler是RecyclerView的itemView的提供者和管理者，它在内部封装了RecyclerView的缓存设计实现，在RecyclerView中有着四级缓存：AttachedScrap,mCacheViews,ViewCacheExtension,RecycledViewPool，正因为这样RecyclerView在使用的时候效率更好。</p><p>参考文章:</p><p><a href="https://blog.csdn.net/feather_wch/article/details/81613313#观察者模式" target="_blank" rel="noopener">RecyclerView和ListView原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一篇文章&lt;a href=&quot;https://rain9155.github.io/2019/03/01/RecyclerView之布局设计&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RecyclerView之布局设计&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RecyclerView，见名之义，这个View代表了可循环使用的视图集合控件，封装了View的缓存逻辑判断，RecyclerView的基本单元是ViewHolder，里面有一个itemView代表了视图上的子View，所以RecyclerView的缓存基本单元也是ViewHolder。本文将从源码的角度来讲解RecyclerView的缓存设计。&lt;br&gt;
    
    </summary>
    
    
      <category term="recyclerView" scheme="http://yoursite.com/categories/recyclerView/"/>
    
    
      <category term="recyclerView" scheme="http://yoursite.com/tags/recyclerView/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView之布局设计</title>
    <link href="http://yoursite.com/2019/03/01/RecyclerView%E4%B9%8B%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/03/01/RecyclerView之布局设计/</id>
    <published>2019-03-01T07:10:00.000Z</published>
    <updated>2019-10-08T09:28:23.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RecyclerView功能强大，自推出以来受到了无数人的喜爱，它可以通过一个LayoutManager将一个RecyclerView显示为不同的样式，例如ListView、GridView样式、瀑布流样式，所以加深对于RecyclerView的学习对于开发有很重要的意义。关于RecyclerView如何使用网上有很多文章，本篇文章从源码讲解RecyclerView如何通过layoutManager来进行布局。<br><a id="more"></a></p><pre><code>本文相关源码基于Android8.0，相关源码位置如下:frameworks/support/v7/recyclerview/src/android/support/v7/widget/RecyclerView.javaframeworks/support/v7/recyclerview/src/android/support/v7/widget/LinearLayoutManager.java</code></pre><h2 id="RecyclerView-onLayout"><a href="#RecyclerView-onLayout" class="headerlink" title="RecyclerView.onLayout()"></a>RecyclerView.onLayout()</h2><p>Android中每一个控件从它被定义到xml布局文件到呈现在屏幕上都要经过onMeasure -&gt; onLayout -&gt; onDraw 三个阶段，RecyclerView同样不例外，它的布局在OnLayout函数中进行，该方法相关源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到该方法只是简单的调用了dispatchLayout方法,并记录了是第一次布局，dispatchLayout()相关源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、检查是否设置了Adapter和LayoutManager</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//2、RecyclerView的布局分3步，即dispatchLayoutStep1()，dispatchLayoutStep2()，dispatchLayoutStep3()，下面分情况进行dispatchLayoutStep1()，dispatchLayoutStep2()</span></span><br><span class="line">        <span class="comment">//2.1、没有执行过布局流程，执行 dispatchLayoutStep1()， dispatchLayoutStep2()</span></span><br><span class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        <span class="comment">//2.2、已经执行过布局流程，但是因为数据变化或布局大小发生改变，重新执行 dispatchLayoutStep2()</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()</span><br><span class="line">                || mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        <span class="comment">//2.3、已经执行过布局流程并且数据和布局大小也确定了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置RecyclerView的宽高为精确模式（即MeasureSpecMode == MeasureSpec.EXACTLY）</span></span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、RecyclerView的布局第3步 dispatchLayoutStep3()</span></span><br><span class="line">        dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面源码我分3部分解释，首先注释1，没有设置RecyclerView的Adapter和LayoutManager直接return，这也解释了为什么我们平时忘记设置它们时RecyclerView会显示不出数据。<br>然后注释2、3，这两部分一起讲，因为RecyclerView的布局过程分为3步：dispatchLayoutStep1，dispatchLayoutStep2和dispatchLayoutStep3。在讲解之前先讲解mState.mLayoutStep，mState是State类型用于保存RecyclerView的状态，mLayouStep定义在State中，有三种取值分别代表了布局过程的3个步骤，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RecyclerView.State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STEP_START = <span class="number">1</span>;           <span class="comment">//还未执行dispatchLayoutStep1()，初始步骤</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STEP_LAYOUT = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;     <span class="comment">//已经执行了dispatchLayoutStep1()或dispatchLayoutStep2()，布局步骤</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STEP_ANIMATIONS = <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">//已经执行dispatchLayoutStep2()，动画步骤</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">int</span> mLayoutStep = STEP_START;</span><br></pre></td></tr></table></figure></p><p>可以看到mLayoutStep默认是STEP_START取值，下面我们简单分析RecyclerView的布局过程3步分别做了什么，首先dispatchLayoutStep1()的相关源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保dispatchLayoutStep1()还未被执行过</span></span><br><span class="line">    mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//1、处理Adapter数据更新的问题，计算需要运行的动画类型</span></span><br><span class="line">    processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">    <span class="comment">//2、存储关于View的一些状态和信息</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//3、 如果有必要，会进行预言性的布局，并且保存相关信息。</span></span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mState.mRunPredictiveAnimations)&#123;</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新mLayoutStep的值，进入布局步骤</span></span><br><span class="line">     mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>省略了很多东西，dispatchLayoutStep1()主要是来存储当前子View的状态并确定是否要执行动画、如果过有必要，会进行预言性的布局，并且保存相关信息，本文重点不在此，然后来看看dispatchLayoutStep2()，相关源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法执行期间不能要求RequestLayout()</span></span><br><span class="line">        startInterceptRequestLayout();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//确保已经执行了dispatchLayoutStep1()或dispatchLayoutStep2(), 从这里可以看出dispatchLayoutStep2()可能会被多次执行</span></span><br><span class="line">        mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">        <span class="comment">//1、设置好初始状态</span></span><br><span class="line">        mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">        mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line">        mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//2、调用布局管理器去布局（布局核心方法）</span></span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState)；</span><br><span class="line">        <span class="comment">// 动画相关状态</span></span><br><span class="line">        mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//更新mLayoutStep值，进入动画步骤</span></span><br><span class="line">        mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">        </span><br><span class="line">        stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dispatchLayoutStep2()大部分源码都在此，它才是本文的重点，它在里面调用 mLayout.onLayoutChildren(）将布局的具体策略交给了LayoutManager，下面我们会重点分析这个函数，最后我们再来看看dispatchLayoutStep3()，相关源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保已经执行dispatchLayoutStep2()</span></span><br><span class="line">    mState.assertLayoutStep(State.STEP_ANIMATIONS);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//重置mLayoutStep的值</span></span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="comment">//1、触发动画</span></span><br><span class="line">    <span class="keyword">if</span>(mState.mRunSimpleAnimations)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、保存View的一些信息</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//3、清除状态和清除无用的信息</span></span><br><span class="line">    mViewInfoStore.clear()</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>省略了大量代码，dispatchLayoutStep3()同样跟动画相关，它主要保存关于Views的所有信息、触发动画、做必要的清理操作，它也不是本文的重点。<br>可以看到mLayoutStep与dispatchLayoutStep()对应关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STEP_START --&gt;  dispatchLayoutStep1()</span><br><span class="line">STEP_LAYOUT --&gt; dispatchLayoutStep2()</span><br><span class="line">STEP_ANIMATIONS --&gt; dispatchLayoutStep2(), dispatchLayoutStep3()</span><br></pre></td></tr></table></figure></p><p>讲完3个步骤我们在回到RecyclerView.dispatchLayout()，RecyclerView的布局入口OnLayout()会执行dispatchLayout()，dispatchLayout（）会根据RecyclerView的布局步骤执行dispatchLayoutStep1、2、3。那么为什么dispatchLayout（）中会分2.1, 2.2, 2.3条件执行dispatchLayoutStep1、2，而不直接按顺序dispatchLayoutStep1、2、3执行布局流程？这是因为在RecyclerView的onMeasure中，dispatchLayoutStep1、2就已经有可能因为RecyclerView自动测量模式中由于测量出来的宽高不精确而被调用，相应代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//设置了layoutaManager后，layoutaManager默认开启自动测量模式</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line">       <span class="comment">//首先执行LayoutManager的onMeasure方法,里面会调用RecyclerView的onMeasure方法测量自身width和height</span></span><br><span class="line">       mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">       <span class="comment">//Measure过后检查RecyclerView的width和height是否是精确值</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> measureSpecModeIsExactly = widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">       <span class="comment">//如果RecyclerView的width和height是精确值，就跳过下面步骤</span></span><br><span class="line">       <span class="keyword">if</span> (measureSpecModeIsExactly || mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果RecyclerView的width和height不是精确值，则会进行下面步骤</span></span><br><span class="line">       <span class="comment">//1、dispatchLayoutStep1()还未被执行过，执行 dispatchLayoutStep1()</span></span><br><span class="line">       <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">           dispatchLayoutStep1();</span><br><span class="line">       &#125;</span><br><span class="line">       mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">       mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//2、执行dispatchLayoutStep2()进行布局</span></span><br><span class="line">       dispatchLayoutStep2();</span><br><span class="line">       <span class="comment">//3、布局过程结束，该方法里面会根据childView中的边界信息计算并设置RecyclerView长宽的测量值</span></span><br><span class="line">       mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">       <span class="comment">//下面省略一些代码，下面还会再次检查，如果RecyclerView的宽高还不是精确值或至少有一个childView的宽高还不是精确值，还会再次执行执行dispatchLayoutStep2()进行布局</span></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RecyclerView是一个ViewGroup，如果自身的宽高设置了warp_content必须先调用dispatchLayoutStep2()布局childView后才能测量出准确宽高。所以我们再看回dispatchLayout()中的3个判断:</p><ul><li>dispatchLayout()中2.1条件：如果mLayoutStep == State.STEP_START，证明OnMeasure中还没有进行过布局，如果mLayoutStep ！= State.STEP_START，证明OnMeasure中进行过布局了，直接跳到2.3条件，不用重复布局，直接使用直接使用之前数据设置RecyclerView的宽高为精确模式。</li><li><p>dispatchLayout()中2.2条件：2.1条件不成立时为什么直接跳到2.3条件不到2.2条件，因为上述条件基于RecyclerView正常的测量布局绘制到呈现在屏幕的过程，如果在这之后你对RecyclerView调用了notifXX函数，就会造成数据变化从而要求重新布局（requestLayout()函数调用），此时2.2条件就会成立，RecyclerView会调用dispatchLayoutStep2()重新布局。</p></li><li><p>dispatchLayout()中2.3条件：2.1条件中分析过了。</p></li></ul><p>3个判断后，最终一定会调用dispatchLayoutStep3()。至此分析完RecyclerView的onLayout()。</p><h2 id="RecyclerView-dispatchLayoutStep2-gt-LayoutManager-onLayoutChildren（）"><a href="#RecyclerView-dispatchLayoutStep2-gt-LayoutManager-onLayoutChildren（）" class="headerlink" title="RecyclerView.dispatchLayoutStep2() -&gt; LayoutManager.onLayoutChildren（）"></a>RecyclerView.dispatchLayoutStep2() -&gt; LayoutManager.onLayoutChildren（）</h2><p>RecyclerView真正布局的进行就是在LayoutManager.onLayoutChildren（）中进行，LayoutManager的onLayoutChildren()的实现在LayoutManager的三个子类中：LinearLayoutManager、GridLayoutManager、StaggeredGridLayoutMnager，分别对应3种不同的布局样式。这里以LinearLayoutManager中的实现为例，下面是该函数在LinearLayoutManager实现中的相关源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码很长，这里先抛出它的主要步骤：</span></span><br><span class="line"><span class="comment">//1、通过检查childView和其他变量，找出锚点的坐标（coordinate）和位置（position），并把锚点信息设置到AnchorInfo</span></span><br><span class="line"><span class="comment">//2、根据锚点向俩边填充</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里还讲一下下面出现End和Start的方法或字段的意思：</span></span><br><span class="line"><span class="comment">//如果LinearLayoutManager的Orientation是VERTICAL方向，End指屏幕的最下面（即Bottom），Start指屏幕的最上面(即Top)</span></span><br><span class="line"><span class="comment">//如果LinearLayoutManager的Orientation是HORIZONTAL方向，End指屏幕的最左边（即Left），Start指屏幕的最右边(即Right)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//解析布局方向，设置mShouldReverseLayout的值，它是一个Boolean类型，false表示LinearLayoutManager的Orientation是VERTICAL方向或者LinearLayoutManager的Orientation是HORIZONTAL方向并且你在manifest中没有设置RTL布局，true表示LinearLayoutManager的Orientation是HORIZONTAL方向并且你在manifest中设置了RTL布局</span></span><br><span class="line">    resolveShouldLayoutReverse();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//根据mStackFromEnd（表示从End开始填充itemView，默认是false）和mShouldReverseLayout决定mLayoutFromEnd的值，mLayoutFromEnd表示itemView从End开始布局还是从Start开始布局，从Start开始布局为false 从End开始布局是为true，这里一般都为false，即从Start到End开始布局</span></span><br><span class="line">    mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1、计算AnchorInfo的信息，即找出锚点的position和coordinate</span></span><br><span class="line">    updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//从End到Start开始布局，这里省略不讲，原理和从Start到End开始布局一样</span></span><br><span class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//这里我们只讨论从Start到End开始布局</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//更新LayoutState，确定从锚点到RecyclerView底部有多少可用空间</span></span><br><span class="line">        updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra = extraForEnd;</span><br><span class="line">        <span class="comment">//2.1、第一次填充itemView，从锚点向底部填充</span></span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        endOffset = mLayoutState.mOffset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lastElement = mLayoutState.mCurrentPosition;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            extraForStart += mLayoutState.mAvailable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新LayoutState，确定从锚点到RecyclerView顶部有多少可用空间</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra = extraForStart;</span><br><span class="line">        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</span><br><span class="line">        <span class="comment">//2.2、第二次填充itemView，从锚点向顶部填充</span></span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        startOffset = mLayoutState.mOffset;</span><br><span class="line">        <span class="comment">//如果屏幕上还有剩余的空间</span></span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            extraForEnd = mLayoutState.mAvailable;</span><br><span class="line">            updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">            mLayoutState.mExtra = extraForEnd;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            endOffset = mLayoutState.mOffset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>onLayoutChildren方法有接近200行代码，但怎么也逃不出注释的2步，首先确定锚点（大部分情况下锚点就是RecyclerView上的itemView），并设置锚点的信息AnchorInfo。它定义在LinearLayoutManager中，有几个关键的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnchorInfo</span> </span>&#123;</span><br><span class="line">        OrientationHelper mOrientationHelper;<span class="comment">//根据LinearLayoutManager的布局方向来测量itemView位置信息的帮助类，当你调用LinearLayoutManager的setOrientation(int orientation)方法时，LinearLayoutManager会根据不同orientation创建不同的OrientationHelper实现并设置给mOrientation属性</span></span><br><span class="line">        <span class="keyword">int</span> mPosition;<span class="comment">//锚点在Adapter中的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> mCoordinate;<span class="comment">//锚点相对于LinearLayoutManager的布局方向在屏幕上的坐标，如果是VERTICAL方向，代表y轴偏移量，如果是HORIZONTAL方向，代表x轴偏移量</span></span><br><span class="line">        <span class="keyword">boolean</span> mLayoutFromEnd;<span class="comment">//上面解释过了</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么它是怎么确定锚点信息的？我们来看注释1 updateAnchorInfoForLayout方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateAnchorInfoForLayout</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="function"><span class="params">            AnchorInfo anchorInfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、如果屏幕上有itemView并且RecyclerView要滚动到某个itemView，则以这个itemView为锚点</span></span><br><span class="line">    <span class="keyword">if</span> (updateAnchorFromPendingData(state, anchorInfo)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、如果屏幕上有itemView,则根据anchorInfo.mLayoutFromEnd找出最接近End或Start位置的itemView为锚点</span></span><br><span class="line">    <span class="keyword">if</span> (updateAnchorFromChildren(recycler, state, anchorInfo)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、如果屏幕上没有itemView，则根据anchorInfo.mLayoutFromEnd和RecyclerView的padding来决定锚点coordinate和mStackFormEnd决定锚点的position</span></span><br><span class="line">    anchorInfo.assignCoordinateFromPadding();</span><br><span class="line">    anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于里面的俩个updataAnchorFormXX函数就不展开了，对于情况1一般是我们滚动了RecyclerView的itemView或调用了RecyclerView的scrolltoXX函数，对于情况2一般是我们itemView已经加载到屏幕上了并且此时我们调用notifiXX函数来刷新或增删itemView，而情况3就是我们现在讨论的情况，RecyclerView加载到屏幕上，此时还没有布局itemView。我们点进AnchorInfo的assignCoordinateFromPadding()看看干了什么，相关源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">assignCoordinateFromPadding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCoordinate = mLayoutFromEnd ? mOrientationHelper.getEndAfterPadding() :     mOrientationHelper.getStartAfterPadding();</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//下面只给出LinearLayoutManager的Orientation为VERTICAL方向的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEndAfterPadding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLayoutManager.getHeight() - mLayoutManager.getPaddingBottom();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStartAfterPadding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLayoutManager.getPaddingLeft();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到如果此时RecyclerView中没有itemView并且LinearLayoutManager的布局方向为VERTICAL和mLayoutFromEnd值为false：anchorInfo的mCoordinate就是RecyclerView的paddingLeft，anchorInfo的position就是0（锚点为RecyclerView左上角的位置）。<br><img src="/2019/03/01/RecyclerView之布局设计/rv1.png" title="图一"></p><p>我们回到onlayoutChildern方法，确定了锚点后，然后就要根据AnchorInfo开始填充itemView，在开始填充之前，LinearLayoutManager会用LayoutState暂时保存一些布局信息，它定义在LinearLayoutManager中，有几个关键属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mAvailable;<span class="comment">//表示当前的布局方向中，RecyclerView中要用于填充itemView的可用空间大小</span></span><br><span class="line">    <span class="keyword">int</span> mOffset;<span class="comment">//表示当前的布局方向中，在RecyclerView中距离锚点的位置偏移量</span></span><br><span class="line">    <span class="keyword">int</span> mExtra = <span class="number">0</span>;<span class="comment">//表示自己设置的额外布局的范围，一般不会设置</span></span><br><span class="line">    <span class="keyword">int</span> mLayoutDirection;<span class="comment">//表示布局往哪个方向填充，俩个取值：LAYOUT_START为向RecyclerView顶部，LAYOUT_END为向底部</span></span><br><span class="line">    <span class="keyword">int</span> mCurrentPosition;<span class="comment">//表示当前锚点在Adapter中的索引，可用它获得下一个itemView的索引</span></span><br><span class="line">    <span class="keyword">int</span> mItemDirection;<span class="comment">//决定由mCurrentPosition获得下一个itemView的索引时是+1还是-1，俩个取值：ITEM_DIRECTION_HEAD表示索引-1，ITEM_DIRECTION_TAIL表示索引+1</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>updateLayoutStateToFillEnd函数会在向下填充前更新layoutState的值，相关源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateLayoutStateToFillEnd</span><span class="params">(AnchorInfo anchorInfo)</span> </span>&#123;</span><br><span class="line">        updateLayoutStateToFillEnd(anchorInfo.mPosition, anchorInfo.mCoordinate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateLayoutStateToFillEnd</span><span class="params">(<span class="keyword">int</span> itemPosition, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//下面基于在当前讨论的情景中：</span></span><br><span class="line">    <span class="comment">//这里可用布局空间mLayoutState.mAvailable就是RecyclerView的高度</span></span><br><span class="line">    mLayoutState.mAvailable = mOrientationHelper.getEndAfterPadding() - offset;</span><br><span class="line">    <span class="comment">//这里为LayoutState.ITEM_DIRECTION_TAIL，索引+1</span></span><br><span class="line">    mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD :</span><br><span class="line">            LayoutState.ITEM_DIRECTION_TAIL;</span><br><span class="line">    <span class="comment">//当前锚点索引</span></span><br><span class="line">    mLayoutState.mCurrentPosition = itemPosition;</span><br><span class="line">    <span class="comment">//这里为向RecyclerView底部填充</span></span><br><span class="line">    mLayoutState.mLayoutDirection = LayoutState.LAYOUT_END;</span><br><span class="line">    <span class="comment">//这里offet为0</span></span><br><span class="line">    mLayoutState.mOffset = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>准备好layoutState后，就调用fill方法进行填充itemView，核心源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前面讲过，表示可用布局空间大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> start = layoutState.mAvailable;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 1、计算剩余可用的填充空间，可用布局空间加上额外布局空间</span></span><br><span class="line">    <span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">    <span class="comment">//用于记录每一次while循环的填充一个itemView后的结果</span></span><br><span class="line">    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;</span><br><span class="line">    <span class="comment">//2、while判断条件，屏幕还有剩余可用空间并且还有数据就继续执行</span></span><br><span class="line">    <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">        <span class="comment">//重置LayoutChunkResult</span></span><br><span class="line">        layoutChunkResult.resetInternal();</span><br><span class="line">        <span class="comment">//3、循环调用layoutChunk方法一个一个的填充itemView，里面会根据LinearLayoutmanager的orientation方向布局itemView（布局子View的核心方法）</span></span><br><span class="line">        layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">        <span class="keyword">if</span> (layoutChunkResult.mFinished) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算填充一次itemView消耗了多少空间，或者说计算距离锚点的偏移量</span></span><br><span class="line">        layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</span><br><span class="line">        <span class="comment">//4、如果layoutChunkResult没有要求忽略这次消耗或这次布局的不是ScrapView或我们不是在做预布局，就更新可填充空间的大小</span></span><br><span class="line">        <span class="keyword">if</span> (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != <span class="keyword">null</span></span><br><span class="line">                    || !state.isPreLayout()) &#123;</span><br><span class="line">                layoutState.mAvailable -= layoutChunkResult.mConsumed;</span><br><span class="line">                remainingSpace -= layoutChunkResult.mConsumed;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//下面省略的是，如果是因滚动引起的布局，会通过判断滑动后view是否滑出边界决定是否回收View</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填充完成，修改起始位置，即填充到哪个位置</span></span><br><span class="line">    <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的注释很详细，大概流程就是在while循环中根据剩余可用空间不断的调用layoutChunk（）函数进行布局itemView，layoutChunk方法会在里面根据RecyclerView的缓存机制获取一个View从而把它填充到RecyclerView中去，下面继续来看layoutChunk方法相关源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,  LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、获取一个View</span></span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result.mFinished = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) view.getLayoutParams();</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="comment">//2、测量itemView</span></span><br><span class="line">   measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="comment">//3、计算该itemView消耗的高度或宽度</span></span><br><span class="line">   result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);</span><br><span class="line">   <span class="keyword">int</span> left, top, right, bottom;</span><br><span class="line">   <span class="comment">//4、按竖直方向布局，计算itemView的上下左右布局</span></span><br><span class="line">   <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLayoutRTL()) &#123;</span><br><span class="line">            right = getWidth() - getPaddingRight();</span><br><span class="line">            left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = getPaddingLeft();</span><br><span class="line">            right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</span><br><span class="line">            bottom = layoutState.mOffset;</span><br><span class="line">            top = layoutState.mOffset - result.mConsumed;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            top = layoutState.mOffset;</span><br><span class="line">            bottom = layoutState.mOffset + result.mConsumed;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//水平布局的计算方式</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5、布局itemView</span></span><br><span class="line">    layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">    <span class="comment">//消耗可用布局空间如果itemView没有被移除或没有改变</span></span><br><span class="line">    <span class="keyword">if</span> (params.isItemRemoved() || params.isItemChanged()) &#123;</span><br><span class="line">        result.mIgnoreConsumed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在layoutChunk方法中首先从layoutState中根据mCurrentPosition获取itemView，然后获取itemView的布局参数，并且根据布局方式(横向或纵向)计算出itemView的上下左右布局，最后调用layoutDecoratedWithMargins方法实现布局itemView，layoutDecoratedWithMargins方法定义在LayoutManger中，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layoutDecoratedWithMargins</span><span class="params">(@NonNull View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right,  <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">    <span class="keyword">final</span> Rect insets = lp.mDecorInsets;</span><br><span class="line">    child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,</span><br><span class="line">right - insets.right - lp.rightMargin,</span><br><span class="line">            bottom - insets.bottom - lp.bottomMargin);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，只是调用了itemView的layout函数将itemView布局到具体的位置。</p><p>我们再回到onlayoutChildern方法，按照上面图一，我们已经填充了下面，但是上面是不用填充的，因为没有可用空间，所以注释2.2基本下是不会走的了。而fill towaards Start步骤和fill towards End差不多。那么为什么RecyclerView进行两次填充呢？因为RecyclerView理想的锚点如下图：<br><img src="/2019/03/01/RecyclerView之布局设计/rv2.png" title="图二"></p><p>上面是RecyclerView的方向为VERTICAL的情况，当为HORIZONTAL方向的时候填充算法是不变的。但我们一般是图一的情况，从上往下填充。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一图胜千言，下图是LayoutManager循环布局所有的itemView。<br><img src="/2019/03/01/RecyclerView之布局设计/rv3.png" title="图三"><br>可以看到RecyclerView将布局的职责分离到LayoutManager中，使得RecyclerView更加灵活，我们也可以自定义自己的LayoutManger，实现自己想要的布局。可以看到RecyclerView具有很强大的扩展性，所以深入学习这个控件是很有必要的。能看到这里的都是有毅力的人，本文只是RecyclerView学习的第一篇，以后会继续分析RecyclerView的缓存设计。</p><p>参考资料：</p><p>《Android源码设计与分析》</p><p><a href="https://blog.csdn.net/feather_wch/article/details/81613313#观察者模式" target="_blank" rel="noopener">RecyclerView和ListView原理</a></p><p><a href="https://www.jianshu.com/p/898479f103b6" target="_blank" rel="noopener">RecyclerView源码分析(三)–布局流程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;RecyclerView功能强大，自推出以来受到了无数人的喜爱，它可以通过一个LayoutManager将一个RecyclerView显示为不同的样式，例如ListView、GridView样式、瀑布流样式，所以加深对于RecyclerView的学习对于开发有很重要的意义。关于RecyclerView如何使用网上有很多文章，本篇文章从源码讲解RecyclerView如何通过layoutManager来进行布局。&lt;br&gt;
    
    </summary>
    
    
      <category term="recyclerView" scheme="http://yoursite.com/categories/recyclerView/"/>
    
    
      <category term="recyclerView" scheme="http://yoursite.com/tags/recyclerView/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal解析</title>
    <link href="http://yoursite.com/2019/02/21/ThreadLocal%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/02/21/ThreadLocal解析/</id>
    <published>2019-02-21T05:55:50.000Z</published>
    <updated>2019-10-08T09:26:24.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究<a href="https://rain9155.github.io/2019/02/21/Android消息机制java层" target="_blank" rel="noopener">Android的消息机制</a>时遇到了一个疑问:<strong>在不同线程中调用 Looper.myLooper() 为什么可以返回各自线程的 Looper 对象呢？明明我们没有传入任何线程信息，内部是如何找到当前线程对应的 Looper 对象呢？</strong>，查看源码得知是ThreadLocal的作用，通过它可以在线程的内部存储数据，本着好奇的心态，就通过源码深入的了解一下ThreadLocal的工作原理。<br><a id="more"></a></p><pre><code>本文的源码是基于Android8.0</code></pre><h2 id="ThreadLocal概述"><a href="#ThreadLocal概述" class="headerlink" title="ThreadLocal概述"></a>ThreadLocal概述</h2><p>ThreadLocal，线程本地存储区（Thread Local Storage，简称为TLS），通过它可以在指定的线程中存储数据，数据存储之后，只能在指定的线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。来看一个简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; mThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; mThreadLocal2 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        mThreadLocal.set(<span class="number">0</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" - "</span> + mThreadLocal.get());</span><br><span class="line"></span><br><span class="line">        mThreadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" - "</span> + mThreadLocal2.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            mThreadLocal.set(<span class="number">2</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" - "</span> + mThreadLocal.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">" - "</span> + mThreadLocal.get())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果：*/</span></span><br><span class="line">main - <span class="number">0</span></span><br><span class="line">main - <span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span> - <span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span> - <span class="keyword">null</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，有三个线程。<strong>对于同一个mThreadLocal，不同线程</strong>，在主线程设置mThreadLocal的值为0，在子线程1设置mThreadLocal的值2，在子线程2没有设置mThreadLocal的值，从输出结果可以看出虽然在不同线程访问的是同一个ThreadLocal对象，但通过ThreadLocal获取的值却不一样。<strong>对于不同的mThreadLocal和mThreadLocal2，同一线程</strong>，在主线程分别设置mThreadLocal的值为0，mThreadLocal2的值为1，从输出结果可以看出在同一线程中，通过不同的ThreadLocal存值，则通过相应的ThreadLocal取出的值也不一样。</p><p>这里可以提出关于ThreadLocal的俩个问题：<br>1、ThreadLocal 是如何做到同一个对象，却维护着不同线程的数据副本呢？<br>2、ThreadLocal是如何做到同一线程中不同 ThreadLocal 虽然共用同一个线程中的容器，但却可以相互独立运作？</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>掌握了ThreadLocal的get和set方法的原理，也就掌握了ThreadLocal的工作原理。</p><h3 id="1、ThreadLocal-get"><a href="#1、ThreadLocal-get" class="headerlink" title="1、ThreadLocal#get()"></a>1、ThreadLocal#get()</h3><p>获取当前线程TLS区域的数据，该方法的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1、获取当前线程</span></span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      <span class="comment">//2、 以当前线程为参数，获取一个 ThreadLocalMap 对象</span></span><br><span class="line">      ThreadLocalMap map = getMap(t)；</span><br><span class="line">      <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//3、map不为空，则以当前 ThreadLocal 对象实例作为key值，去map中取值，有找到直接返回</span></span><br><span class="line">          ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">              T result = (T)e.value;</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4. map 为空或者在map中取不到值，那么走这里，返回默认初始值</span></span><br><span class="line">      <span class="keyword">return</span> setInitialValue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>首先获取当前线程，接着以当前线程为参数调用getMap函数，该方法源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>getMap方法返回传进来的线程中的threadlocals字段，threadlocals是一个ThreadLocalMap对象，它就是我们上面提到的每个线程中保存数据的容器，定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal$ThreadLocalMap</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">        Object value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal key, Object value)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span> </span>&#123;</span><br><span class="line">        ...   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadLocalMap 就是一个用于存储数据的容器类, 里面table数组就是真正的存储每个线程的数据，数组的每个元素类型就是一个具有（key-value）键值对的Entry，key对应ThreadLocal实例，value对应要存储的数据，数组的index值是以ThreadLocal实例为key根据hash算法算出来的，里面的set和getEntry方法就是存取table数组的具体算法实现，这里我们不深究，有兴趣可以自行查找资料。<br>我们继续ThreadLocal#get方法, 调用getMap之后就的到了当前线程的数据存储容器即map：</p><ul><li>当map不为空时，就以当前ThreadLocal实例为参数调用map.getEntry方法，该方法返回一个ThreadLocalMap.Entry对象, ThreadLocalMap在前面已经介绍过了，它里面有一个元素类型为Entry的table数组，getEntry方法就是以ThreadLocal实例作为key值，然后用key值转成table数组中的index值，返回table中的index位置的元素，而Entry又是一个具有（key-value）键值对的Entry，key对应ThreadLocal实例，value对应要存储的数据，所以e.value就返回了结果即要获取的数据。</li><li>当map为空时或者在map中找不到数据即map.getEntry返回了null，就调用setInitialValue方法返回默认初始值。该方法源码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 获取初始值，默认返回Null，允许重写</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line">        <span class="comment">//2、获取当前线程并以当前线程为参数，获取一个ThreadLocalMap 对象</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//3、当map不为空，设置初始值给map</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//当map为空， 创建当前线程的数据存储容器map</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="comment">//4、返回初始值</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>setInitialValue方法返回初始值，第一步调用initialValue()，方法源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到默认返回null，但是该方法可以继承自ThreadLocal并重写它返回你想要的初始值。<br>第二步获取当前线程并以当前线程为参数，获取一个ThreadLocalMap 对象，与上面分析get方法时的1、2步骤一样，就不再复述。<br>第三步同样判断map是否为空:</p><ul><li>当map不为空时，以当前ThreadLocal实例为key，initialvalue方法获取到的初始值为value，将（key - value）值保存到map中。</li><li>当map为空时，就调用createMap方法， ThreadLocal 中的 createMap() 方法就是对当前Thread 中的 threadLocals成员变量赋值，该方法源码如下:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以当前ThreadLocal实例对象为key，存值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>Thread 中的 threadLocal 成员变量初始值为 null，并且在 Thread 类中没有任何赋值的地方，只有在 ThreadLocal 中的 createMap() 方法中对其赋值，而调用 createMap() 的地方就两个：set() 和 setInitialValue()，而调用 setInitialValue() 方法的地方只有 get()。可以看到这里的赋值就是new一个ThreadLocalMap对象,以当前ThreadLocal实例对象为key，存值。</p><p>到此，get方法就已经讲完了，我们现在可以回答上面俩个问题：</p><ul><li>问题1: ThreadLocal</li></ul><p>是如何做到同一个对象，却维护着不同线程的数据副本呢？<br><strong>原来，这些数据本来就是存储在各自线程中了，ThreadLocal 的 get() 方法内部其实会先去获取当前的线程对象，然后直接将线程存储数据的容器(ThreadLocalMap)取出来，如果为空就会先创建并将初始值和当前 ThreadLocal 对象绑定存储进去，这样不同线程即使调用了同一 ThreadLocal 对象的get方法，取的数据也是各自线程的数据副本，这样自然就可以达到维护不同线程各自相互独立的数据副本，且以线程为作用域的效果了。</strong></p><ul><li>问题2:ThreadLocal是如何做到同一线程中不同 ThreadLocal 虽然共用同一个线程中的容器，但却可以相互独立运作？</li></ul><p><strong>原来，ThreadLocal 的 get() 方法内部根据线程取出map后，当map不为空时，会根据ThreadLocal实例去map中查找value，换句话说，在将数据存储到线程的容器map中是以当前 ThreadLocal 对象实例为 key 存储，这样，即使在同一线程中调用了不同的 ThreadLocal 对象的 get() 方法，所获取到的数据也是不同的，达到同一线程中不同 ThreadLocal 虽然共用一个容器，但却可以相互独立运作的效果。</strong></p><h3 id="2、ThreadLocal-set-T-value"><a href="#2、ThreadLocal-set-T-value" class="headerlink" title="2、ThreadLocal#set(T value)"></a>2、ThreadLocal#set(T value)</h3><p>将value存储到当前线程的TLS区域。在上面的get方法中，ThreadLocal会根据线程取出线程的容器，然后再根据key（ThreadLocal实例）去容器中取值，如果取不到值，就会返回初始值，初始值默认是null，那是因为ThreadLocal要调用set方法后，容器中才有我们想要的值，ThreadLocal#set方法的源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 取当前线程对象</span></span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       <span class="comment">//2. 取当前线程的数据存储容器</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">       <span class="comment">//3. 如果map不为空，以当前ThreadLocal实例对象为key，存值</span></span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       <span class="comment">//4. 如果map为空，新建一个当前线程的数据存储容器</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>set方法中的步骤在get方法中已经分析过了，所以读者在看到set方法时是不是感觉似曾相识，get和set两个方法内部会自动根据当前线程选择相对应的容器存取。</p><h2 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h2><p>一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从get和set方法中都可以看出，它们所操作的对象都是当前线程中的容器ThreadLocalMap，所以在不同线程中访问同一个ThreadLocal的get和set方法，它们对ThreadLocal所做的读写操作仅限与线程内部。一句话总结ThreadLocal原理:<strong>不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程取出一个容器ThreadLocalMap，然后再从容器中根据当前ThreadLocal的实例去查找对应的value值，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不干扰，在同一线程中不同 ThreadLocal 虽然共用同一个线程中的容器，但却可以相互独立运作。</strong></p><p>参考资料:</p><p>《Android开发艺术探索》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在研究&lt;a href=&quot;https://rain9155.github.io/2019/02/21/Android消息机制java层&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android的消息机制&lt;/a&gt;时遇到了一个疑问:&lt;strong&gt;在不同线程中调用 Looper.myLooper() 为什么可以返回各自线程的 Looper 对象呢？明明我们没有传入任何线程信息，内部是如何找到当前线程对应的 Looper 对象呢？&lt;/strong&gt;，查看源码得知是ThreadLocal的作用，通过它可以在线程的内部存储数据，本着好奇的心态，就通过源码深入的了解一下ThreadLocal的工作原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android消息机制native层</title>
    <link href="http://yoursite.com/2019/02/21/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6native%E5%B1%82/"/>
    <id>http://yoursite.com/2019/02/21/Android消息机制native层/</id>
    <published>2019-02-21T05:51:51.000Z</published>
    <updated>2019-08-06T05:50:19.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://rain9155.github.io/2019/02/21/Android消息机制java层" target="_blank" rel="noopener">Android消息机制（java层）</a>中讲到MessaeQueue是Android消息机制的Java层和native层的连接纽带，Android的java层和native层通过JNI调用打通，MessageQueue中有多个native方法，java层和native各有一套消息机制，实现不一样，本文讲解native层的Android消息机制。<br><a id="more"></a></p><pre><code>本文基于Android8.0，相关源码文件如下:frameworks/base/core/jni/android_os_MessageQueue.cppframeworks/base/core/jni/android_os_MessageQueue.hsystem/core/libutils/Looper.cpp system/core/libutils/Looper.h</code></pre><h2 id="native层消息机制架构图"><a href="#native层消息机制架构图" class="headerlink" title="native层消息机制架构图"></a>native层消息机制架构图</h2><img src="/2019/02/21/Android消息机制native层/Android消息机制(native层).jpg"><ul><li>MessageQueue  — 里面有一个Looper。</li><li>NativeMessageQueue  —  MessageQueue的继承类，见名知意，native层的消息队列，只是一个代理类，其大部分方法操作都转交给Looper的方法。</li><li>Looper  —  native层的Looper，其功能相当于java层的Handler，它可以取出消息，发送消息，处理消息。</li><li>MessageHandler  —  消息处理类，Looper把处理消息逻辑转交给此类。</li><li>WeakMessageHanlder  —  MessageHandler的继承类，也是处理消息类，但最终还会把消息处理逻辑转交给MessageHandler。</li></ul><h2 id="java层的MessageQueue"><a href="#java层的MessageQueue" class="headerlink" title="java层的MessageQueue"></a>java层的MessageQueue</h2><p>要讲解native层的消息机制，我们可以从java层消息机制调用到的MessageQueue的native方法讲起，MessageQueue中所有的native方法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们主要讲解三个：nativeInit()， nativePollOnce(long ptr, int timeoutMillis)， nativeWake(long ptr)。</p><h3 id="1、MessageQueue-nativeInit"><a href="#1、MessageQueue-nativeInit" class="headerlink" title="1、MessageQueue#nativeInit()"></a>1、MessageQueue#nativeInit()</h3><p>在java层中，MessageQueue是在Looper中创建的，在MessageQueue的构造中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"> MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">        mQuitAllowed = quitAllowed;</span><br><span class="line">        mPtr = nativeInit();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>在java层中，mPtr保存了nativeInit()返回的值，nativeInit方法的实现在android_os_MessageQueue.cpp文件中的android_os_MessageQueue_nativeInit方法中，该方法源码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//创建native消息队列NativeMessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//增加引用计数</span></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="comment">//使用C++强制类型转换符reinterpret_cast把NativeMessageQueue指针强转成long类型并返回到java层</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在android_os_MessageQueue_nativeInit方法中会创建一个NativeMessageQueue对象，并增加其引用计数，并将NativeMessageQueue指针mPtr保存在Java层的MessageQueue中。现在我们来看NativeMessageQueue的构造函数, 如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() :</span><br><span class="line">    mPollEnv(<span class="literal">NULL</span>), mPollObj(<span class="literal">NULL</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//获取TLS中的Looper(Looper::getForThread相当于java层的Looper.mLooper中的ThreadLocal.get) </span></span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="comment">//创建native层的Looper</span></span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//保存Looper到TLS中(Looper::setForThread相当于java层的ThreadLocal.set)</span></span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（关于TLS更多信息可以查看<a href="https://rain9155.github.io/2019/02/21/ThreadLocal解析" target="_blank" rel="noopener">ThreadLocal原理解析</a>），在NativeMessageQueue的构造中会先调用Looper的getForThread方法从当前线程获取Looper对象，如果为空，就会创建一个Looper并调用Looper的setForThread方法设置给当前线程。也就是说Looper和MessageQueue在java层和native层都有，但它们的功能并不是一一对应，此处native层的Looper与Java层的Looper没有任何的关系，只是在native层重实现了一套类似功能的逻辑。我们来看看native层在创建Looper时做了什么，Looper的构造函数如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :</span><br><span class="line">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(<span class="literal">false</span>),</span><br><span class="line">        mPolling(<span class="literal">false</span>), mEpollFd(<span class="number">-1</span>), mEpollRebuildRequired(<span class="literal">false</span>),</span><br><span class="line">        mNextRequestSeq(<span class="number">0</span>), mResponseIndex(<span class="number">0</span>), mNextMessageUptime(LLONG_MAX) &#123;</span><br><span class="line">    <span class="comment">//构造唤醒事件的fd（文件描述符）</span></span><br><span class="line">    mWakeEventFd = eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//重建epoll事件</span></span><br><span class="line">    rebuildEpollLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们忽略一大堆字段赋值，只关注一个函数:  rebuildEpollLocked(), 该函数核心源码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::rebuildEpollLocked() &#123;</span><br><span class="line">    <span class="comment">//1、关闭旧的管道</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">       close(mEpollFd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、创建新的epoll实例（文件描述符），并注册wake管道</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">//置空eventItem</span></span><br><span class="line">    <span class="comment">//3、设置事件类型和文件描述符</span></span><br><span class="line">    eventItem.events = EPOLLIN;<span class="comment">//可读事件</span></span><br><span class="line">    eventItem.data.fd = mWakeEventFd;<span class="comment">//唤醒事件的fd（文件描述符）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4、将唤醒事件(mWakeEventFd)添加到epoll实例(mEpollFd)，并监听事件</span></span><br><span class="line">    <span class="keyword">int</span> result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Looper的构造函数中涉及到Linux的epoll机制，关于更多资料可以自行查找资料(有Linux基础的可以阅读<a href="http://gityuan.com/2019/01/06/linux-epoll/" target="_blank" rel="noopener">源码解读epoll内核机制</a> )，这里简单介绍一下:</p><pre><code>epoll机制是Linux最高效的I/O复用机制, 使用一个文件描述符管理多个描述符。epoll操作过程有3个方法，分别是:1、int epoll_create(int size)；   用于创建一个epoll的文件描述符，size是指监听的描述符个数。2、int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； 用于对需要监听的文件描述符(fd)执行op操作，比如将fd加入到epoll文件描述符, 参数:epfd：是epoll_create()的返回值op：表示op操作，用三个宏来表示，分别代表添加(EPOLL_CTL_ADD)、删除(EPOLL_CTL_DEL)和修改( EPOLL_CTL_MOD)对fd的监听事件fd：需要监听的文件描述符epoll_event：需要监听的事件3、int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)； 等待事件的上报, 该函数返回需要处理的事件数目，如返回0表示已超时,参数：epfd：等待epfd上的io事件，最多返回maxevents个事件；events：用来从内核得到事件的集合；maxevents：events数量，该maxevents值不能大于创建epoll_create()时的size；timeout：超时时间（毫秒，0会立即返回）。</code></pre><p>要使用epoll机制，首先通过 epoll_create创建一个epoll专用文件描述符，并创建了一个管道，最后通过epoll_ctl函数来设置监听的事件类型为EPOLLIN（可读事件），在这里Looper对象中的mWakeEventFd(唤醒事件的文件描述符)添加到epoll监控范围内。至此，native层的MessageQueue和Looper就构建完毕，底层通过管道与epoll机制也建立了一套消息机制。</p><p>我们跟着MessageQueue#nativeInit()一路走下来，这里小结一下：</p><ul><li>1、首先java层的Looper对象会在构造函数中创建java层的MessageQueue对象。</li><li>2、 java层的MessageQueue对象又会调用nativeInit函数初始化native层的NativeMessageQueue，NativeMessageQueue的构造函数又会创建native层的Looper，并且在Looper中通过管道与epoll机制建立一套消息机制。</li><li>3、native层构建完毕，将NativeMessageQueue对象转换为一个long类型存储到java层的MessageQueue的mPtr中。</li></ul><p>在此之后就会在java层中启动消息循环，Looper.loop -&gt; Looper.next -&gt; MessageQueue.next -&gt;<br>MessageQueue.nativePollOnce，下面我们来看MessageQueue#nativePollOnce()。</p><h3 id="2、MessageQueue-nativePollOnce"><a href="#2、MessageQueue-nativePollOnce" class="headerlink" title="2、MessageQueue#nativePollOnce()"></a>2、MessageQueue#nativePollOnce()</h3><p>在java层中每次循环去读消息时，都会调用这个函数，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"> <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>nativePollOnce函数的实现在android_os_MessageQueue.cpp文件中的android_os_MessageQueue_nativePollOnce方法中，该方法的源码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把ptr强转为NativeMessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ptr是从java层传过来的mPtr的值，mPtr在初始化时保存了NativeMessageQueue的指针，此时首先把传递进来的ptr转换为NativeMessageQueue，然后调用NativeMessageQueue的pollOnce函数，该函数核心源码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//核心是调用了native层的Looper的pollOnce方法</span></span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码主要就是调用了native层的Looper的pollOnce(timeoutMillis)方法，该方法会调用Looper的 pollOnce(timeoutMillis, NULL, NULL, NULL)，相关源码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="comment">//处理内部轮询</span></span><br><span class="line">     result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法核心在于调用了pollInner函数，该函数相关源码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//事件集合，EPOLL_MAX_EVENTS为最大事件数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="comment">//1、等待事件发生或者超时，从管道中读取事件</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);  </span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    mLock.lock();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Done:;</span><br><span class="line">    <span class="comment">//处理Native的Message，调用相应回调方法</span></span><br><span class="line">    mNextMessageUptime = LLONG_MAX;</span><br><span class="line">    <span class="keyword">while</span> (mMessageEnvelopes.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//2、判断消息的执行时间</span></span><br><span class="line">        <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">        <span class="comment">//3、获取native层的Handler</span></span><br><span class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">                <span class="comment">//4、获取native层的消息</span></span><br><span class="line">                Message message = messageEnvelope.message;</span><br><span class="line">                mMessageEnvelopes.removeAt(<span class="number">0</span>);</span><br><span class="line">                mSendingMessage = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                mLock.unlock();</span><br><span class="line">                <span class="comment">//5、处理消息事件</span></span><br><span class="line">                handler-&gt;handleMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//请求锁</span></span><br><span class="line">            mLock.lock();</span><br><span class="line">            mSendingMessage = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 发生回调</span></span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//消息还没到执行时间</span></span><br><span class="line">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    mLock.unlock();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>pollInner函数很长，省略了一大堆代码，这里讲解一些核心的点，在此之前先讲解一下MessageEnvelope，正如其名字，信封，其结构体定义在Looper类中，如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Looper</span> :</span> <span class="keyword">public</span> RefBase &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MessageEnvelope</span> &#123;</span></span><br><span class="line">        MessageEnvelope() : uptime(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        MessageEnvelope(<span class="keyword">nsecs_t</span> u, <span class="keyword">const</span> sp&lt;MessageHandler&gt; h,</span><br><span class="line">                <span class="keyword">const</span> Message&amp; m) : uptime(u), handler(h), message(m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">nsecs_t</span> uptime;</span><br><span class="line">        sp&lt;MessageHandler&gt; handler;</span><br><span class="line">        Message message;</span><br><span class="line">    &#125;;   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MessageEnvelope里面记录着收信人（handler，MessageHandler类型，是一个消息处理类），发信时间(uptime)，信件内容(message，Message类型)。Message结构体，消息处理类，Looper类都定义在Looper.h/ Looper.cpp文件中。pollInner函数的流程如下：</p><ul><li>1、先调用epoll_wait()，这是阻塞方法，从管道取到事件或等待超时都会返回。</li><li>2、进入Done标记位的代码段, 处理Native的Message，调用Native 的Handler来处理该Message。</li></ul><p>pollInner实际上就是从管道中读取事件，并且处理这些事件。在native中事件存储在管道中，而在java层中事件存储在消息链表中，但这俩个层次的事件都通过java层的Looper消息循环进行不断的获取，处理等操作。</p><p>我们更着MessageQueue#nativePollOnce()一路走下来，小结一下：</p><ul><li>1、当在java层通过Looper启动消息循环后，就会走到MessageQueue的nativePollOnce方法，在该方法native实现中，会把保存在java层的mPtr再转换为NativeMessageQueue。</li><li>2、然后调用NativeMessageQueue的pollOnce方法，该方法中最终会调用native层的Looper的pollInner方法，Looper的pollInner方法是阻塞方法，等从管道取到事件或超时就会返回，并通过native层的Handler处理native层的Message消息。</li><li>3、处理完native层消息后，又会返回到java层处理java层的消息。</li></ul><p>可以看到，native层的NativeMessageQueue实际上并没有做什么实际工作，只是把操作转发给native层的Looper，而native层的Looper则扮演了java层的Handle角色，它可以取出，发送，处理消息。</p><h3 id="3、MessageQueue-nativeWake"><a href="#3、MessageQueue-nativeWake" class="headerlink" title="3、MessageQueue#nativeWake()"></a>3、MessageQueue#nativeWake()</h3><p>nativeWake()用于唤醒功能，我们在Java层通过Hanlder发送消息时，实际是把消息添加到消息队列，会调用到MessageQueue的enqueueMessage方法, 该方法中会调用到nativeWake方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p> 或者把消息从消息队列中全部移除，调用MessageQueue的quit方法，在有需要时都会调用nativeWake方法。MessageQueue的nativeWake方法的实现在android_os_MessageQueue.cpp文件中的android_os_MessageQueue_nativeWake方法中，该方法的源码如下:<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 可以看到，步骤和上面讲的差不多，首先把传递进来的ptr转换为NativeMessageQueue，然后调用NativeMessageQueue的wake函数，该函数源码如下:<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> NativeMessageQueue::wake() &#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面说过在native层中NativeMessageQueue只是一个代理Looper的角色，该方法把操作转发给native层的Looper，Looper的wake方法核心源码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::wake() &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//通过write函数向管道mWakeEventFd写入字符inc</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">   <span class="comment">//...</span></span><br></pre></td></tr></table></figure></p><p>其中TEMP_FAILURE_RETRY 是一个宏定义， 当执行write失败后，会不断重复执行，直到执行成功为止。Looper的wake方法就是向管道mWakeEventfd写入字符。</p><p>我们跟着MessageQueue#nativeWake一路走下来，小结一下：</p><ul><li>1、在java层插入消息到消息队列后，就会根据需要判断是否要调用nativeWake方法，如果调用，就转到2。</li><li>2、在nativeWake方法native实现中，会把保存在java层的mPtr再转换为NativeMessageQueue，然后调用NativeMessageQueue的wake方法，最终调用Looper的wake方法。</li><li>3、前面讲到Looper::pollInner方法是一个阻塞操作，当管道中没有事件时当前线程就会进入等待，当管道有事件就会立即返回，从管道中读取事件并处理。而Looper::wake方法就是一个唤醒操作，它就是通过前面创建的唤醒事件文件描述符mWakeEventFd来往管道中写入内容，这时另外等待管道事件的线程就会被唤醒。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java层和Native层的MessageQueue通过JNI建立关联，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理native层消息。Handler/Looper/Message这三大类Java层与Native层并没有任何的真正关联，只是分别在Java层和Native层的handler消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑。另外，消息处理流程是先处理Native Message，最后处理Java Message。</p><p>参考资料：</p><p>《Android源码设计与分析》</p><p><a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Android消息机制2-Handler(Native层)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://rain9155.github.io/2019/02/21/Android消息机制java层&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android消息机制（java层）&lt;/a&gt;中讲到MessaeQueue是Android消息机制的Java层和native层的连接纽带，Android的java层和native层通过JNI调用打通，MessageQueue中有多个native方法，java层和native各有一套消息机制，实现不一样，本文讲解native层的Android消息机制。&lt;br&gt;
    
    </summary>
    
    
      <category term="消息机制" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="handler" scheme="http://yoursite.com/tags/handler/"/>
    
  </entry>
  
  <entry>
    <title>Android消息机制java层</title>
    <link href="http://yoursite.com/2019/02/21/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82/"/>
    <id>http://yoursite.com/2019/02/21/Android消息机制java层/</id>
    <published>2019-02-21T05:33:11.000Z</published>
    <updated>2019-08-06T05:50:10.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android的消息机制用于同进程的线程间通信，它是由MessageQueue，Message，Looper，Handler共同组成。Android中有大量的交互都是通过消息机制，比如Android的四大组件的启动过程的交互就离不开消息机制，所以Android在某种意义上也可以说成是一个以消息驱动的系统。</p><a id="more"></a><pre><code>本文源码基于Android8.0，源码相关位置:frameworks/base/core/java/android/os/MessageQueue.javaframeworks/base/core/java/android/os/Handler.javaframeworks/base/core/java/android/os/Looper.javaframeworks/base/core/java/android/os/Message.java</code></pre><h2 id="消息机制概述"><a href="#消息机制概述" class="headerlink" title="消息机制概述"></a>消息机制概述</h2><p>Android应用的每个事件都会转化为一个系统消息即Message，消息中包含了事件的相关信息和消息的处理人即Handler，消息要通过Handler发送，最终被投递到一个消息队列中即MessageQueue，它维护了一个待处理的消息列表，然后通过Looper开启了一个消息循环不断地从这个队列中取出消息，当从消息队列取出一个消息后，Looper根据消息的处理人（target）将此消息分发给相应的Handle处理。它们的工作原理就像工厂的生产线，Looper是发动机，MessageQueue是传送带，Handler是工人，Message则是待处理的产品。整个过程如下图所示。<br><img src="/2019/02/21/Android消息机制java层/handler1.png"></p><h2 id="消息机制架构图"><a href="#消息机制架构图" class="headerlink" title="消息机制架构图"></a>消息机制架构图</h2><img src="/2019/02/21/Android消息机制java层/handler2.png"><ul><li>Looper  — 是每个线程的MessageQueue管家，里面有一个MessageQueue消息队列，负责把消息从MessageQueue中取出并把消息传递到Handler中去，每个线程只有一个Looper。</li><li>MessageQueue  —  消息队列，有一组待处理的Message，主要用于存放所有通过Handler发送的消息，每个线程只有一个MessageQueue。</li><li>Message  —  是线程之间传递的消息，里面有一个用于处理消息的Handler。</li><li>Handler  —  主要用于发送和处理消息，里面有Looper和MessageQueue。</li></ul><h2 id="深入了解Android的消息机制"><a href="#深入了解Android的消息机制" class="headerlink" title="深入了解Android的消息机制"></a>深入了解Android的消息机制</h2><h3 id="1、-Looper的创建，Handler与Looper的关联"><a href="#1、-Looper的创建，Handler与Looper的关联" class="headerlink" title="1、 Looper的创建，Handler与Looper的关联"></a>1、 Looper的创建，Handler与Looper的关联</h3><p>我们知道Android应用程序的入口实际上是ActivityThread.main方法，在该方法中首先会创建Application和默认启动的Activity，并将它们关联在一起，而该应用的UI线程的消息循环也是在这个方法中创建，具体源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="comment">//1、创建UI线程的消息循环Looper</span></span><br><span class="line"> Looper.prepareMainLooper();</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="comment">//2、执行消息循环</span></span><br><span class="line"> Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行ActivityThread.main后，应用程序就启动了，UI的消息循环也在Looper.loop（）中启动，此后Looper会一直从消息队列中取出消息，用户或系统通过Handler不断往消息队列中添加消息，这些消息不断的被取出，处理，回收，使得应用运转起来。Android应用程序的Handler在ActivityThread中被创建，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br><span class="line"><span class="comment">//H定义如下，里面定义了大量的字段，跟Activity的启动，Application的绑定等有关</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIND_APPLICATION        = <span class="number">110</span>;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXIT_APPLICATION        = <span class="number">111</span>;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATE_SERVICE          = <span class="number">114</span>;</span><br><span class="line">       <span class="comment">//....</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">              <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line"> <span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">              <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br></pre></td></tr></table></figure></p><p>在开发中，我们在子线程中执行完操作后通常需要更新UI，但我们都知道不能在子线程中更新UI，此时我们就要通过Handler将一个消息post到UI线程中，然后再在Handler中的handleMessage（）中进行处理，在这里要注意的是如果我们不传递UI线程所属的Looper去创建Handler，那么该Handler必须在主线程中创建，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在主线程中创建Handler </span></span><br><span class="line">Handler mHandler = <span class="keyword">new</span> Handler（）&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">  <span class="comment">//更新UI</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在子线程中进行耗时操作</span></span><br><span class="line"><span class="keyword">new</span> Thread（）&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">mHandler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果不这样做将会抛出一个异常”Can’t create handler inside threadxx that has not called Looper.prepare()”, 为什么会这样呢？看异常描述是我们没有调用Looper.prepare()，那么问题又来了，<strong>为什么在主线程中创建Handler时我们没有手动调用Looper.prepare()不会抛异常，而在子线程创建Handler时没有调用Looper.prepare()就会抛异常？</strong><br>这里我们先从Handler的默认构造函数看起，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//与Looper关联</span></span><br><span class="line"> mLooper = Looper.myLooper();</span><br><span class="line">      <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">              <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                      + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">//通过Looper获取MessageQueue</span></span><br><span class="line">      mQueue = mLooper.mQueue;</span><br><span class="line">      mCallback = callback;</span><br><span class="line">      mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，Handler构造中会和Looper关联，如果通过Looper.myLooper()获取不到Looper，就会抛出上述所讲的异常，然后再通过Looper获取它持有的MessageQueue。我们继续点进myLooper()中看它如何工作，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取当前线程TLS区域的Looper</span></span><br><span class="line"><span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到myLooper方法是通过ThreadLocal获取的，这里简单介绍一下ThreadLocal（关于ThreadLocal更多信息可以查看<a href="https://rain9155.github.io/2019/02/21/ThreadLocal解析" target="_blank" rel="noopener">ThreadLocal原理解析</a>）:</p><pre><code>ThreadLocal： 线程本地存储区（Thread Local Storage，简称为TLS），每 个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。它的常用操作方法有：ThreadLocal.set(T value)：将value存储到当前线程的TLS区域。ThreadLocal.get()：获取当前线程TLS区域的数据</code></pre><p>ThreadLocal的get()和set()方法操作的类型都是泛型，接着回到前面提到的sThreadLocal变量，其在Looper中定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure></p><p>可见sThreadLocal的get()和set()操作的类型都是Looper类型,也就是说每个线程只能有一个Looper，不同线程的Looper是不相同的。那么Looper是什么时候被set到ThreadLocal中的？其实答案就在上面写到的ActivityThread.main方法中的Looper.perpareMainLooper中，相关源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置不允许退出的Looper</span></span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="comment">//将当前的Looper保存为主Looper，每个线程只允许执行一次。</span></span><br><span class="line">    <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//quitAllowed表示是否允许Looper运行时退出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span></span>&#123;</span><br><span class="line"><span class="comment">//Looper.prepare()只能执行一次</span></span><br><span class="line"><span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>); </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//把Looper保存到TLS中</span></span><br><span class="line">sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Looper的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//可以看到MessageQueue是在Looper中创建的</span></span><br><span class="line">     mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>我们再回到Handler中来，Looper属于某个线程，MessageQueue存储在Looper中，MessageQueue则通过Looper与特定的线程关联上，而Handler在构造中又与Looper和MessageQueue关联，所以最终通过Handler发送的消息就会被执行到这个线程上。同时因为应用程序启动时在ActivityThread.main方法中的Looper.prepareMainLooper()中已经调用了Looper.prepare(),所以在主线程中创建Handler无需我们手动调用Looper.prepare()，而在子线程中，如果我们不传递UI线程所属的Looper去创建Handler，那么就需要调用Looper.prepare()后再创建Handle来传递消息（<strong>总的来说是因为Handler要和某个线程中的MessageQueue和Looper关联，只有调用Looper.prepare()，Looper和MessageQueue才属于某个线程</strong>）。</p><h3 id="2、消息循环的运作"><a href="#2、消息循环的运作" class="headerlink" title="2、消息循环的运作"></a>2、消息循环的运作</h3><p>在创建Looper后，通过Looper.loop()就启动了消息循环，这个函数会不断的从消息队列中取出消息、处理消息。我们点进此方法看一下它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">     <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">     <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     <span class="comment">//从MessageQueue中取出消息，没有消息时会阻塞等待</span></span><br><span class="line"> Message msg = queue.next(); </span><br><span class="line"> <span class="comment">//next()返回了null，表示MessageQueue正在退出，即调用了Looper的quit或quitSafely方法</span></span><br><span class="line"> <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">           <span class="comment">//分发消息</span></span><br><span class="line"> msg.target.dispatchMessage(msg);</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>loop()中是一个死循环，loop()会调用MessageQueue的next()来获取最新的消息，当没有消息时，next()会一直阻塞在那里，这也导致loop()阻塞，唯一跳出循环的条件是next()返回null，这时代表Looper的quit()或quitSafely()被调用，从而调用MessageQueue的quit()来通知消息队列退出。MessageQueue的next()是最关键的函数，我们来看看next函数的关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//mPtr是在构造中被赋值，是指向native层的MessageQueue</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">       <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">           <span class="comment">//1、处理native层事件，是一个阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class="line">           nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">               Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">//java层的消息队列</span></span><br><span class="line">               Message msg = mMessages;</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;<span class="comment">//有消息</span></span><br><span class="line">            <span class="comment">//2、消息还没到触发时间</span></span><br><span class="line">                   <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                     <span class="comment">//设置下一次轮询的超时时长（等待时长）</span></span><br><span class="line">                       nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;   </span><br><span class="line">                       mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="comment">//3、获取一条消息并返回 </span></span><br><span class="line">                       <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           prevMsg.next = msg.next;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           mMessages = msg.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       msg.next = <span class="keyword">null</span>;</span><br><span class="line">                       <span class="comment">//设置消息的使用状态，即flags |= FLAG_IN_US</span></span><br><span class="line">                       msg.markInUse();</span><br><span class="line">                       <span class="keyword">return</span> msg;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有消息</span></span><br><span class="line">                   nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>next函数看起来有点多代码，但这里只分析核心部分，其实MessageQueue是消息机制的Java层和C++层的连接纽带，大部分核心方法都交给native层来处理，这里的mPtr是指向native层的NativeMessageQueue对象，在MessageQueue构造中被赋值, 如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">   mQuitAllowed = quitAllowed;</span><br><span class="line">   <span class="comment">//通过native方法初始化消息队列，其中mPtr是供native代码使用</span></span><br><span class="line">   mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>next方法也是一个死循环，最主要的方法是nativePollOnce(),它是一个阻塞操作，其中nextPollTimeoutMillis代表下一个消息到来前，还需要等待的时长，当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去，则next方法将会一直阻塞在这里，当有新消息到来时，next方法会返回这条消息并将其从单链表中删除。可以发现虽然MessageQueue叫消息队列，但它却不是用队列实现的，而是用链表实现的。</p><pre><code>MessageQueue是消息机制的核心类，它里面有大量的native方法，Android有俩套消息机制（java层和native层，实现不一样），但本文只讲解java层的消息机制，不会涉及到native层。</code></pre><p>（<a href="https://rain9155.github.io/2019/02/21/Android消息机制native层" target="_blank" rel="noopener">关于native层的查看Android消息机制（native层）</a>）</p><h3 id="3、消息的分发"><a href="#3、消息的分发" class="headerlink" title="3、消息的分发"></a>3、消息的分发</h3><p>如果loop方法中next()返回了null，那么就会执行到这一句” msg.target.dispatchMessage(msg)<br>“,Looper会把这条消息交给Message的target（Handler对象）来处理, 实际上是转了一圈，Handler把消息发送给消息队列，Looper又把这个消息给Handler处理。<strong>注意：在本文的情景下，loop方法这个时候是执行在主线程的，因为Looper是在主线程中创建的，所以到了这里，消息的处理就切换到主线程了，这就是Handler线程切换的原理，Handler发送的消息的线程不处理消息，只有在Looper.loop()中将消息取出来后再进行处理，所以在Handler机制中，无论发送消息的Handler对象处于什么线程，最终处理都是运行在Looper.loop()所在线程。</strong><br>下面来看消息分发逻辑，dispatchMessage()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1、检查msg的callback是否为空</span></span><br><span class="line">       <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">           handleCallback(msg);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//2、Handler的mCallback是否为空</span></span><br><span class="line">           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//3、我们平常处理消息的方法，该方法默认为空，Handler子类通过覆写该方法来完成具体的逻辑。</span></span><br><span class="line">           handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>里面代码量很少，首先第一步，检查msg.callback是否为空，不为空则执行” handleCallback(msg)”, 源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">       message.callback.run();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>msg.callback其实是一个Runnable对象，当我们通过Handler来post一个Runnable消息时，它就不为空，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//把Runnable对象包装成Message对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，在post(Runnable r)中，会把Runnable包装成Message对象，并把Runnable设置给Message的callback字段，然后发送此消息。</p><p>如果msg.callback为空，就到第二步，检查mCallback是否为空，mCallback是一个Callback接口，定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>当我们这样来创建Handler: Handler handler = new Handler(callback)时, mCallback就不为空，它的意义是当我们不想派生Handler的子类重写handleMessage()来处理消息时，就可以通过Callback来实现。</p><p>如果mCallback为空，就到第三步，调用Handler的handleMessage方法来处理消息。</p><h3 id="4、消息的发送"><a href="#4、消息的发送" class="headerlink" title="4、消息的发送"></a>4、消息的发送</h3><p>前面讲到消息的接收处理最终是在Handler中进行，而消息的发送也是通过Handler进行，消息的发送可以通过handler的一系列post方法和一系列的send方法，一系列post方法最终通过一系列send方法来实现，如图：<br><img src="/2019/02/21/Android消息机制java层/handler3.png"><br>从上图，可以发现所有的发消息方式，最终都是调用MessageQueue.enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)，该方法源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       msg.target = <span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>在该方法中，首先把Message的target字段设置为当前发送消息的Handler,然后设置Message是否是异步消息，最后把所有逻辑交给MessageQueue的enqueueMessage(Message msg, long when)方法，该方法的相应源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="comment">//正在退出时，回收msg，加入到消息池</span></span><br><span class="line">           <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">               msg.recycle();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">            msg.markInUse();</span><br><span class="line">           msg.when = when;</span><br><span class="line">           <span class="comment">//1、取队头消息</span></span><br><span class="line">           Message p = mMessages;</span><br><span class="line">           <span class="comment">//2、如果p为null，则代表MessageQueue没有消息</span></span><br><span class="line">           <span class="comment">//如果when == 0 或 when &lt; p.when, 则代表msg的触发时间是队列中最早的</span></span><br><span class="line">           <span class="comment">//满足上述条件就把msg插入到队列头部</span></span><br><span class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">               msg.next = p;</span><br><span class="line">               mMessages = msg;</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//3、如果p != null且msg并不是最早触发的</span></span><br><span class="line">               <span class="comment">//...              </span></span><br><span class="line">               Message prev;</span><br><span class="line">               <span class="comment">//下面是一个链表的插入操作,将消息按时间顺序插入到MessageQueue </span></span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = p.next；</span><br><span class="line">                   <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="comment">//...</span></span><br><span class="line">               &#125;</span><br><span class="line">               msg.next = p;</span><br><span class="line">               prev.next = msg;</span><br><span class="line">           &#125;   </span><br><span class="line">           <span class="comment">//消息没有退出，此时mPtr != 0，native层处理逻辑</span></span><br><span class="line">           <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">               nativeWake(mPtr);</span><br><span class="line">           &#125;     </span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法主要操作就是一个链表的插入操作，MessageQueue是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，如果消息队列为空或这个消息是最早触发的，就会直接插入队头，否则会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p><h3 id="5、消息的复用"><a href="#5、消息的复用" class="headerlink" title="5、消息的复用"></a>5、消息的复用</h3><p>前面多次提到了Message，当我们通过Handler的obtainMessage()或Message的obtain()获取一个Message对象时，系统并不是每次都new一个出来，而是先从消息池中（sPool）尝试获取一个Message。Handler的obtainMessage()最终是调用了Message的obtain()。Message#obtain()的源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">    <span class="comment">//从sPool头部取出一个Message对象返回，并把消息从链表断开（即把sPool指向下一个Message）</span></span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>;<span class="comment">//清除in-use flag</span></span><br><span class="line">                sPoolSize--;<span class="comment">//消息池的大小进行减1操作</span></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息池中没有Message，直接new一个返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br></pre></td></tr></table></figure></p><p>sPool的数据类型为Message，通过next成员变量，维护一个消息池，消息池的默认大小为50。定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();<span class="comment">//用于在获取Message对象时进行同步锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;<span class="comment">//池的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;<span class="comment">//池的可用大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line">    Message next;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然叫消息池，其实是通过链表实现的，每个Message都有一个同类型的next字段，这个next就是指向下一个可用的Message，最后一个可用的Message的next为空，这样所有可用的Message对象就通过next串成一个Message池，sPool指向池中的第一个Message。<br>那么Message对象是什么时候被放进消息池中的呢？其实在obtain方法中创建Message对象时，并不会直接把它放到池中，而是在回收Message时把它放入池中，Message中也有类似Bitmap那样的recycler函数，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断消息是否正在使用</span></span><br><span class="line">        <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gCheckRecycle) &#123;<span class="comment">//Android 5.0以后的版本默认为true,之前的版本默认为false.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                        + <span class="string">"is still in use."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//对于不再使用的消息，加入到消息池</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//将消息标示位置为IN_USE，并清空消息所有的参数</span></span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = <span class="number">0</span>;</span><br><span class="line">        arg1 = <span class="number">0</span>;</span><br><span class="line">        arg2 = <span class="number">0</span>;</span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        replyTo = <span class="keyword">null</span>;</span><br><span class="line">        sendingUid = -<span class="number">1</span>;</span><br><span class="line">        when = <span class="number">0</span>;</span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">        callback = <span class="keyword">null</span>;</span><br><span class="line">        data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">           <span class="comment">//当消息池没有满时，将Message对象加入消息池（即把Message插入链表头部）</span></span><br><span class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                next = sPool;</span><br><span class="line">                sPool = <span class="keyword">this</span>;</span><br><span class="line">                sPoolSize++;<span class="comment">//消息池的可用大小进行加1操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>recycler函数先判断该Message是否还在使用，如果还在使用，就会抛异常，否则就调用recyclerUnchecked函数根据MAX_POOL_SIZE判断是否把该消息回收，回收前还要先清空该消息的各个字段，回收消息就是把自身插入到链表表头。</p><p>通过消息的复用，减少Message对象不断创建与销毁的过程，提升了效率。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>能看到这里的，证明你已经了解了java层的消息机制是如何运作的了，本文从Android应用UI线程消息循环的创建出发，通过讲解Looper与Handler的关联，如何启动消息循环，消息的发送与分发，还有消息的复用来讲解了Message，Handler，MessageQueue，Looper之间是如何配合工作。掌握了这些，在以后开发中又能更加随心所欲了。</p><p>参考资料：</p><p>《Android开发艺术探索》</p><p>《Android源码设计与分析》</p><p><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Android消息机制1-Handler(java层)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Android的消息机制用于同进程的线程间通信，它是由MessageQueue，Message，Looper，Handler共同组成。Android中有大量的交互都是通过消息机制，比如Android的四大组件的启动过程的交互就离不开消息机制，所以Android在某种意义上也可以说成是一个以消息驱动的系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="消息机制" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="handler" scheme="http://yoursite.com/tags/handler/"/>
    
  </entry>
  
  <entry>
    <title>Http网络请求浅析</title>
    <link href="http://yoursite.com/2018/12/31/Http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/31/Http网络请求浅析/</id>
    <published>2018-12-31T07:33:15.000Z</published>
    <updated>2019-10-12T11:23:04.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着互联网的发展，网络已经越来越普及了，绝大多数的网络请求都是基于HTTP协议的，因此在开发中，了解HTTP的基本原理是必要的，在TCP/IP四层体系结构中，HTTP协议位于应用层，它是应用层主要使用的协议，应用层往下一层就是运输层，HTTP在运输层采用的是TCP协议来保证可靠传输，知道这些后，接下来详细介绍一下 Http。</p><a id="more"></a><h2 id="HTTP协议版本"><a href="#HTTP协议版本" class="headerlink" title="HTTP协议版本"></a>HTTP协议版本</h2><p>我们先来简单了解一下 HTTP 协议的历史演变：</p><ul><li>HTTP/1.0：1996年，HTTP/1.0 版本发布，可以传输文字，图像、视频、二进制文件，它的特点是每次请求都需要建立一个单独的TCP连接，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接，上一次请求和下一次请求完全分离，这种非持续连接过程又叫做短连接。它的特点也是它的缺点，客户端和服务端每次请求都要建立TCP连接，而建立TCP连接和关闭TCP连接都是相对比较费时的过程，严重影响客户端和服务端的性能。</li><li>HTTP/1.1：1997年，HTTP/1.1 版本发布，1999年广泛应用于各大浏览器网络请求中，直到现在HTTP/1.1也是使用最为广泛的HTTP协议，它进一步完善了HTTP/1.0，HTTP/1.1支持在一个TCP连接上传送多个HTTP请求和响应，即一个TCP连接可以被多个请求复用，减少了建立和关闭连接的消耗延迟，一定程度上弥补了HTTP/1.0每次请求都要创建连接的缺点，这种持续连接过程又叫做长连接，HTTP/1.1默认使用长连接。</li><li>HTTP/2.0：2015年，HTTP/2 .0版本发布，前面的两个版本都是基于超文本的协议，HTTP 2.0把基于超文本的协议改成了基于二进制的，把HTTP请求和响应变成数据帧，这样就实现了多路复用，在一个TCP连接上可以同时“混合”发送多个HTTP的请求和响应，效率大大提高。</li></ul><h3 id="1、长连接和多路复用的区别"><a href="#1、长连接和多路复用的区别" class="headerlink" title="1、长连接和多路复用的区别"></a>1、长连接和多路复用的区别</h3><p>上面讲到HTTP/1.1的长连接和HTTP 2.0的多路复用都是复用TCP连接，它们之间有什么区别呢？如图：</p><img src="/2018/12/31/Http网络请求浅析/http1.png" title="http1"><p>可以看到，HTTP/1.1的长连接的若干个请求只能排队发送，后面的请求等待前面请求的响应返回才能获得执行机会，一旦有某请求超时，后续请求只能被阻塞，这就是人们常说的线头阻塞；同时由于浏览器自身的Max-Connection最大连接限制，导致同一个域名 (host) 下的请求连接限制，比如谷歌浏览器的Max-Connection值为6，即同一个域名下一次最多连续发送6个请求，超过限制后续请求就会被阻塞。</p><p>而HTTP/2.0的多路复用才是做到了同一个域名下的真正的并发请求，多个请求可同时在一个TCP连接上并行发送，某个请求任务超时，不会影响到其它连接的正常执行。</p><h3 id="2、HTTPS是什么"><a href="#2、HTTPS是什么" class="headerlink" title="2、HTTPS是什么"></a>2、HTTPS是什么</h3><p>HTTPS就是在HTTP的应用层与运输层之间加了一层<strong>SSL/TLS</strong>，如下：</p><img src="/2018/12/31/Http网络请求浅析/http2.png" title="http2"><p>HTTP协议运行在TCP之上，所有传输的内容都是明文；HTTPS协议运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都通过SSL/TLS层进行了加密，保证了数据安全。目前大多数网站都运行在HTTPS协议之上，把HTTP报文经过加密后才发送出去，在接收到HTTP报文后经过解密才能使用。</p><p>由于HTTP/2.0还未大规模应用，所以下面的讨论都是围绕HTTP/1.x，只有熟悉HTTP/1.x的原理，才能更好的读懂<a href="https://juejin.im/post/5a4dfb2ef265da43305ee2d0" target="_blank" rel="noopener">HTTP/2.0</a>。</p><h2 id="HTTP工作过程"><a href="#HTTP工作过程" class="headerlink" title="HTTP工作过程"></a>HTTP工作过程</h2><p>HTTP是基于TCP的应用层协议，从更高层次封装了TCP的使用细节，使得网络操作更为简单，一个HTTP请求就是一个典型的C/S模式，HTTP协议首先要和服务器建立TCP连接，当建立TCP连接的三报文握手的前两次报文握手完成后，在第三次握手，客户端就把HTTP请求报文作为第三个握手报文的数据发送给服务端，服务器收到请求报文后，就把所请求的文档作为响应报文返回给客户端。</p><img src="/2018/12/31/Http网络请求浅析/http3.png" title="http3"><p>HTTP的工作特点可以总结为以下两点：</p><ul><li>1、面向无连接的：即通信双方在交换HTTP报文时不需要向建立HTTP连接，但HTTP使用了面向连接的TCP作为运输层协议。</li><li>2、无状态的：服务器不会记得每个客户访问的状态，同一个客户访问两次服务器上的页面时，服务器响应与第一次访问相同，所以出现了<strong>Cookie/Session机制</strong>维护连接的状态，可自行了解。</li></ul><h2 id="HTTP的请求方式"><a href="#HTTP的请求方式" class="headerlink" title="HTTP的请求方式"></a>HTTP的请求方式</h2><p>HTTP协议提供了几种请求方式，大家熟知的请求方式有7种GET、POST、DELETE、PUT、HEAD、TRACE、OPTIONS，其中最常用的是PUT（增）、DELETE(删)、POST（改）、GET（查）。下面以一张表来看看它们各自的作用。</p><table><thead><tr><th style="text-align:center">请求</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">CET</td><td style="text-align:left">客户端获取服务器中的某个资源，然后服务端返回对应资源给客户端，请求参数放在URL中</td></tr><tr><td style="text-align:center">POST</td><td style="text-align:left">POST请求通常会用来提交HTML表单，把数据填在表单中，传给服务器，然后服务器对这些数据进行处理</td></tr><tr><td style="text-align:center">PUT</td><td style="text-align:left">与GET相反，PUT向服务器写入数据</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:left">顾名思义，请服务器删除请求URL所指定的资源，但是服务端可以在客户端不知情下撤销此请求，请求参数放在URL中</td></tr><tr><td style="text-align:center">HEAD</td><td style="text-align:left">HEAD与GET类似，但服务器在响应中只返回首部不会返回主体部分，HEAD是用来在不获取资源的情况下对资源的首部进行检查，如查看响应的状态码，看看资源是否被修改，对象是否存在</td></tr><tr><td style="text-align:center">TRACE</td><td style="text-align:left">客户端发起一个请求时，可能要穿过防火墙，代理，网关等，每一个中间点都会修改HTTP原始请求，TRACE允许请求最终发送给服务端时，看看它最终变成什么样，服务端会返回一个TRACE响应</td></tr><tr><td style="text-align:center">OPTIONS</td><td style="text-align:left">客户端请求Web服务器告知其支持的各种功能，就是询问服务器支持什么方法或者对某些特殊资源支持什么方法，这就让客户端不用访问那些实际的资源就能判定访问各种资源的最优方法</td></tr></tbody></table><h2 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a>HTTP的报文格式</h2><p>用于HTTP协议交换的信息称为HTTP报文，客户端发出的HTTP报文叫做请求报文，服务端返回的HTTP报文交过响应报文，它们都是由多行数据构成的字符串文本，用CR + LF作为换行符，即回车符 + 换行符作为换行符，HTTP报文大体分为报文首部和报文主体两块，由第一个出现的空行(CR + LF)划分，如下：</p><img src="/2018/12/31/Http网络请求浅析/http4.png" title="http"><h3 id="1、请求报文"><a href="#1、请求报文" class="headerlink" title="1、请求报文"></a>1、请求报文</h3><p>一个HTTP的请求报文通常由请求行，请求头部，空行(CR + LF)，请求数据4个部分组成，如图：</p><img src="/2018/12/31/Http网络请求浅析/http5.png" title="http"><ul><li><p><strong>请求行</strong></p><p>又叫起始行，就是报文的第一行，在请求报文中说明要以什么方式做什么请求。</p></li><li><p><strong>请求头部</strong><br>又叫首部字段，起始行后由零个或多个首部字段，每个字段包含一个key和value，用冒号分割（如Connection：keep-Alive），首部以一个CR + LF结束，如果再细分，首部字段又可以分为请求首部字段、通用首部字段和实体首部字段。</p></li><li><p><strong>请求数据</strong><br>又叫主体，其中可以包含任意类型的数据（如图片，视频等），而首部和起始行只能是文本形式，在请求主体中包括了要发送给Web服务器的数据。</p></li></ul><p>不同的请求方式，它们的请求报文格式可能有点差别的，有些请求方式它的请求数据为空，有些则不为空，但是请求行和请求头部是必须存在的，下面以GET、DELETE、PULL、POST举例：</p><h4 id="1-1、GET、DELETE的请求报文"><a href="#1-1、GET、DELETE的请求报文" class="headerlink" title="1.1、GET、DELETE的请求报文"></a>1.1、GET、DELETE的请求报文</h4><p>对于GET和DELETE来说，它们的所有参数都是拼接在URL最后，第一个参数前通过”?”连接，然后请求参数按照”key=value”格式进行追加，每个请求参数之间通过”&amp;”连接，如 <strong><a href="http://www.myhost.com/text/?id=1&amp;name=rain" target="_blank" rel="noopener">http://www.myhost.com/text/?id=1&amp;name=rain</a></strong>，如果是GET请求表示获取 <strong><a href="http://www.myhost.com/text/" target="_blank" rel="noopener">http://www.myhost.com/text/</a></strong> 下用户id为1，名为rain的文本，如果是DELETE请求表示删除该文本。</p><p><code>注意：GET和DELETE的URL最长度为1024字节（1KB）</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /?id=1&amp;name=rain HTTP/1.1</span><br><span class="line">Host: www.myhost.com</span><br><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>从上面的HTTP请求格式知，第一行为请求行，表明请求方式为GET，子路径为 /?id=1&amp;name=rain，HTTP版本为1.1。后两行为请求首部，Host为主机地址，Cache-Control为no-cache。因为GET,DELETE的请求参数都在URL中，所以请求数据为空。</p><h4 id="1-2、PULL、POST的请求报文"><a href="#1-2、PULL、POST的请求报文" class="headerlink" title="1.2、PULL、POST的请求报文"></a>1.2、PULL、POST的请求报文</h4><p>而对于PULL和POST来说，它们的报文格式一般是表单格式，也就是说请求参数存储在请求数据位置上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST /local/ HTTP/1.1</span><br><span class="line">Host: www.myhost.com</span><br><span class="line">Accept-Encoding：gzip</span><br><span class="line">Content-Length: 222222</span><br><span class="line">Content-Type:multipart/from-data；boundary=dRGP2cPPTxE6WRTssnh4jC7HJLcSde</span><br><span class="line">Connection：Keep-Alive</span><br><span class="line"></span><br><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde</span><br><span class="line">Content-Disposition：from-data；name=“username”</span><br><span class="line">Content-Type：text/plain：charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"></span><br><span class="line">rain</span><br><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde</span><br><span class="line">Content-Diaposition:from-data:name=&quot;image&quot;</span><br><span class="line">filename=&quot;/storage/emulated/0/image/1234.png&quot;</span><br><span class="line">Content-Type:application/octet-stream</span><br><span class="line">Content-Transfer-Encoding:binary</span><br><span class="line"></span><br><span class="line">图片二进制数据，在此省略...</span><br><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde--</span><br></pre></td></tr></table></figure><p>上述的请求含义是向 <strong><a href="http://www.myhost.com/local/" target="_blank" rel="noopener">http://www.myhost.com/local/</a></strong> 这个地址发送一个POST请求，请求的数据格式为multipart/from-data，报文的boundary值为dRGP2cPPTxE6WRTssnh4jC7HJLcSde，报文有两个请求参数：一个是名为username的文本，值为rain；一个是名为image的二进制参数，值为图片的二进制数据。</p><p>请求参数是以两个横杠（–）加上boundary开始的，然后是请求参数的一些首部属性，如参数名，格式等，然后加上一个空行，最后才是参数的值，如上述的username=name，其表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde//两横杠加boundary</span><br><span class="line">Content-Disposition：from-data；name=“username”//以下三个参数是首部属性</span><br><span class="line">Content-Type：text/plain：charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">//不可省略的空行</span><br><span class="line">rain//参数值</span><br></pre></td></tr></table></figure><p>POST和PULL都要遵守这种格式，每个参数以两横杠加boundary分隔，参数首部与值之间有一个空行。</p><p>请求数据的最后是以两个横杆+boundary+两个横杠结束作为整个报文的结束符，如上面报文的图片二进制数据最后的- -dRGP2cPPTxE6WRTssnh4jC7HJLcSde- -，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde</span><br><span class="line">Content-Diaposition:from-data:name=&quot;image&quot;</span><br><span class="line">filename=&quot;/storage/emulated/0/image/1234.png&quot;</span><br><span class="line">Content-Type:application/octet-stream</span><br><span class="line">Content-Transfer-Encoding:binary</span><br><span class="line"></span><br><span class="line">图片二进制数据，在此省略...</span><br><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde--//整个报文的结束符</span><br></pre></td></tr></table></figure><h3 id="2、响应报文"><a href="#2、响应报文" class="headerlink" title="2、响应报文"></a>2、响应报文</h3><p>一个HTTP的响应报文通常由状态行、响应头部、空行(CR + LF)、响应主体组成，如下：</p><ul><li><p><strong>状态行</strong></p><p>在响应报文中粗略的说明了报文的执行结果。</p></li><li><p><strong>响应头部</strong></p><p>又叫首部字段，起始行后由零个或多个首部字段，每个字段包含一个key和value，首部以一个CR + LF结束，如果再细分，首部字段又可以分为响应首部字段、通用首部字段和实体首部字段。</p></li><li><p><strong>响应主体</strong></p><p>在响应主体中装载了服务端要返回给客户端的数据。</p></li></ul><p>可以看到响应报文与请求报文的格式类似，最大的不同的就是第一行用状态信息代替了请求信息，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP-Version Status-Code Reason-Phrase CRLF</span><br></pre></td></tr></table></figure></p><p>其中HTTP-Version代表HTTP协议版本，Status-Code代表响应状态码，Reason-Phrase代表状态码的文本描述，其中状态码的5种取值范围如下：</p><table><thead><tr><th style="text-align:center">取值范围</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">100~199</td><td style="text-align:left">表示请求已被接收，继续处理</td></tr><tr><td style="text-align:center">200~299</td><td style="text-align:left">表示请求已被成功接收，理解，接收</td></tr><tr><td style="text-align:center">300~399</td><td style="text-align:left">重定向，要完成请求必须要进一步的操作</td></tr><tr><td style="text-align:center">400~499</td><td style="text-align:left">客户端错误，表示请求有语法错误或请求无法实现</td></tr><tr><td style="text-align:center">500~599</td><td style="text-align:left">服务端错误，表示服务器未能实现合法的请求</td></tr></tbody></table><p>例如这是一个GET请求的返回的响应报文格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP1.1 200 OK</span><br><span class="line">Data:Sat, 30, Dec 2006 23:23:00 GMT</span><br><span class="line">Content-Type:text/plain；charset=UTF-8</span><br><span class="line">Content-Length:14</span><br><span class="line"></span><br><span class="line">&#123;data:这里是返回结果&#125;</span><br></pre></td></tr></table></figure></p><p>上面表示，响应状态码为200，表示请求成功，返回数据类型为text/plain，编码为UTF-8，内容长度为7，空行之后就为返回的数据。</p><h4 id="2-1、常见的状态码"><a href="#2-1、常见的状态码" class="headerlink" title="2.1、常见的状态码"></a>2.1、常见的状态码</h4><ul><li>200 OK：客户端请求成功</li><li>400 Bad Request：客户端请求有语法错误，不能被服务器理解</li><li>401 Unauthorized：请求未授权</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li><li>404 Not Found：请求资源不存在</li><li>500 Internal Server Error：服务器发生不可预估的错误</li><li>503 Server Unavailable：服务器当前不能处理客户端请求，一段时间后可能恢复正常</li></ul><h2 id="常见的首部字段"><a href="#常见的首部字段" class="headerlink" title="常见的首部字段"></a>常见的首部字段</h2><p>这里列举了一些在请求报文和响应报文中常见的首部：</p><ul><li>Content-Type：请求数据的格式</li><li>Content-Length：消息长度</li><li>Host：请求的主机名</li><li>User-Agent：发出请求的浏览器类型，可以自行设置</li><li>Accept：客户端可识别的内容类型列表</li><li>Accept-Endcoding：客户端可识别的数据编码</li><li>Connection：允许客户端和服务端指定与请求/响应连接相关的选项，如设置为Connection：Keep-Alive，表示保持连接</li><li>Transfer-Encoding：告知接收端为了保证报文的可靠传输性，对报文采用了什么的编码方式</li></ul><h3 id="1、Connection-：Keep-Alive工作原理-长连接"><a href="#1、Connection-：Keep-Alive工作原理-长连接" class="headerlink" title="1、Connection ：Keep-Alive工作原理 (长连接)"></a>1、Connection ：Keep-Alive工作原理 (长连接)</h3><p>从HTTP/1.1起，默认都开启了Keep-Alive保持连接特性，简单地说，当一个网页打开完成后，客户端和服务端之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务端上的网页，会继续使用这一条已经建立的TCP连接，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同服务器软件中设置这个时间。</p><p>那么，长连接是如何工作的呢？长短连接是运输层（TCP）的概念，HTTP是应用层协议，它只能说告诉运输层我打算一段时间内复用TCP通道，而没有自己去建立、释放TCP通道的能力。那么HTTP是如何告诉运输层复用TCP通道的呢？分为以下几个步骤：</p><ul><li>客户端第一次发送请求报文时，顺带发送一个Connection: keep-alive的Header，表示需要保持连接，同时客户端可以顺带发送Keep-Alive: timeout=5,max=100这个Header给服务端</li><li>然后服务端识别Connection: keep-alive这个Header，并且通过响应报文Header带同样的Connection: keep-alive，告诉客户端我可以保持连接</li><li>客户端和服务端之间通过保持的通道收发数据</li><li>当客户端最后一次发送请求报文，顺带发送Connection：close这个Header，表示长连接关闭</li></ul><p>Keep-Alive: timeout=5,max=100表示TCP连接最多保持5秒，长连接接受100次请求就断开，长连接虽好，但是长时间的TCP连接容易导致系统资源无效占用，浪费系统资源，所以需要有一些限制。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>网络请求已经成为了一个应用最基本的部分，所以熟悉HTTP对于我们开发很重要，我们不仅会用开发环境提供给我们的API，还要属性它的原理，这样开发才能做到胸有成竹。</p><p>参考资料：</p><p><a href="https://www.jianshu.com/p/84aa55a8a7eb" target="_blank" rel="noopener">Web的工作方式</a></p><p><a href="https://www.cnblogs.com/heluan/p/8620312.html" target="_blank" rel="noopener">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></p><p><a href="https://mp.weixin.qq.com/s/xU8X2gF_M_9_qzqbBdr4xQ" target="_blank" rel="noopener">深度解密 HTTP 通信细节</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着互联网的发展，网络已经越来越普及了，绝大多数的网络请求都是基于HTTP协议的，因此在开发中，了解HTTP的基本原理是必要的，在TCP/IP四层体系结构中，HTTP协议位于应用层，它是应用层主要使用的协议，应用层往下一层就是运输层，HTTP在运输层采用的是TCP协议来保证可靠传输，知道这些后，接下来详细介绍一下 Http。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
</feed>
