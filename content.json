[{"title":"使用AIDL来进行进程间通信","date":"2019-10-21T13:04:01.000Z","path":"2019/10/21/使用AIDL来进行进程间通信/","text":"前言AIDL它是Android众多进程间通信方式中的一种，底层是Binder机制的实现，所以想要读懂AIDL自动生成的代码中各个类的作用，就必须对Binder有一定的了解，其实不止AIDL，Android进程间通信的大多数方式的底层都是Binder机制，本文主要介绍AIDL的使用，所以不会介绍Binder机制的原理，关于Binder机制的原理，我推荐下面的一篇文章，零基础也能看懂： 写给 Android 应用工程师的 Binder 原理剖析 看完上面的文章你也就能对Binder原理的实现有大概的了解，对于我们Android应用开发也就足够了，如果你还不满足，想从底层和源码了解Binder机制，你可以阅读下面的两个链接： Android Bander设计与实现 Binder系列—开篇 上面两个系列就是从设计和源码的角度去解读Binder，有点深入。好了，对Binder有一个大体上的认识后，接下来我们就要通过AIDL的使用来完成Android进程间通信的实践。 Android进程间通信的方式在介绍AIDL之前，我们先来看一下Android中除了AIDL还有哪些进程间通信的方式： 1、Bundle Bundle实现了Parcelable，所以在Android中我们可以通过Intent在不同进程间传递Bundle数据。 但是在Intent 传输数据的过程中，用到了 Binder，Intent中的数据，即Bundle数据，会作为 Parcel 存储在Binder 的事务缓冲区(Binder transaction buffer)中的对象进行传输，而这个 Binder 事务缓冲区具有一个有限的固定大小，约为1MB，而且这个1Mb并不是当前进程所独享，而是所有进程共享的，所以由于1Mb的限制，Bundle不能存放大量的数据，不然会报TransactionTooLargeException，并且Bundle中存放的数据也要求能够被序列化，所以Bundle只适用于数据量小和简单的进程间通信。 2、文件共享 两个进程间通过读写同一个文件来交换数据。 但是由于Android允许并发的对同一个文件读写，所以如果两个进程同时的对这个文件写，就会出现问题，所以这适用于对数据同步要求不高的进程间通信。 3、ContentProvider ContentProvider是Android中专门用于不同应用之间，即不同进程之间进行数据共享的方式，它的底层实现是Binder。 ContentProvider是四大组件之一，它的使用比较简单，我们只需要继承自ContenProvider，并重写它的六个方法：onCreate、query、updata、insert、delete和getType，其中onCreate用于初始化，getType用于返回一个Uri请求代表的MIME类型，剩下的都是CRUD操作，除了onCreate方法运行在主线程，其他方法都运行在Binder线程池，然后在另外一个进程中注册这个ContentProvider，在本进程的Activity中通过getContentResolver()获得ContentResolver后，再通过ContentResolver来完成对这个ContentProvider的CRUD操作。 4、套接字(Socket) 一种传统的Linux IPC方式，除了用于不同进程之间还可以用于不同机器之间（通过网络传输）的通信，但是它的传输效率也是非常的低。 5、Messenger 通过Messenger可以在不同进程之间传递Message对象，Message中可以放入我们需要传递的数据，它的底层实现是AIDL。 但是Messenger在服务端的Handler是以串行的方式处理来自客户端的Message，所以如果有大量的并发请求，Messenger就效率低下，所以Messenger适用于数据并发量低的进程间通信。 6、AIDL 也就是本文的主角，它的底层实现是Binder。 可以看到Android中进程间通信的方式中，除了文件共享和Socket，底层都是需要通过Binder来传输数据，可见Binder对Android的进程间通信来说是多么的重要。 进程间通信的准备1、 序列化Android中要在进程间传输的数据都要是可序列化的，序列化就是把对象转换成二进制（字节流），从而可以存储到存储设备或者通过网络进行传输，有序列化，就有反序列，反序列化就是把二进制（字节流）转化为对象，其中8种基本数据类型默认可以在进程间传输，没有序列化的概念，序列化的作用对象是对象。在Android中，对象通过实现Serializable或Parcelable接口来实现序列化，下面简单介绍一下它们之间使用和区别： 1.1、SerializableSerializable是java中提供的一个序列化接口，它是一个空接口，对象实现这个Serializable接口，就标记这个对象是可序列化的，然后我们通过ObjectOutputStream的writeObject方法就能完成对象的序列化，如下： 1234User user = new User();ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"D://test.txt\"));os.writeObject(user);os.close(); 同理，通过ObjectOutputStream的readObject方法就能完成对象的反序列化，如下： 123ObjectOutputStream in = new ObjectInputStream(new FileInputStream(\"D://test.txt\"));User user = in.readObject();in.close(); 如果你在序列化这个对象之后有可能会改变这个对象的类结构，例如为类添加新的字段，这时在序列化这个对象之前你就要为这个对象的类加上一个serialVersionUID参数，如下： 1234public class User&#123; //serialVersionUID取什么值没关系，只要保持不变就行 private static final long serialVersionUID = 1L;&#125; 如果你确保这个对象的类结构在序列化之后是一直不变的，那么这个serialVersionUID可以忽略，为什么会这样呢？这是因为在序列化的时候，系统会把当前类的serialVersionUID写入到序列化的文件中，当反序列化时系统就会去检测文件中的serialVersionUID是否和当前类的serialVersionUID相同，如果相同就说明序列化的类和当前类的版本是相同的，这时候系统可以正确的反序列化，如果不一致，就说明序列化的类和当前类相比发生了某些变化，例如当前类添加了新的字段，这时就会反序列化失败，抛出异常。所以如果你手动指定了serialVersionUID的值，并一直保持不变，就算你改变了类的结构（不要改变类名和变量类型），序列化和反序列化时两者的serialVersionUID都是相同的，可以正常的进行反序列化，相反，如果你没有指定serialVersionUID的值，系统会根据类的结构自动生成它的hash值作为serialVersionUID的值，这时你改变了类的结构，在进行序列化和反序列化时两者生成的serialVersionUID不相同，这时反序列化就会失败，所以当你没有指定serialVersionUID的值，你要确保这个对象的类结构在序列化之后是一直不变。当然大多数情况下我们还是会指定serialVersionUID的值，以防我们不小心修改类的结构导致无法恢复对象。 这里只是列举了用Serializable实现对象序列化最简单的使用，其实我们可以通过transient关键字控制哪些字段不被序列化，还有静态成员不属于对象，不会参与序列化过程，还可以手动控制Serializable对象的序列化和反序列化过程，还关于Serializable更多使用方式可以看Java对象表示方式1：序列化、反序列化和transient关键字的作用。 1.2、ParcelableParcelable是Android提供的一个接口，一个对象只要实现了这个接口，就可以实现序列化，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class User implements Parcelable &#123; private final String name; private final String password; public User(String name, String password) &#123; this.name = name; this.password = password; &#125; public String getName() &#123; return name == null ? \"\" : name; &#125; public String getPassword() &#123; return password == null ? \"\" : password; &#125; //下面就是实现Parcelable接口需要实现的方法 @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(this.name); dest.writeString(this.password); &#125; public static final Parcelable.Creator&lt;User&gt; CREATOR = new Parcelable.Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel source) &#123; return new User(source); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; protected User(Parcel in) &#123; this.name = in.readString(); this.password = in.readString(); &#125;&#125; User中需要序列化的字段都会包装进Parcel中，当反序列化时，从Parcel中读取数据，Parcel内部包装了可序列化的数据，可以在进程间传输，其中describeContents方法用来完成内容描述，一般返回0，writeToParcel方法用来实现序列化，CREATOR对象的内部方法用来实现反序列化，其中createFromParcel方法用来从序列化后的对象中创建原始对象，newArray方法用来创建指定长度的原始对象数组。 Parcelable的用法相比Serializable复杂了一点，如果每次需要序列化一个对象，都要写这么多重复样本代码，会有点累，这里我推荐一个插件android-parcelable-intellij-plugin，专门用于自动生成这些重复样本代码。 1.3、Serializable和Parcelable的区别Serializable和Parcelable都可以实现序列化，用于进程间的数据传递，它们之间有什么区别呢？在编码上，Serializable使用简单，而Parcelable稍显复杂；在效率上，Serializable的开销很大，因为它只是一个空接口，我们无需实现任何方法，Java便会对这个对象进行序列化操作，这是因为java会通过反射创建所需方法，导致序列化的过程较慢，而Parcelable的效率高，它的速度比Serializable快十倍，通过把一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现了传递对象的功能；在使用场景上，Parcelable主要用在内存序列化上，它不能使用在要将数据序列化在磁盘上的情况，因为在外界有变化的情况下，Parcelable不能很好的保证数据的持续性，所以如果需要序列化到磁盘或通过网络传输建议使用Serializable，尽管它的效率低点。 综上所述，在Android开发中，如果有序列化的要求，我们多点考虑使用Parcelable，毕竟它是Android自带的，虽然它使用稍显复杂，但是有插件的帮助，加上它的效率高，就略胜Serializable了。 2、开启多进程模式既然是进程间通信，就一定会涉及到两个或两个进程以上，我们知道，在Android中，启动一个应用就代表启动了一个进程，但其实除了启动多个应用外，其实在一个应用中，也可以存在多个进程，只要你为四大组件在AndroidMenifest中指定“android:process”属性就行，比如我希望ClientActivity启动的时候，运行在独立的进程，我就会在AndroidMenifest中这样写，如下： 12345678910&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=\".ClientActivity\" android:process=\"com.example.aidltest.client\"/&gt; 可以看到我只是简单的ClientActivity指定了“android:process”属性，这样ClientActivity在启动的时候就会运行在进程名为com.example.aidltest.client的独立进程上，而MainActivity启动时，就会运行在默认进程上，默认进程的进程名为当前包名即com.example.aidltest。 需要注意的是，此时这两个Activity虽然在同一个应用，但是却不在同一个进程，所以它们是不共享内存空间的，Android会为每一个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，所以MainActivity和ClientActivity的内存地址空间不一样，它们要访问对方的数据的时候，都要通过进程间通信的方式来进行。 接下来为了方便后面的讲解，我把ClientActivity指定为主活动，把MainActivity删除，再创建一个Server，并为它指定process属性，如下： 123456789101112&lt;activity android:name=\".ClientActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;service android:name=\".RemoteService\" android:enabled=\"true\" android:exported=\"true\" android:process=\"com.example.aidltest.remote\"/&gt; ClientActivity启动时会运行在默认的进程上，RemoteService启动时会运行在名为com.example.aidltest.remote的进程上，它们在本文分别代表为本地客户端和远程服务端。 使用AIDL前面花了一点篇幅来讲解序列化和其他进程间通信的方式，主要是让大家有个心理准备，下面进入正文： 1、AIDL是什么它全称是Android Interface Definition Language，即Android接口定义语言，为了使其他的进程也可以访问本进程提供的服务，Android使用AIDL来公开服务的接口，它里面定义了本进程可以为其他进程提供什么服务，即定义了一些方法，其他进程就可以通过RPC（远程调用）来调用这些方法，从而获得服务，其中提供服务的进程称为服务端，获取服务的进程称为客户端。 2、AIDL接口的创建AIDL接口用来暴露服务点提供给客户端的方法，新建一个AIDL接口文件，只需要在你的项目中 点击包名 -&gt; 右键 -&gt; new -&gt; AIDL -&gt; Aidl.file，然后输入AIDL接口名称，这里我输入了IUserManager，然后点击Finish，就会在你的main目录下创建了一个aidl文件夹，aidl文件夹里的包名和java文件夹里的包名相同，里面用来存放AIDL接口文件，如下： 在里面你会发现你刚刚创建的AIDL接口IUserManager，点进去，如下： 12345678910111213// IUserManager.aidlpackage com.example.aidltest;// Declare any non-default types here with import statementsinterface IUserManager &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 里面声明了一个方法，写着AIDL支持的一些数据类型(int、long、boolean、float、double、String)，除了这些，AIDL还支持其他的基本数据类型、ArrayList(里面的每个元素都要被AIDL支持)、HashMap(里面的每个元素都要被AIDL支持)、实现了Parcelable接口的对象和AIDL接口本身，还有AIDL接口中只支持声明方法，不支持声明静态常量。 其中如果要在AIDL接口文件中使用AIDL对象，必须显式的 import 进来，即使它们在同一个包内，还有如果在AIDL接口文件用到了Parcelable对象，必须新建一个和它同名的AIDL文件，并在其中声明它为parcelable类型，接下来我要使用User这个Parcelable对象，所以我要在aidl文件夹下新建一个和他同名的AIDL文件，如下： 然后在User.aidl中添加如下内容： 1234// User.aidlpackage com.example.aidltest;parcelable User; 在里面，我声明了User.java这个对象为parcelable类型，接下来把IUserManager中的basicTypes方法删除，添加一个根据用户姓名获得用户信息的方法，如下： 123456789// IUserManager.aidlpackage com.example.aidltest;import com.example.adiltest.User;interface IUserManager &#123; User getUser(String name);&#125; 在里面我显示的 import 了User这个AIDL文件，即使它们在同一个包内，并声明了一个getUser方法，这个方法将会在服务端实现，然后在客户端调用(RPC)。 3、根据AIDL接口生成 对应的Binder类有了AIDL接口后我们需要根据AIDL接口生成客户端和服务端对应的Binder类，有两种方式生成，一种是通过SDK自动生成，另外一种是我们自己手动编码实现，其中能够进行手动编码实现的前提是基于对SDK自动生成的各种Binder类的充分理解，下面我们先来介绍SDK自动生成的Binder类。 3.1、SDK自动生成我们在AS导航栏 Build -&gt; ReBuild Project，SDK就会替我们在 app\\build\\generated\\aidl_source_output_dir\\debug\\compileDebugAidl\\out\\包名 下生成一个IUserManager.java，它就是根据IUserManager.aidl文件生成的，里面没有缩进，所以看起来不习惯，使用快捷键ctrl+alt+L，格式化一下代码，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//IUserManager.java/** * 1、IUserManager接口，getUser方法定义在其中 **/public interface IUserManager extends android.os.IInterface &#123; /** * 1、抽象类Stub，需要在远程服务端实现 */ public static abstract class Stub extends android.os.Binder implements com.example.aidltest.IUserManager &#123; private static final java.lang.String DESCRIPTOR = \"com.example.aidltest.IUserManager\"; public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; public static com.example.aidltest.IUserManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.aidltest.IUserManager))) &#123; return ((com.example.aidltest.IUserManager) iin); &#125; return new com.example.aidltest.IUserManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; java.lang.String descriptor = DESCRIPTOR; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(descriptor); return true; &#125; case TRANSACTION_getUser: &#123;//case TRANSACTION_getUser分支 data.enforceInterface(descriptor); java.lang.String _arg0; _arg0 = data.readString(); //调用getUser方法的具体实现 com.example.aidltest.User _result = this.getUser(_arg0); reply.writeNoException(); if ((_result != null)) &#123; reply.writeInt(1); _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; return true; &#125; default: &#123; return super.onTransact(code, data, reply, flags); &#125; &#125; &#125; /** * 2、代理类Proxy，客户端使用 */ private static class Proxy implements com.example.aidltest.IUserManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public com.example.aidltest.User getUser(java.lang.String name) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); com.example.aidltest.User _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(name); //传进了TRANSACTION_getUser字段 mRemote.transact(Stub.TRANSACTION_getUser, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) &#123; _result = com.example.aidltest.User.CREATOR.createFromParcel(_reply); &#125; else &#123; _result = null; &#125; &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; &#125; static final int TRANSACTION_getUser = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); &#125; public com.example.aidltest.User getUser(java.lang.String name) throws android.os.RemoteException;&#125; 这个文件有3个主要的类： 1、IUserManager接口 它声明了IUserManager.aidl定义的getUser方法，继承自IInterface。 2、IUserManager.Stub抽象类 IUserManager的静态内部类，它继承自Binder，说明它是一个 Binder 本地对象（Binder下面介绍），它虽然实现了IUserManager接口，但是它继续声明为一个抽象类，并没有实现IUserManager接口中的getUser方法，表明子类需要实现getUser方法，返回具体的User信息，而服务端将会实现这个Stub抽象类。 3、IUserManager.Stub.Proxy代理类 IUserManager.stub的静态内部类，它实现了IUserManager接口，并且实现了getUser方法，但是里面只是把数据装进data这个Parcel对象，通过mRemote的transact方法发送给服务端，接着用reply这个Parcel对象等待服务端数据的返回，这一切都是通过mRemote这个IBinder对象进行，mRemote代表着Binder对象的本地代理（IBinder下面介绍），mRemote会通过Binder驱动来完成与远程服务端的Stub的通信。 可以看到Stub类和Stub.Proxy类都实现了IUserManager接口，这就是一个典型的代理模式，它们的getUser方法有着不同的实现，Stub类它将会在远程的服务端完成getUser方法的具体实现，而Stub.Proxy类是本地客户端的一个代理类，它已经替我们默认的实现了getUser方法，该方法里面通过mRemote这个Binder引用的transact方法把请求通过驱动发送给服务端，我们注意到mRemote发送请求时还传进了TRANSACTION_getUser这个代表着getUser方法的标识名，这表示客户端告诉服务端我要调用getUser这个方法，当驱动把请求转发给服务端后，服务端的Stub类的onTransact方法就会回调，它里面有一个switch语句，根据code来调用不同的方法，这时它就会走到case TRANSACTION_getUser这个分支，然后调用getUser方法的在服务端的具体实现，如果有返回值的话，还会通过reply返回给客户端，这样就通过Binder驱动完成了一次远程方法调用(RPC)。 这里要注意的是客户端通过mRemote的transact方法把请求发送给客户端之后，这时会阻塞UI线程等待服务端的返回，而服务端的onTransact方法回调时，服务端的getUser方法会被回调，这时服务端的getUser方法是运行在服务端Binder线程池中，所以如果此时有UI操作需要回到UI线程再进行UI操作。 我们还注意到IUserManager接口继承了IInterface，IUserManager.Stub继承自Binder，它们是干什么的？我们来认识一下： IInterface 这是一个接口，用来表示服务端提供了哪些服务，如果服务端需要暴露调用服务的方法给客户端使用，就一定要继承这个接口，它里面有个asBinder方法，用于返回当前的Binder对象。 IBinder 这时一个跨进程通信的Base接口，它声明了跨进程通信需要实现的一系列抽象方法，实现了这个接口就说明可以进行跨进程通信，Binder和BinderProxy都继承了这个接口。 Binder 代表的是 Binder 本地对象（Binder实体），它继承自IBinder，所有本地对象都要继承Binder，Binder中有一个内部类BinderProxy，它也继承自IBinder，它代表着Binder对象的本地代理(Binder引用)，Binder实体只存在于服务端，而Binder引用则遍布于各个客户端。 接下来我们动手实践一下，首先在服务端RemoteService中，我们要这样做： 1234567891011121314151617181920public class RemoteService extends Service &#123; //1、实现Stub类中的getUser方法 private IUserManager.Stub mBinder = new IUserManager.Stub() &#123; @Override public User getUser(String name) throws RemoteException &#123; //这里只是简单的返回了一个用户名为name，密码为123456的用户实例 return new User(name, \"123456\"); &#125; &#125;; public RemoteService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; //2、在onBinder方法中返回Stub类的实现，Stub类继承自Binder，Binder实现了IBinder，这样返回是没问题的 return mBinder; &#125;&#125; 在服务端我们需要实现Stub类中的getUser方法，然后在onBinder方法中返回Stub类的实现，这样客户端绑定服务时就会收到这个Stub类的Binder引用。 然后在客户端ClientActivity中，我们要这样做： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ClientActivity extends AppCompatActivity &#123; private static final String TAG = ClientActivity.class.getSimpleName(); //1、创建ServiceConnection private ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(TAG, \"onServiceConnected, 与服务端连接成功！\"); //把服务端返回的Binder引用，通过Stub.asInterface方法包装成本地代理类IUserManager.Stub.Proxy，Proxy类实现了IUserManager，所以这样写是没问题的 IUserManager userManager = IUserManager.Stub.asInterface(service); try &#123; //通过本地代理对象远程调用服务端的方法 User user = userManager.getUser(\"rain\"); Log.d(TAG, \"onServiceConnected，向服务端获取用户信息成功，User = [\" + \"name = \" + user.getName() + \"password = \" + user.getPassword()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(TAG, \"onServiceDisconnected, 与服务端断开连接\"); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //2、启动并通过ServiceConnection绑定远程服务 bindService( new Intent(this, RemoteService.class), mServiceConnection, Context.BIND_AUTO_CREATE ); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //3、解绑服务 unbindService(mServiceConnection); &#125;&#125; 在服务端我们首先要创建ServiceConnection，然后通过ServiceConnection来绑定RemoteService，在成功绑定后，ServiceConnection的onServiceConnected方法就会回调，它的第二个输入参数就是RemoteService在onBind方法返回的Stub类的Binder引用，我们拿到这个引用后，就可以通过通过Stub.asInterface方法转换为本地代理类Stub.Proxy，然后调用它的getUser方法，Proxy的getUser方法会远程调用RemoteService的getUser方法，方法返回后，在log中打印出User的信息，最后，活动结束，我们记得解绑服务，这个过程和上面介绍的一次RPC过程是一样的。 我们发现完成一次进程间的通信是非常的简单，这就好像只是简单的调用一个对象的方法，但其实这都得益于Binder在底层为我们做了更多工作，我们上层使用得有多简单，它得底层实现就有多复杂，上面的一次进程间通信，可以简单的用下图表示： 其中ServiceManager就是根据Binder的名字查找Binder引用并返回，如果你对Binder的通信架构有一定的了解，理解这个就不难，对象转换就是完成Binder实体 -&gt; Binder引用，Binder引用 -&gt; Binder实体的转换，在java层继承自Binder的都代表Binder本地对象，即Binder实体，而Binder类的内部类BinderProxy就代表着Binder对象的本地代理，即Binder引用，这两个类都继承自IBinder, 因而都具有跨进程传输的能力，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。 我们重点讲一下图中的第3步：将Binder引用赋值给Proxy的mRemote字段，Proxy就是前面介绍的Stub.Proxy，所以接着我们看看IUserManager.Stub.asInterface(IBinder)方法是如何把服务端返回的Binder引用赋值给本地的代理类Proxy的mRemote字段，asInterface方法如下： 1234567891011121314151617181920212223242526//IUserManager.Stub.javapublic static com.example.aidltest.IUserManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; //根据DESCRIPTOR调用IBinder的queryLocalInterface方法 android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.aidltest.IUserManager))) &#123; return ((com.example.aidltest.IUserManager) iin); &#125; return new com.example.aidltest.IUserManager.Stub.Proxy(obj);&#125;//Binderpublic @Nullable IInterface queryLocalInterface(@NonNull String descriptor) &#123; if (mDescriptor != null &amp;&amp; mDescriptor.equals(descriptor)) &#123; //mOwner等于Stub类实例 return mOwner; &#125; return null;&#125;//Binder#BinderProxypublic IInterface queryLocalInterface(String descriptor) &#123; return null;&#125; 可以发现它里面根据DESCRIPTOR标识调用IBinder的queryLocalInterface方法在查找一些什么，DESCRIPTOR是什么？DESCRIPTOR是Binder实体的唯一标识，一般用当前的Binder的类名表示，它定义在Stub类中，如本文的Stub的 DESCRIPTOR = “com.example.aidltest.IUserManager”，前面已经讲过Binder和BinderProxy都继承自IBinder，所以它们的queryLocalInterface有不同的实现，我们看到BinderProxy的直接返回null；而Binder的需要和自己的DESCRIPTOR比较，如果相同就返回mOwner，否则返回null，其中mOwner就等于Stub类实例，在Stub类构造的时候赋值，如下： 123456789101112131415public static abstract class Stub extends android.os.Binder implements com.example.aidltest.IUserManager &#123; private static final java.lang.String DESCRIPTOR = \"com.example.aidltest.IUserManager\"; public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; public void attachInterface(@Nullable IInterface owner, @Nullable String descriptor) &#123; mOwner = owner; mDescriptor = descriptor; &#125; //...&#125; 这说明了如果queryLocalInterface的返回不为空，iin != null，表示obj是Binder实体（Stub的子类），客户端和服务端在同一个进程，asInterface方法返回的就是Binder实体；如果queryLocalInterface的返回为空，iin == nul，表示obj实际上是Binder引用，客户端和服务端在不同的进程，asInterface构造一个Proxy对象返回，并把Binder引用通过构造传了进去，我们看Proxy的构造函数，如下： 123456789private static class Proxy implements com.example.aidltest.IUserManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; //...&#125; 可以看到，传进去的Binder引用赋值给了mRemote字段，所以Proxy中的mRemote就是Binder引用，客户端就是通过这个mRemote来和服务端通信。 也就是说，如果在同一个进程，asInterface返回的是Stub的实现类，因为不存在跨进程调用，直接调用该方法就行，如果在不同进程，asInterface返回的是Proxy对象，客户端调用Proxy中的同名方法，通过mRemote的transact方法挂起当前线程等待服务端返回，服务端收到请求后响应返回数据。 到这里，相信大家在SDK把帮助下已经会使用AIDL来完成简单的进程间通信，接下来通过手动编码实现。 3.2、手动编码实现我们发现使用AIDL系统会自动的帮我们生成上述代码，是为了方便我们的开发，系统根据AIDL文件生成的java文件格式是固定，我们完全可以抛开AIDL直接手写对应的Binder类，下面我们本着单一原则把原本IUserManager.java的里面的Stub类和Stub类中的Proxy类独立出来，所以我们总共要写3个类，分别是：IUserManager、Stub、Proxy。 1、声明一个继承自IInterface的接口 声明一个继承自IInterface的接口，在里面定义我们想要让客户端调用的方法，如下： 123public interface IUserManager extends IInterface &#123; User getUser(String name);&#125; 2、声明服务端的Stub类 Stub类需要继承Binder，表明它是一个Binder本地对象，它还需要实现IUserManager接口，但是继续声明为抽象类，不需要实现IUserManager的getUser方法，接着我们做以下几步： 1、在里面定义一个字符串DESCRIPTOR，表示Binder实体的唯一标识，用当前的Stub类的类名表示，并把它的可见修饰符改为public，待会在Proxy需要用到. 2、在构造函数中把this 和 DESCRIPTOR字符串 attach 给父类Binder中的mOwner和mDescriptor字段. 3、定义一个TRANSACTION_getUser整型数值代表着getUser方法的标识名，赋值格式照抄自动生成的Stub类的TRANSACTION_getUser. 4、定义一个asInterface静态方法，里面的内容实现照抄自动生成的Stub类的asInterface方法，需要注意里面的IUserManager接口需要换成我们刚刚定义的IUserManager接口. 5、最后重写IInterface的asBinder方法和Binder的onTransact方法，里面的内容实现照抄自动生成的Stub类的asBinder和onTransact方法. 最终这个Stub类如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public abstract class Stub extends Binder implements IUserManager &#123; public static final String DESCRIPTOR = \"com.example.aidltest.Stub\";//这里改成com.example.aidltest.Stub static final int TRANSACTION_getUser = (IBinder.FIRST_CALL_TRANSACTION + 0); public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; public static IUserManager asInterface(android.os.IBinder obj) &#123;//导入我们自定义的IUserManager if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof IUserManager))) &#123; return (IUserManager) iin; &#125; return new Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; java.lang.String descriptor = DESCRIPTOR; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(descriptor); return true; &#125; case TRANSACTION_getUser: &#123; data.enforceInterface(descriptor); java.lang.String _arg0; _arg0 = data.readString(); com.example.aidltest.User _result = this.getUser(_arg0); reply.writeNoException(); if ((_result != null)) &#123; reply.writeInt(1); _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; return true; &#125; default: &#123; return super.onTransact(code, data, reply, flags); &#125; &#125; &#125;&#125; 3、声明客户端的Proxy类 Proxy类只需要实现IUserManager接口，并且实现IUserManager中的getUser方法，接着我们做以下几步： 1、定义一个IBinder类型的mRemote字段，并在构造函数中赋值. 2、实现IUserManager中的getUser方法和IInterface的asBinder方法，里面的内容实现照抄自动生成的Stub.Proxy的getUser方法和asBinder方法，需要注意getUser中的一些字段需要导入我们刚刚在Stub类中定义的字段. 最终这个Proxy类如下： 123456789101112131415161718192021222324252627282930313233343536public class Proxy implements IUserManager &#123; private IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; @Override public com.example.aidltest.User getUser(java.lang.String name) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); com.example.aidltest.User _result; try &#123; _data.writeInterfaceToken(Stub.DESCRIPTOR);//这里引用我们自己写的Stub的DESCRIPTOR _data.writeString(name); mRemote.transact(Stub.TRANSACTION_getUser, _data, _reply, 0);//这里引用我们自己写的Stub的TRANSACTION_getUser _reply.readException(); if ((0 != _reply.readInt())) &#123; _result = com.example.aidltest.User.CREATOR.createFromParcel(_reply); &#125; else &#123; _result = null; &#125; &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125;&#125; 最终整个工程目录如下： 4、使用 使用就很简单了，只需要把上面自动生成的IUserManager、IUserManager.Stub、IUserManager.Stub.Proxy替换成我们自己写的IUserManager、Stub、Proxy就行，就不再贴代码了，输出如下： 学完AIDL能干什么平常在Android中应用到进程间通信的场景非常的少，但这并不是说AIDL没有用，一个最直观的应用就是在阅读Android系统源码的时候，例如Activity的启动流程： Activity的启动流程（1） Activity的启动流程（2） 在android8.0之后Activity的有关进程间的通信都是通过AIDL来实现，Android根据IActivityManager.aidl文件来生成进程间通信所需的Binder类，如ApplicationThread在AMS的本地代理，AMS在ActivityThread的本地代理，当我们通过startActiivty发起Activity的启动请求时，ActivityThread就会通过AMS本地代理调用AMS的相应方法，当Actiivty在AMS准备好后，AMS就会通过ActivityThread本地代理回调应用进程的Activity的生命周期方法，这里就不在多述了，这个过程如下： 主要是通过这个例子说明，学习完AIDL后，能够帮助我们更好的理解系统源码有关跨进程的一些术语，类等，通过AIDL也能更好的加深我们对Android进程间通信的原理的理解，也掌握了一种进程间通信的方式。 结语本文简单的介绍了一下Android几种进程间通信的方式，然后通过SDK自动生成AIDL代码来理解了一下生成的代码中各个类的作用和关系，还根据自动生成AIDL代码来手动实现了一遍简单的跨进程通信，加深理解，掌握了一些基础AIDL知识，可能会有些不全面，但是足够基本使用，想要了解更全面的AIDL知识，最好的途径还是参阅官方文档：Android 接口定义语言 (AIDL) 本文源码地址 参考资料： Android系统中Parcelable和Serializable的区别 关于Binder，作为应用开发者你需要知道的全部","tags":[{"name":"IPC","slug":"IPC","permalink":"http://yoursite.com/tags/IPC/"},{"name":"AIDL","slug":"AIDL","permalink":"http://yoursite.com/tags/AIDL/"}]},{"title":"策略模式","date":"2019-10-19T14:56:38.000Z","path":"2019/10/19/策略模式/","text":"介绍在开发中也经常遇到这种情况，实现某一个功能往往有许多算法或者策略，我们在实际开发中选择不同的算法或策略来完成该功能。一般的情况是我们会把所有的算法或策略写入一个类中，通过if…else…或case语句来根据实际情况来选择具体算法或策略，但是这种方法会使这个类臃肿，维护难，当增加一种算法或策略时又要修改源代码，违反了面向对象的单一原则和开闭原则。如果将这些算法或者策略抽象出来，提供一个统一的接口，不同的算法或策略有不同的实现类，在实际使用时通过动态注入来实现算法或策略的替换，这种模式扩展性高，维护性好，也就是本次所说的策略模式。 定义策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们相互可以替换。让算法独立于客户端变化。 使用场景（1）需要安全的封装多种同一类型的操作时 （2）出现同一抽象类有多个子类，而又需要使用if..else..或case语句来选择具体子类时 类图 角色介绍： Context - 用来操作策略的上下文环境 Stragety - 策略的抽象 ConcreteStragetyA、B - 具体的策略实现 简单实现我们在写代码时经常会遇到对一个数组排序，排序的算法有很多比如插入排序，归并排序，冒泡排序等，我们在实际开发中要选择一种算法来对数组排序，一般情况下我们会这样写: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Client &#123; private static final int INSERT_SORT = 0;//插入排序 private static final int MERGE_SORT = 1;//归并排序 private static final int BUBBLE_SORT = 2;//冒泡排序 public static void main(String[] args)&#123; Client client = new Client(); int[] a = new int[]&#123;1, 2, 3, 4, 5, 6&#125;; client.show(a, INSERT_SORT); &#125; //显示结果 private void show(int[] a, int type)&#123; if(type == INSERT_SORT)&#123; insetSort(a); &#125;else if (type == MERGE_SORT)&#123; mergeSort(a); &#125;else if (type == BUBBLE_SORT)&#123; bubbleSort(a); &#125; for(int b : a)&#123; System.out.print(b + \" \"); &#125; &#125; //插入排序算法 private void insetSort(int[] a)&#123; //TODO... &#125; //归并排序算法 private void mergeSort(int[] a)&#123; //TODO... &#125; //冒泡排序算法 private void bubbleSort(int[] a)&#123; //TODO... &#125;&#125; 这里并不是讨论算法，就没有给出算法的具体实现，上面我们使用type类型通过if…else…语句来动态决定使用哪一种排序算法，当我们增加一种算法时，就要在函数中增加一个判断，以此类推，这样会使代码变得臃肿，一改很多处都要改。下面用策略模式进行重构，首先定义一个抽象的排序接口。 抽象的排序接口，即抽象策略角色 123public interface Sort&#123; &lt;T&gt; void sort(T[] a);&#125; 具体策略实现类 123456public class BubbleSort implements Sort &#123; @Override public &lt;T&gt; void sort(T[] a) &#123; //这里实现冒泡排序 &#125;&#125; 1234567public class InsertSort implements Sort&#123; @Override public &lt;T&gt; void sort(T[] a) &#123; //这里实现插入排序 &#125;&#125; 1234567public class MergeSort implements Sort &#123; @Override public &lt;T&gt; void sort(T[] a) &#123; //这里实现归并排序 &#125;&#125; 客户端，用来操作策略的上下文环境，即Context角色。 12345678910111213141516171819202122232425public class Client &#123; private Sort mSort; public static void main(String[] args)&#123; Client client = new Client(); //设置策略 Sort bubbleSort = new BubbleSort(); client.setmSort(bubbleSort); Integer[] a = &#123;1, 2, 3, 4, 5, 6&#125;; client.show(a); &#125; public void setmSort(Sort mSort) &#123; this.mSort = mSort; &#125; public void show(Integer[] a)&#123; mSort.sort(a); for(Integer b : a)&#123; System.out.print(b + \" \"); &#125; &#125;&#125; 通过上述实例可以清晰的看出两者的区别，前面说通过if..else语句来解决问题，而后者是通过建立抽象，将不同的算法构建成一个个具体的策略实现，通过不同的策略注入实现算法替换。 结语策略模式主要用来分离算法，在简化逻辑结构的同时，增强了系统的可读性，稳定性，可扩展性，这对于复杂的业务逻辑显得更为直观，通过建立抽象，注入不同实现，从而达到很好的扩展性。 本文源码相关位置","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"静态和动态代理模式","date":"2019-10-15T12:05:03.000Z","path":"2019/10/15/代理模式/","text":"前言代理模式，也称委托模式，是结构型设计模式之一，何为代理呢? 在日常生活中就比如叫朋友替你拿个快递，叫朋友替你做一下作业，叫朋友替你买点东西等等，这个朋友就是你的代理，你把事情委托你的朋友做了，同样在代码的世界中也存在代理，而且在你以后阅读到更多的设计模式时，你会发现很多的设计模式中也有代理模式的影子，代理模式是一个非常重要的设计模式，代理模式分为静态代理和动态代理，本文将会通过一个简单的例子讲解静态代理，然后引出动态代理，并且深入的探讨一下动态代理的实现原理。 代理模式的定义为其他对象提供一种代理以控制这个对象的访问。 使用场景静态代理和动态代理都适用于以下场景： 1、当不想访问某个对象或访问某个对象存在困难时，就可以为这个对象创建一个代理，通过代理来间接的访问这个对象； 2、如果原始对象有不同的访问权限，可以使用代理控制对原始对象的访问，保护原始对象； 3、在访问原始对象时执行一些自己的附加操作； 4、为某个对象在不同的内存地址空间提供局部代理，使得系统可以将服务端的实现隐藏，客户端不必考虑服务端的存在，例如Android中的Binder。 下面先简单的讲解一下静态代理。 静态代理1、类图 角色介绍: Subject — 抽象主题类，定义了代理对象和真实对象的共同接口方法，既可以是接口也可以是抽象类。 RealSubject — 真实主题类，该类可以被称为被委托类或被代理类，该类定义了代理对象所表示的真实对象，实现了Subject接口，而Client端通过代理类间接的调用的真实主题类中的方法，由其执行真正的业务逻辑。 ProxySubject — 代理类，该类也被称为委托类或代理类，该类中持有一个真实主题类的引用，同样实现了Subject接口，在其实现的接口方法中调用真实主题类中相应的接口方法，以此起到代理的作用。 Client — 客户端，使用代理。 这个类图就是静态代理的结构，在下面小明通过中介租房的例子中会有体现这几个角色的作用，而动态代理的类图结构与静态代理的稍有不同，将会在动态代理那里讲到，但动态代理和静态代理的整体思想是相同的，我们还需要注意一下下面会提到的一些近义词： Subject = 公共接口； ProxySubject = 代理对象 = 代理类 = 委托类 = 代理人； RealSubject = 真实对象 = 被代理类 = 被委托类 = 被代理人； 在根据不同的上下文时我会用不同的词表示Subject 、ProxySubject 和 RealSubject，还有委托和代理这个两个动词要根据上下文含义理解。 2、使用静态代理使用静态代理的基本步骤： 1、定义代理对象和真实对象的公共接口； 2、真实对象实现公共接口中的方法； 3、代理对象实现公共接口中的方法，并把方法的逻辑转发给真实对象。 我们通过小明买房的这个例子来讲解静态代理，小明想要在大城市租房，但是他平时很忙没有时间去看房，于是他就找到一个房产中介，把自己的租房意愿告诉房产中介，让房产中介来替自己解决租房问题，很明显房产中介就是代理人，小明就是被代理的人。 我们用静态代理来实现这个过程，首先定义一个租房步骤的公共接口： 1234567//租房步骤公共接口，即Subject角色public interface IRoom &#123; void seekRoom();//找房 void watchRoom();//看房 void room();//给钱租房 void finish();//完成租房&#125; 4个步骤完成租房，很简单，然后我们定义具体的想要租房的人即小明： 1234567891011121314151617181920212223//被代理人，想要租房的小明，即RealSubject角色public class XiaoMing implements IRoom &#123; @Override public void seekRoom() &#123; System.out.println(\"找房\"); &#125; @Override public void watchRoom() &#123; System.out.println(\"看房\"); &#125; @Override public void room() &#123; System.out.println(\"给钱租房\"); &#125; @Override public void finish() &#123; System.out.println(\"完成租房\"); &#125;&#125; 该类实现了IRoom接口，实现了其中的具体逻辑，但是小明并不会自己去打租房，他委托房产中介去做，所以这里定义一个房产中介： 1234567891011121314151617181920212223242526272829//代理人，房产中介，即ProxySubject角色public class RoomAgency implements IRoom &#123; private IRoom mRoom;//持有一个被代理人（小明）的引用 public RoomAgency(IRoom room)&#123; this.mRoom = room; &#125; @Override public void seekRoom() &#123; mRoom.seekRoom(); &#125; @Override public void watchRoom() &#123; mRoom.watchRoom(); &#125; @Override public void room() &#123; mRoom.room(); &#125; @Override public void finish() &#123; mRoom.finish(); &#125;&#125; 在该类中会持有一个被代理人的引用，在这里指小明，可以看到房产中介所执行的方法的实质就是简单的调用被代理人中的方法，下面来看看Client中具体的执行关系： 1234567891011121314151617//客户端，即Client角色public class Client &#123; public static void main(String[] args)&#123; //小明想租房 XiaoMing xiaoMing = new XiaoMing(); //找一个代理人，房产中介 RoomAgency roomAgency = new RoomAgency(xiaoMing); //房产中介找房 roomAgency.watchRoom(); //房产中介看房 roomAgency.seekRoom(); //房产中介租房 roomAgency.room(); //房产中介完成租房 roomAgency.finish(); &#125;&#125; 输出结果:1234看房找房给钱租房完成租房 上面就是傻瓜式的过程，一看就懂，房产中介代理了小明的找房、看房、租房等过程，可以看到静态代理模式还是很简单，就是一种委托机制，真实对象将方法委托给代理对象，那么房产中介继续代理其他人可以吗? 可以的，比如XiaoHong也想租房，我们再定义一个XiaoHong实现IRoom接口，并在Client中给房产中介RoomAgency代理就行。 3、缺点但是如果小明是想要买房而不是租房，这时房产中介还能满足小明的需求吗？很显然不能了，因为这个房产中介它只有替人租房的能力，没有替人买房的能力，这时就需要更换租房接口为买房接口，再定义一个专门买房的的房产中介，你会发现我每次更换接口，都需要更换代理类，这就是静态模式的缺点，只能为给定接口下的实现类做代理，如果接口不同就需要定义不同的代理类，随着系统的复杂度增加，就会很难维护这么多代理类和被代理类之间的关系，这时动态代理就应运而生，当需要频繁的更换接口，更换代理类时，采用动态代理是一个更好的选择，动态代理可以通过一个代理类来代理N多个被代理类，它在更换接口时，不需要重新定义代理类，因为动态代理不需要根据接口提前定义代理类，它把代理类的创建推迟到代码运行时来完成。 4、与动态代理的区别我们先来复习一下class文件的加载，我们编写的.Java文件经过javac编译之后，会产生.class文件，这种.class文件是二进制文件，里面的内容是只有JVM能够识别，在代码运行之前，JVM会读取.class文件，解析.class文件内的信息，取出二进制数据，加载进内存中，从而生成对应的Class对象。 而静态代理和动态代理最主要的区别就是：静态代理在我们的代码运行之前，代理类的.class文件就已经存在，例如上述的RoomAgency.java，在经过javac编译之后，就会变成RoomAgency.class；而动态代理则与静态代理相反，在代码运行之前不存在代理类的.class文件，在代码运行时才动态的生成代理类。 下面来讲解动态代理，并通过动态代理重新实现一遍小明买房的例子。 动态代理1、类图 这个就是动态代理的大概类图结构，其中Subject 、ProxySubject、 RealSubject和Client角色的作用和静态代理的一样，这里就不在累述，与静态代理相比，多了一个InvocationHandler角色和一个Proxy角色，InvocationHandler是java提供的一个接口，我们需要定义一个类实现InvocationHandler接口，这里就叫DynamicProxy角色；Proxy是java提供用于动态生成ProxySubject的一个类，它需要ProxySubject继承。 我们看到DynamicProxy在ProxySubject和RealSubject之前起到了中间人的角色，ProxySubject会把事情委托给DynamicProxy来做，而DynamicProxy最终把事情委托给RealSubject来做，可以这样说：ProxySubject代理了DynamicProxy，而DynamicProxy代理了RealSubject，其中最重要的一点是ProxySubject是在代码运行时才动态生成的，这是和静态代理的最大区别。 接下来简单介绍一下InvocationHandler接口，Proxy类。 1、InvocationHandler和Proxy的作用为了让我们更加容易的实现动态代理，java提供了动态代理接口InvocationHandler和动态代理类Proxy供我们使用，它们都在java.lang.reflect包中，可见动态代理和反射有不可逃脱的关系。 InvocationHandler接口 定义如下： 123456789public interface InvocationHandler &#123; /** * 这个方法的含义是：代理对象proxy要调用真实对象的method * @param proxy 代理对象 * @param method 真实对象被调用的方法 * @param args 被调用的方法的参数 */ Object invoke(Object proxy, Method method, Object[] args）throws Throwable;&#125; InvocationHandler接口的作用就是在invoke方法中执行真实对象的方法，可以看到里面只有一个invoke方法，我们需要为真实对象定义一个实现了这个接口中的invoke方法的动态代理类，同时在创建这个动态代理类的实例的时候，我们还要在方法或构造中传入真实对象的引用，即InvocationHandler的实现类需要持有真实对象的引用，这样才能执行真实对象的方法。 Proxy类定义如下： 1234567891011121314151617181920public class Proxy implements Serializable &#123; protected InvocationHandler h;//持有一个InvocationHandler类型的引用 protected Proxy(InvocationHandler h) &#123; this.h = h; &#125; //根据指定的类加载器和接口来获取代理对象的Class对象 public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class... interfaces) throws IllegalArgumentException &#123; //... &#125; //根据指定的类加载器和接口生成代理对象 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; //... &#125; //...&#125; Proxy这个类的作用就是用来动态的创建一个代理对象，它内部会持有一个InvocationHandler引用，在构造中传入，它提供了许多的方法，但是我们常用的是 getProxyClass方法和newProxyInstance方法： getProxyClass（重点方法）：这个方法的作用是在运行时根据.class的结构生成一个代理Class二进制流，并通过传入的ClassLoader去把代理Class二进制流加载成一个代理Class对象，该代理Class对象继承Proxy并实现了传入的第二个参数对应的Interface列表。 newProxyInstance(常使用的方法)： 这个方法的作用是在运行时根据代理Class对象生成代理对象实例，这个方法中会先调用了getProxyClass方法生成代理Class对象，在获取到代理Class对象后，根据第三个参数InvocationHandler引用通过反射创建代理对象实例，所以newProxyInstance最终的结果是生成一个代理对象实例，该代理对象会继承Proxy类并实现给定的接口列表，同时内部持有一个InvocationHandler引用。 以上两个方法过程现在看不懂不要紧，下面在讲解动态代理的源码分析时还会再分析一遍，我们通常会使用newProxyInstance方法来生成一个代理对象实例。 3、使用动态代理使用动态代理的基本步骤如下： 1、定义代理对象和真实对象的公共接口；（与静态代理步骤相同） 2、真实对象实现公共接口中的方法；（与静态代理步骤相同） 3、定义一个实现了InvocationHandler接口的动态代理类； 4、通过Proxy类的newProxyInstance方法创建代理对象，调用代理对象的方法。 1和2步骤都是和静态代理步骤相同的，就不在累述了，和静态代理相比，少了的一个步骤是：代理对象实现公共接口的方法，因为前面讲过代理对象是代码运行时通过Proxy动态创建的，所以不需要提前编写代理对象的类；和静态代理相比，多了的两个步骤是：3、定义一个实现了InvocationHandler接口的动态代理类和4、通过Proxy类的newProxyInstance方法创建代理对象，调用代理对象的方法，我们接着静态代理的小明买房的例子，下面分别讲解： 步骤3：我们需要定义一个动态代理类，它用于执行真实对象的方法：12345678910111213141516//实现了InvocationHandler接口的动态代理类public class DynamicProxy implements InvocationHandler &#123; private Object mObject;//真实对象的引用 public DynamicProxy(Object object)&#123; this.mObject = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //通过反射调用真实对象的方法 Object result = method.invoke(mObject, args); return result; &#125;&#125; 在该类中，我们声明了一个Object引用，该引用指向真实对象，真实对象在构造函数中传入，而在invoke方法中通过反射调用真实对象的具体方法，这里需要注意的是指向真实对象的引用类型最好定义为Objec类型t而不是真实对象的具体类型如XiaoMing，这样做的好处是，当你要代理另外一个人时，例如xiaoHong，我在DynamicProxy的构造函数中只需要传入xiaoHong引用而不用更改DynamicProxy的类结构，这样一个DynamicProxy就可以代理很多人。 接着步骤4：通过Proxy类newProxyInstance方法创建代理对象，调用代理对象的方法，下面是Client端逻辑: 123456789101112131415161718192021222324public class Client &#123; public static void main(String[] args) &#123; //构造一个小明 IRoom xiaoMing = new XiaoMing(); //构造一个动态代理 InvocationHandler dynamicProxy = new DynamicProxy(xiaoMing); //获取被代理类小明的ClassLoader ClassLoader classLoader = xiaoMing.getClass().getClassLoader(); //1、通过Proxy类的newProxyInstance方法动态构造一个代理人房产中介 IRoom roomAgency = (IRoom) Proxy.newProxyInstance(classLoader, new Class[]&#123;IRoom.class&#125;, dynamicProxy); //调用代理对象的方法 //房产中介找房 roomAgency.watchRoom(); //房产中介看房 roomAgency.seekRoom(); //房产中介租房 roomAgency.room(); //房产中介完成租房 roomAgency.finish(); &#125;&#125; 运行结果和前面的静态代理一致，就不再贴出，在介绍Proxy时讲过，Proxy的newProxyInstance方法会根据传入的类加载器动态生成代理对象实例，生成的代理对象会继承Proxy类并实现传入的接口列表，这里的类加载器是小明的ClassLoader，即真实对象的类加载器，而接口列表则是IRoom，传入的IRoom的Class对象，除了这个两个参数，还传入了动态代理类InvocationHandler实例，这样Proxy类在创建代理对象的实例时就会把这个InvocationHandler引用传给代理对象，接下来当我们调用代理对象的方法时，这个方法的处理逻辑就会委托给InvocationHandler实例的invoke方法执行，invoke方法中就会通过反射调用我们真实对象的方法。 下面我们通过源码看一下是怎样生成代理对象以及生成的代理对象是长什么样的。 4、源码分析我们看Client的注释1： 12//1、通过Proxy类的newProxyInstance方法动态构造一个代理人房产中介IRoom roomAgency = (IRoom) Proxy.newProxyInstance(classLoader, new Class[]&#123;IRoom.class&#125;, dynamicProxy); 我们先看Client的注释1，Proxy的newProxyInstance方法会根据传入的类加载器动态生成代理对象实例，我们点进Proxy的newProxyInstance方法看一下，如下： 12345678910111213141516171819202122232425262728293031//Proxy.java private static final Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;;public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; Objects.requireNonNull(h); //clone一下传入的接口列表 final Class&lt;?&gt;[] intfs = interfaces.clone(); //getProxyClass会把逻辑转发给getProxyClass0，所以getProxyClass的作用 = getProxyClass0的作用，它们的区别只是一个是public，一个是private的 //1、调用getProxyClass0，获得一个代理Class对象 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); try &#123; //constructorParams = InvocationHandler.class //2、这里通过代理Class对象获取构造参数为InvocationHandler的Constructor final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); //传入的InvocationHandler引用 final InvocationHandler ih = h; //这个Constructor是protected的，所以要设置为Public if (!Modifier.isPublic(cl.getModifiers())) &#123; cons.setAccessible(true); &#125; //3、通过构造参数为InvocationHandler的Constructor反射创建代理对象实例，并传入InvocationHandler引用给构造 return cons.newInstance(new Object[]&#123;h&#125;); &#125; //...省略异常处理&#125; 这个方法里面的流程还是很简单的，首先注释1，调用getProxyClass0，获得一个代理Class对象，getProxyClass0等于前面讲过的getProxyClass的作用，如下： 1234 public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) throws IllegalArgumentException&#123; //getProxyClass里面只是调用了getProxyClass0 return getProxyClass0(loader, interfaces);&#125; 可以看到，getProxyClass里面也是简单的调用getProxyClass0方法，所以getProxyClass0方法的作用就是我前面讲的getProxyClass方法的作用：在运行时根据.class的结构生成一个代理Class二进制流，并通过传入的ClassLoader去把代理Class二进制流加载成一个代理Class对象，该代理Class对象继承Proxy并实现了传入的第二个参数对应的Interface列表。 我们来看一下这个动态生成的代理Class对象的真实面目，首先在Client的main函数的开头填入下面的一代码： 1System.getProperties().put(\"jdk.proxy.ProxyGenerator.saveGeneratedFiles\", \"true\"); 填入后，运行Client的main函数就会在你的idea工作空间下的com/sun/proxy/目录下生成一个$Proxy0.class文件，这个$Proxy0.class就是动态生成的代理Class对象，即代理对象，如下： 这个.class文件里面都是JVM才能看懂的二进制，用idea打开，它会自动替你反编译成.java文件，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public final class $Proxy0 extends Proxy implements IRoom&#123; private static Method m1; private static Method m3; private static Method m4; private static Method m2; private static Method m5; private static Method m6; private static Method m0; //调用父类Proxy的构造函数，传入InvocationHandler引用 public $Proxy0(InvocationHandler paramInvocationHandler)&#123; super(paramInvocationHandler); &#125; //下面四个方法都是实现自IRoom的方法，可以看到它们只是简单的调用了父类的h的invoke方法，并把代理对象 $Proxy0实例、要调用的方法method，还有参数传了进去 public final void watchRoom()&#123; try&#123; this.h.invoke(this, m3, null); return; &#125; //...省略异常处理 &#125; public final void room()&#123; try&#123; this.h.invoke(this, m4, null); return; &#125; //...省略异常处理 &#125; public final void seekRoom()&#123; try&#123; this.h.invoke(this, m5, null); return; &#125; //...省略异常处理 &#125; public final void finish()&#123; try&#123; this.h.invoke(this, m6, null); return; &#125; //...省略异常处理 &#125; //...我们只关注IRoom接口中的方法，所以我省略了Object中继承而来的toSting，hashcode方法等，里面逻辑都一样，都是调用父类的h的invoke方法 static&#123; try&#123; m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] &#123; Class.forName(\"java.lang.Object\") &#125;); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); //获取IRoom接口方法的Method对象 m3 = Class.forName(\"com.example.hy.designpatternDemo.proxy.IRoom\").getMethod(\"watchRoom\", new Class[0]); m4 = Class.forName(\"com.example.hy.designpatternDemo.proxy.IRoom\").getMethod(\"room\", new Class[0]); m5 = Class.forName(\"com.example.hy.designpatternDemo.proxy.IRoom\").getMethod(\"seekRoom\", new Class[0]); m6 = Class.forName(\"com.example.hy.designpatternDemo.proxy.IRoom\").getMethod(\"finish\", new Class[0]); return; &#125; //...省略异常处理 &#125;&#125; 为了阅读方便，我省略了无关代码，可以看到Proxy类的getProxyClass0方法会替我们动态生成代理对象$Proxy0.class，这个代理对象会继承Proxy类，和实现接口列表，而这里传入的接口只有IRoom，所以$Proxy0会实现IRoom的方法，这些方法里面的逻辑都是调用父类的h的invoke方法，父类的h就是InvocationHandler引用，我们回去看newProxyInstance方法的注释2和3，你就会发现这个InvocationHandler引用是在通过反射创建$Proxy0实例时在构造中传入的。 我们在$Proxy0中还发现了很多Method对象，在$Proxy0的底部的static块中通过反射获取到我们IRoom接口所有方法的Method对象，当我们调用某个方法时，相应方法的method 和 代理对象$Proxy0实例、还有方法参数一起传进了父类的h的invoke方法中，所以我们在invoke方法中就可以根据method通过反射调用真实对象的相应方法，如下： 12345678910111213141516//实现了InvocationHandler接口的动态代理类public class DynamicProxy implements InvocationHandler &#123; private Object mObject;//真实对象的引用 public DynamicProxy(Object object)&#123; this.mObject = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //通过反射调用真实对象的方法 Object result = method.invoke(mObject, args); return result; &#125;&#125; 我们回到Client的注释1，所以当我们调用Proxy类的newProxyInstance方法，这个方法在里面创建了代理对象，并返回代理对象$Proxy0实例，所以当我们调用代理对象的方法时，我们就是在调用$Proxy0相应的方法，这个方法处理逻辑就会委托给InvocationHandler实例的invoke方法执行（代理对象的父类持有InvocationHandler引用），invoke方法中就会通过反射调用我们真实对象的方法（InvocationHandler的实现类中持有真实对象的引用），这就是整个动态代理的过程。 5、原理通过使用和源码分析，相信大家对动态代理有一个更加深入的了解，动态代理的原理就是通过反射机制动态生成代理类，这是因为由于JVM可以通过.class文件的二进制信息加载class对象的，那么，如果我们在代码运行时，遵循.class文件的格式和结构，生成相应的二进制数据，然后再把这个二进制数据通过JVM加载成对应的class对象，有了class对象，我们就可以在运行时通过反射创建出代理对象的实例，这样就完成了在代码运行时，动态的创建一个代理对象的能力，这就是动态代理的原理。 结语在静态代理模式中，代理类ProxySubject中的方法，都指定地调用了特定ReadSubject对应的方法；而在动态代理模式中，代理类ProxySubject中每一个方法的调用，都会交给InvocationHandler来处理，而InvocationHandler则调用了RealSubject的方法，以上就是我对静态代理和动态代理的理解，下面用一张表总结本文： 优点 缺点 区别 动态代理 1、代理类在程序运行时由反射自动生成，无需我们手动编写代理类代码，简化编程工作2、一个动态代理类InvocationHandler就能代理多个被代理类，较为灵活 1、动态代理只能代理实现实现了接口的类，而不能代理实现抽象类的类2、通过反射调用被代理类的方法，效率低 需要提前实现接口编写代理类，在代码运行之前，代理类的.class文件就已经存在 静态代理 1、代理类作为客户端和被代理类之间的中介，起到了保护被代理类的作用2、通过接口对代理类和被代理类进行解耦，降低了系统的耦合度 1、只能为给定接口下的实现类做代理，如果接口不一样那么就要重新定义不同的代理类，维护复杂2、由于在客户端和被代理类之间增加了代理对象，因此会造成请求的处理速度变慢 不需要提前实现接口编写代理类，在代码运行时，由JVM来动态的创建代理类 代理模式应用广泛，在实际开发中要根据实际情况进行选择。 本文源码位置 参考资料： 这是一份全面 &amp; 清晰的动态代理模式（Proxy Pattern）学习指南","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"代理","slug":"代理","permalink":"http://yoursite.com/tags/代理/"}]},{"title":"从进程的角度看Android的系统架构","date":"2019-10-08T08:32:55.000Z","path":"2019/10/08/从进程的角度看Android的系统架构/","text":"前言 上一篇文章Android的系统架构概述 上一篇文章从5个层次简述了Android的系统架构，那么这5个层次是怎么联系起来的呢？本文从进程的角度看Android的系统架构，简述一下Android系统启动的过程中，各大进程的启动顺序是如何的，本文并不会涉及到任何源码，只是为了让读者对Android的进程有个大概的了解。 先看一张图： 从这张图中可以找到Android官方给出的5个层次（Application、Framework（java）、库和运行时（native）、HAL、Kernel）的影子，java层与native层之间通过JNI调用打通，native层与kernel层通过Syscall调用打通。这个图就是你启动Android手机时Android系统的启动过程，下面从下到上分别介绍： 1、系统启动（Loader）长按电源键开机键： 1.1 Boot ROM引导芯片代码固化在ROM中，当你长按电源键开机时，会引导引导芯片代码从预定义的代码处开始执行，然后加载引导程序Boot Loader到RAM中。 1.2 Boot LoaderBoot Loader是Android系统启动之前的引导程序，顾名思义，就是将系统拉起来并启动。 2、Linux内核启动（Kernel）然后就到了Linux内核启动，内核启动时就会启动两个进程 — swapper（pid=0），kthreadd（pid=2）： 2.1、swapper（pid=0）swapper进程又称idle进程， 是系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作。 2.2、kthreadd（pid=2）kthreadd是Linux系统的内核进程，是所有内核进程的鼻祖，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。 3、init进程启动（Native）init进程是Linux系统的用户进程，它的pid=1，是所有用户进程的鼻祖，它是由许多源码文件组成的，它对应的源码目录在/system/core/init中。init进程有许多重要的职责： 孵化出许多用户空间的守护进程（ueventd、logd、healthd、installd、adbd、lmkd） 启动ServiceManager(binder服务管家)、bootanim(开机动画)等重要服务 孵化出Media Server进程，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。 孵化出Zygote进程4、Zygote进程启动（Native -&gt; java Framework）Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程，它是由init进程通过解析init.rc文件后fork生成的，Zygote的启动脚本放在/system/core/rootdir目录中。Zygote进程的职责主要有： 创建JVM虚拟机，并为JVM注册JNI方法 响应AMS的请求去创建新的应用进程 孵化出SystemServer进程5、SystemServer进程启动（java Framework）SystemServer进程是Zygote孵化的第一个进程，负责创建系统服务如ActivityManagerService，WindowManagerService，PackageManagerService，InputManagerService等服务，和管理整个Java framework。SystemServer进程的职责主要有： 创建Binder线程池，这样就可以与其他进程进行跨进程通信 启动SystemServiceManger，它用来对系统服务进行创建、管理和启动 通过SystemServiceManger启动各种系统服务：引导服务（如AMS，PMS），核心服务，其他服务（如WMS，IMS）6、Launcher进程启动（Application）SystemServer进程启动的过程中会启动PMS和AMS，PMS会把系统中的应用程序安装完成，然后AMS会请求Zygote将Launcher启动起来，这就是用户看到的app桌面，然后Launcher会将已经安装了的应用的应用图标显示出来。Launcher进程是Zygote进程孵化出来的第一个App进程。至此Android系统已经启动完毕，用户就可以点进桌面上的应用图标进入app，对于普通的app进程,跟SystemServer进程的启动过来有些类似，不同的是app进程是先发消息给SystemServer进程，由SystemServer向Zygote发出创建进程的请求，而SystemServer是由Zygote直接fork出来，前面已经说过Zygote是所有Java进程的父进程，SystemServer和所有的app进程都是由Zygote进程的子进程。 总结Android系统底层基于Linux Kernel, 当Kernel启动过程会创建init进程, 该进程是所有用户空间的鼻祖,init进程会启动ServiceManager(binder服务管家)、Zygote进程(Java进程的鼻祖)，Zygote进程会创建system_server进程以及各种app进程，下图是这几个系统重量级进程之间的层级关系。 从下而上，其中binder和socket都是Android中进程间的通信方式，而ServiceManager是binder服务的大管家，系统服务的binder实体都会注册到它身上。本文并没有深入的了解各个进程的启动，只是简单的让大家对Android系统主要的进程有个大概的了解，这样以后去研究相应的进程的源码时就会有个大概的方向。 参考资料： Android系统启动-综述","tags":[{"name":"进程","slug":"进程","permalink":"http://yoursite.com/tags/进程/"}]},{"title":"工厂模式","date":"2019-09-07T11:47:08.000Z","path":"2019/09/07/工厂模式/","text":"前言工厂方法模式是一种结构简单的模式，并且在我们的应用中很广泛，如Android中Activity的各个生命周期的回调，以onCreate方法为例，它就可以看做是一个工厂方法，我们在其中构造我们的View并返回给framework处理。 定义定义一个用于创建对象的接口，让子类决定实例化哪个类。 使用场景在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂方法模式，用new就能完成创建的对象无需使用工厂方法模式。 类图 角色介绍： Factory - 抽象工厂，是工厂方法的核心 ConcreteFactory - 具体工厂，实现了业务逻辑 Product - 抽象产品，是工厂方法模式所创建的产品的父类 ConcreteProduct - 为实现抽象产品的某个具体产品 简单实现下面生产汽车为例，要生产三款汽车，于是使用一条生产线来生产，我们先定义产品，产品是汽车。 抽象汽车，即抽象产品 123public abstract class Car &#123; public abstract void drive();&#125; 接下来是具体的车型 奥迪汽车，即具体的产品类 123456public class AudiCar extends Car &#123; @Override public void drive() &#123; System.out.println(\"奥迪汽车开始启动啦！\"); &#125;&#125; 奔驰汽车，即具体的产品类 1234567public class BenzCar extends Car &#123; @Override public void drive() &#123; System.out.println(\"奔驰车开始启动啦！\"); &#125;&#125; 宝马汽车，即具体的产品类 123456public class BWMCar extends Car &#123; @Override public void drive() &#123; System.out.println(\"宝马汽车开始启动啦！\"); &#125;&#125; 有了产品就要有工厂来生产，定义一个汽车抽象工厂。 抽象汽车工厂，即抽象工厂角色 123public abstract class CarFactory &#123; public abstract Car createCar();&#125; 接下来是具体的车型工厂。 生产奥迪车的工厂，即具体工厂类 12345678public class AudiCarFactory extends CarFactory &#123; @Override public Car createCar() &#123; return new AudiCar(); &#125;&#125; 生产奔驰车的工厂，即具体工厂类 123456public class BenzCarFactory extends CarFactory &#123; @Override public Car createCar() &#123; return new BenzCar(); &#125;&#125; 生产宝马车的工厂，即具体工厂类 123456public class BWMCarFactory extends CarFactory &#123; @Override public Car createCar() &#123; return new BWMCar(); &#125;&#125; 最后我们将各个汽车的生产组装成一条生产线。 客户端 12345678910111213141516171819202122public class Client &#123; public static void main(String[] args)&#123; //制造各个工厂 CarFactory audiFactory = new AudiCarFactory(); CarFactory benzFactory = new BenzCarFactory(); CarFactory bwmFactory = new BWMCarFactory(); //生产各种车 Car audiCar = audiFactory.createCar(); Car benzCar = benzFactory.createCar(); Car bwmCar = bwmFactory.createCar(); //车启动 audiCar.drive(); benzCar.drive(); bwmCar.drive(); &#125;&#125;输出结果:奥迪汽车开始启动啦！奔驰车开始启动啦！宝马汽车开始启动啦！ 可以看到我们需要哪种车型就可以定义哪种车型的具体工厂，像这样拥有多个工厂的的方式我们称之为多工厂模式，每个工厂各司其职。 但上面的方式不好的是会产生大量工厂，使代码臃肿，在实际开发中，我们可以使用反射的方式更加简洁的来生产具体的产品对象，此时需要在工厂方法的参数列表中传入一个Class类来决定是哪一个产品类。 使用反射的方式来生产具体的产品对象，抽象工厂角色 12345678public abstract class CarFactory2 &#123; /** * 抽象工厂方法，具体生产什么产品由子类决定 */ public abstract &lt;T extends Car&gt; T createCar(Class&lt;T&gt; car);&#125; 对于 具体的工厂，则通过反射获取类的实例即可 123456789101112131415161718public class ConcreteCarFactory extends CarFactory2 &#123; @Override public &lt;T extends Car&gt; T createCar(Class&lt;T&gt; car) &#123; Car c = null; try &#123; c = (T) Class.forName(car.getName()).newInstance(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return (T) c; &#125; &#125; 客户端 123456789101112131415public class Client &#123; public static void main(String[] args)&#123; //创建工厂 CarFactory2 carFactory = new ConcreteCarFactory2(); //生产车 AudiCar audiCar = carFactory.createCar(AudiCar.class); BenzCar benzCar = carFactory.createCar(BenzCar.class); BWMCar bwmCar = carFactory.createCar(BWMCar.class); //车启动 audiCar.drive(); benzCar.drive(); bwmCar.drive(); &#125;&#125; 输出和和上面一样，使用反射的方式，需要哪一个产品的对象，就传入哪一个产品的类的型即可，这种方式比较简洁，动态。 上面我们有三个工厂，如果我们只需要生产一种车型，即我们只有一个工厂时，我们就可以把抽象工厂简化掉，将对应的工厂方法改为静态方法，像下面，我们只生产一辆五菱车。 一个工厂，只生产一种产品 1234567public class Factory &#123; public static Car createWuLingCar()&#123; return new WuLingCar(); &#125; &#125; 像这样的方式又称为简单工厂方式或静态工厂方式，它是工厂方式模式的一个弱化版本。 总结工厂模式依赖于抽象的架构，将实例化的具体任务交给子类去完成，有非常好的扩展性。 本文源码相关位置","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Builder模式","date":"2019-09-07T11:35:25.000Z","path":"2019/09/07/Builder模式/","text":"前言Builder模式是一步步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更加精准的控制对象的构造过程，为了在构建过程中，对外部隐藏实现细节，就可以使用Builder模式将部件和组装过程分离，使得构建过程和部件可以自由扩展，两者之间的耦合度也降到最低。 定义将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。 使用场景（1）相同的方法不同的执行顺序产生不同的事件结果时 （2）多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不同时 （3）产品类比较复杂或者产品类中的调用顺序不同产生不同的作用时 （4）当初始化一个对象非常复杂，如参数非常多，且很多参数都具有默认值时 类图 类图介绍： Produc - 产品的抽象类 Builder - 抽象的Builder类，规范产品的组建，一般由子类实现具体的组建过程 ConcreteBuilder - 具体的Builder类 Director - 统一组装过程 简单实现计算机的组装过程比较复杂且组装顺序说不固定的，下面把计算机的组装过程简化为构建主机，设置操作系统，设置显示器3部分，然后通过Director和具体Builder来构建计算机对象。 计算机抽象类，即Product 12345678910111213141516171819202122232425262728293031323334public abstract class Computer &#123; protected String mBroad;//主板 protected String mDisplay;//显示器 protected String mOS;//操作系统 protected Computer()&#123;&#125; /** * 设置主板 * @param broad */ public void setmBroad(String broad)&#123; mBroad = broad; &#125; /** * 设置显示器 * @param display */ public void setmDisplay(String display)&#123; mDisplay = display; &#125; /** * 设置操作系统 */ public abstract void setmOS(); @Override public String toString() &#123; return \"Computer &#123;mBroad = \" + mBroad + \", mDisplay = \" + mDisplay + \", mOS = \" + mOS + \"&#125;\"; &#125;&#125; 苹果电脑，具体的Product 123456789public class Macbook extends Computer &#123; protected Macbook() &#123;&#125; @Override public void setmOS() &#123; mOS = \"Mac OS X 10.10\"; &#125;&#125; 抽象Builder类 12345678public abstract class Builder &#123; public abstract void buildBroad(String broad);//设置主机 public abstract void buildDisplay(String display);//设置显示器 public abstract void buildOS();//设置操作系统 public abstract Computer create();//创建Computer&#125; 具体的Builder类，构造苹果电脑 123456789101112131415161718192021222324public class MacBuilder extends Builder &#123; private Computer mComputer = new Macbook(); @Override public void buildBroad(String broad) &#123; mComputer.setmBroad(broad); &#125; @Override public void buildDisplay(String display) &#123; mComputer.setmDisplay(display); &#125; @Override public void buildOS() &#123; mComputer.setmOS(); &#125; @Override public Computer create() &#123; return mComputer; &#125;&#125; Director类，负责构造Computer 12345678910111213141516171819public class Director &#123; private Builder mBuilder; public Director(Builder builder) &#123; this.mBuilder = builder; &#125; /** * 构建对象 * @param broad * @param display */ public void construct(String broad, String display)&#123; mBuilder.buildBroad(broad); mBuilder.buildDisplay(display); mBuilder.buildOS(); &#125;&#125; 测试代码 123456789101112public class Test &#123; public static void main(String[] args)&#123; Builder builder = new MacBuilder(); Director director = new Director(builder); director.construct(\"英特尔主板\", \"Retina 显示器\"); System.out.println(\"Computer Info: \" + builder.create().toString()); &#125;&#125;输出结果 :Computer Info: Computer &#123;mBroad = 英特尔主板, mDisplay = Retina 显示器, mOS = Mac OS X 10.10&#125; 上面代码中，通过具体的MacBuilder来构建Macbook对象，而Director封装构建复杂对象的过程，对外隐藏细节。Builder与Director一起将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。 但在现实开发中，Director常常被忽略，直接使用一个Builder对象来进行链式调用构造，它的关键点是每个setter返回自身，如下，我们来组装一个华硕电脑： 华硕电脑，具体的产品类 1234567public class ASUSbook extends Computer &#123; @Override public void setmOS() &#123; mOS = \"Windows 10 专业版\"; &#125;&#125; 抽象Builder类 12345678public abstract class Builder2 &#123; public abstract Builder2 buildBroad(String broad);//设置主机 public abstract Builder2 buildDisplay(String display);//设置显示器 public abstract Builder2 buildOS();//设置操作系统 public abstract Computer create();//创建Computer &#125; 具体的Builder类，构造ASUS电脑 123456789101112131415161718192021222324252627public class ASUSBuilder extends Builder2 &#123; private Computer mComputer = new ASUSbook(); @Override public Builder2 buildBroad(String broad) &#123; mComputer.setmBroad(broad); return this; &#125; @Override public Builder2 buildDisplay(String display) &#123; mComputer.setmDisplay(display); return this; &#125; @Override public Builder2 buildOS() &#123; mComputer.setmOS(); return this; &#125; @Override public Computer create() &#123; return mComputer; &#125;&#125; 测试代码 12345678910111213141516171819public class Test &#123; public static void main(String[] args)&#123; Builder2 builder2 = new ASUSBuilder(); ASUSbook asusbook = (ASUSbook) builder2 .buildBroad(\"AMDB350socketAM4\") .buildDisplay(\"AOC 显示器\") .buildOS() .create(); System.out.println(\"Computer Info: \" + asusbook.toString());// Builder builder = new MacBuilder();// Director director = new Director(builder);// director.construct(\"英特尔主板\", \"Retina 显示器\");// System.out.println(\"Computer Info: \" + builder.create().toString()); &#125;&#125;输出结果 :Computer Info: Computer &#123;mBroad = AMDB350socketAM4, mDisplay = AOC 显示器, mOS = Windows 10 专业版&#125; 链式调用形式不仅去除Director角色，让整个结构简单，而且也能对product对象的组装过程有更加精准的控制。 然而上面的只是经典的实现方式，下面才是现在开发中最常用的，通过把Builder与产品类封装在一起，建立于上面的基础。 联想电脑，把Builder与产品类封装在一起 1234567891011121314151617181920212223242526272829303132333435363738394041public class LenovoBook extends Computer &#123; private LenovoBook(Builder builder)&#123; setmOS(); setmBroad(builder.broad); setmDisplay(builder.display); &#125; @Override public void setmOS() &#123; mOS = \"Windows 10 家庭中文版\"; &#125; public static class Builder extends Builder2&#123; String broad; String display; @Override public Builder2 buildBroad(String broad) &#123; this.broad = broad; return this; &#125; @Override public Builder2 buildDisplay(String display) &#123; this.display = display; return this; &#125; @Override public Builder2 buildOS() &#123; return this; &#125; @Override public Computer create() &#123; return new LenovoBook(this); &#125; &#125;&#125; 测试代码 12345678910111213141516public class Test &#123; public static void main(String[] args)&#123; LenovoBook lenovoBook = (LenovoBook) new LenovoBook.Builder() .buildOS() .buildBroad(\"联想主板\") .buildDisplay(\"联想显示器\") .create(); System.out.println(\"Computer Info: \" + lenovoBook.toString()); &#125;&#125;输出结果：Computer Info: Computer &#123;mBroad = 联想主板, mDisplay = 联想显示器, mOS = Windows 10 家庭中文版&#125; 总结Builder模式在开发中很常用，通过把产品类的构造器，字段私有化，只能通过Builder来设置属性，也通常作为配置类的构造器将配置的构建与表示分离开来，同时也是将配置从目标类中独立出来，避免过多的setter方法。Builder模式常用的实现形式是链式调用。 本文源码相关位置","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"责任链模式","date":"2019-09-07T08:46:01.000Z","path":"2019/09/07/责任链模式/","text":"前言责任链模式是一种链式结构，就是由一个个节点首尾相接串起来的结构，具有很好的灵活性，将每一个节点看作是一个对象，每一个对象拥有不同的处理逻辑，将一个请求从链式的首端发出，沿着链的路径依此传递每一个节点对象，直到有对象处理这个请求为止，我们将这样一种模式称为责任链模式。 定义使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。 使用场景 1、多个对象可以处理同一请求，但具体哪个对象处理则是在运行时动态决定 2、在请求者不明确的情况下向多个对象中的一个提交一个请求 3、需要动态指定一组对象的处理请求 类图 角色介绍： AbstractHandler - 抽象处理者角色，声明一个请求处理的方法（handle（））、一个获得处理级别的方法（getHandlerLever（））和封装了一个对具体的处理转发逻辑实现的方法（handleRequest（)），并在其中保持对下一个处理节点的AbstractHandler对象的引用（nextHandler） ConcreteHandler1、2 - 具体处理者角色，对请求进行处理，如果不能处理就将请求转发给下一个节点上的处理对象 AbstractRequest - 抽象的请求类，里面声明了一个获得请求内容的方法（getContent（））和一个获得请求处理级别的方法（getRequestLever（）） ConcreteRequest - 具体的请求类 简单实现在一个公司中，员工拿到了一份合同，需要上级的签名，于是员工就把合同给组长，但是组长没有权限签名，于是组长就把合同给经理，但是经理也没有足够的权限签名，于是经理就把合同给老板，老板二话不说就把合同给签了。上面的例子就是责任链模式，员工是请求的发起者，处于链的底端，而老板是处于链条顶端的类，员工发起请求后，请求经过层层转发，直至请求被处理，员工只是和组长发生了关联，后面合同被谁处理，员工并不知道，也并不关心，他在乎的是合同签名的结果，责任链模式很好的将请求的发起者与处理者解耦，下面用代码来模拟。 抽象的员工，即AbstractHandler角色 123456789101112131415161718public abstract class Staff &#123; protected Staff nextHandler;//上一级领导处理者 //处理转发的逻辑 public final void handleRequest(Contract contract)&#123; if(contract.getContractLever() &lt; getHandlerLever())&#123; handle(contract); &#125;else &#123; if(nextHandler != null)&#123; nextHandler.handleRequest(contract); &#125; &#125; &#125; public abstract int getHandlerLever();//自身能处理请求的级别 public abstract void handle(Contract contract);//具体的处理过程&#125; 在这个抽象的处理者中，一是定义了两个接口来确定一个Staff应有的行为和属性，二是封装了一个处理请求的逻辑转发方法，确定当前Staff是否有足够的级别来处理当前合同，如果没有，就把合同转发给上一级Staff，接下来是各个实现类。 组长，即ConcreteHandler角色 12345678910111213public class CroupStaff extends Staff &#123; @Override public int getHandlerLever() &#123; return 1; &#125; @Override public void handle(Contract contract) &#123; System.out.println(\"组长签名了合同！\"); &#125;&#125; 经理，即ConcreteHandler角色 1234567891011public class ManagerStaff extends Staff &#123; @Override public int getHandlerLever() &#123; return 2; &#125; @Override public void handle(Contract contract) &#123; System.out.println(\"经理签名了合同！\"); &#125;&#125; 老板，即ConcreteHandler角色 1234567891011public class BossStaff extends Staff &#123; @Override public int getHandlerLever() &#123; return 3; &#125; @Override public void handle(Contract contract) &#123; System.out.println(\"老板签名了合同！\"); &#125;&#125; 接下来看一看请求，就是合同。 抽象的合同类，即AbstractRequest角色 1234public abstract class Contract &#123; public abstract String getContext();//获得合同具体内容 public abstract int getContractLever();//获得合同处理级别&#125; 最后员工从组长发起请求。 请求发起者，员工 12345678910111213141516171819public class Employee &#123; public static void main(String[] args)&#123; //构造各个节点对象 GroupStaff groupStaff = new GroupStaff(); ManagerStaff managerStaff = new ManagerStaff(); BossStaff bossStaff = new BossStaff(); //构成一条链 groupStaff.nextHandler = managerStaff; managerStaff.nextHandler = bossStaff; //发起请求 Contract contract = new ConcreteContract(); groupStaff.handleRequest(contract); &#125;&#125;输出结果:老板签名了合同！ 其实这里也可以直接绕过组长和经理，直接找老板签名，这也是责任链模式的灵活性，请求的发起可以从任意节点发起，同时也可以改变责任链模式内部的传递规则，如直接找老板签名。 总结对于责任链模式中的节点，有两个行为，一是处理请求，二是将请求转发给下一个节点，不允许某个节点处理者处理了请求后又把节点转发给下一个节点。对于责任链中的请求，只有俩个结果，一个是被某个节点处理，一个是所有对象均没有处理。 本文相关源码位置","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"okhttp3源码分析之拦截器","date":"2019-09-07T07:01:40.000Z","path":"2019/09/07/okhttp3源码分析之拦截器/","text":"前言 上一篇文章：okhttp3源码分析之请求流程 本篇文章继续通过源码来探讨okhttp的另外一个重要知识点：拦截器，在上一篇文章我们知道，在请求发送到服务器之前有一系列的拦截器对请求做了处理后才发送出去，在服务器返回响应之后，同样的有一系列拦截器对响应做了处理后才返回给发起请求的调用者，可见，拦截器是okhttp的一个重要的核心功能，在分析各个拦截器功能的同时又会牵扯出okhttp的缓存机制、连接机制。 本文源码基于okhttp3.14.x okhttp项目地址：okhttp 拦截器的简单使用自定义一个拦截器需要实现Interceptor接口，接口定义如下： 123456789101112131415161718192021222324252627282930public interface Interceptor &#123; //我们需要实现这个intercept(chain)方法，在里面定义我们的拦截逻辑 Response intercept(Chain chain) throws IOException; interface Chain &#123; //返回Request对象 Request request(); //调用Chain的proceed(Request)方法处理请求，最终返回Response Response proceed(Request request) throws IOException; //如果当前是网络拦截器，该方法返回Request执行后建立的连接 //如果当前是应用拦截器，该方法返回null @Nullable Connection connection(); //返回对应的Call对象 Call call(); //下面的方法见名知意，返回或写入超时 int connectTimeoutMillis(); Chain withConnectTimeout(int timeout, TimeUnit unit); int readTimeoutMillis(); Chain withReadTimeout(int timeout, TimeUnit unit); int writeTimeoutMillis(); Chain withWriteTimeout(int timeout, TimeUnit unit) &#125;&#125; 可以看到Interceptor由两部分组成：intercept(Chain)方法和内部接口Chain，下面是自定义一个拦截器的通用逻辑，如下： 1234567891011121314151617181920public class MyInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; //1、通过传进来的Chain获取Request Request request = chain.request(); //2、 处理Request，逻辑自己写 //... //3、调用Chain的proceed(Request)方法处理请求，得到Response Response response = chain.proceed(request); //4、 处理Response，逻辑自己写 //... //5、返回Response return response; &#125;&#125; 上述就是一个拦截器的通用逻辑，首先我们继承Interceptor实现intercept(Chain)方法，完成我们自己的拦截逻辑，即根据需要进行1、2、3、4、5步，不管是自定义拦截器还是后面介绍的okhttp默认的拦截器大概都是这个模板实现，定义完拦截器后，我们在构造OkhttpClient时就可以通过addInterceptor(Interceptor)或addNetworkInterceptor(Interceptor)添加自定义拦截器，如下： 123456789OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(new MyInterceptor()) .build();或OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new MyInterceptor()) .build(); 这样okhttp在链式调用拦截器处理请求时就会调用到我们自定义的拦截器，那么addInterceptor(Interceptor)和addNetworkInterceptor(Interceptor)有什么不一样呢？它们一个是添加应用拦截器，一个是添加网络拦截器，主要是调用的时机不一样，更多区别可以参考官方WIKI文档Okhttp-wiki 之 Interceptors 拦截器，当我们平时做应用开发使用addInterceptor(Interceptor)就行了。 上述是我们自定义的拦截器，下面我们来看看okhttp默认的拦截器都干了什么。 RealCall :: getResponseWithInterceptorChain()在上一篇文章知道RealCall的getResponseWithInterceptorChain()是处理、发送请求并且返回响应的地方，我们再看一遍getResponseWithInterceptorChain()方法的源码，如下： 123456789101112131415161718192021222324252627282930313233343536//RealCall.javaResponse getResponseWithInterceptorChain() throws IOException &#123; //新建一个List用来保存拦截器 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); //添加我们自定义的应用拦截器 interceptors.addAll(client.interceptors()); //添加负责重试重定向的拦截器 interceptors.add(new RetryAndFollowUpInterceptor(client)); //添加负责转换请求响应的拦截器 interceptors.add(new BridgeInterceptor(client.cookieJar())); //添加负责缓存的拦截器 interceptors.add(new CacheInterceptor(client.internalCache())); //添加负责管理连接的拦截器 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123;//没有特殊要求，不使用WebSocket协议，WebSocket是什么？自行百度 //添加我们自定义的网络拦截器 interceptors.addAll(client.networkInterceptors()); &#125; //添加负责发起请求获取响应的拦截器 interceptors.add(new CallServerInterceptor(forWebSocket)); //构造第一个Chain Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); boolean calledNoMoreExchanges = false; try &#123; //调用Chain的proceed(Request)方法处理请求 Response response = chain.proceed(originalRequest); //... //返回响应 return response; &#125; //...省略异常处理 &#125; getResponseWithInterceptorChain()干了三件事：1、添加拦截器到interceptors列表中；2、构造第一个Chain；3、调用Chain的proceed(Request)方法处理请求。下面分别介绍: 1、添加拦截器到interceptors列表中除了添加我们自定义的拦截器外，还添加了默认的拦截器，如下： 1、RetryAndFollowUpInterceptor：负责失败重试和重定向。 2、BridgeInterceptor：负责把用户构造的Request转换为发送给服务器的Request和把服务器返回的Response转换为对用户友好的Response。 3、CacheInterceptor：负责读取缓存以及更新缓存。 4、ConnectInterceptor：负责与服务器建立连接并管理连接。 5、CallServerInterceptor：负责向服务器发送请求和从服务器读取响应。 这几个默认的拦截器是本文的重点，在后面会分别介绍。 2、构造第一个ChainChain是Interceptor的一个内部接口，它的实现类是RealInterceptorChain，我们要对它的传进来的前6个构造参数有个印象，如下： 12345678910111213141516public final class RealInterceptorChain implements Interceptor.Chain &#123; //... public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, Transmitter transmitter, @Nullable Exchange exchange, int index, Request request, Call call, int connectTimeout, int readTimeout, int writeTimeout) &#123; this.interceptors = interceptors;//interceptors列表 this.transmitter = transmitter;//Transmitter对象，后面会介绍 this.exchange = exchange;//Exchange对象，后面会介绍 this.index = index;//interceptor索性，用于获取interceptors列表中的interceptor this.request = request;//请求request this.call = call;//Call对象 //... &#125; //...&#125; 在后面的拦截器中都可以通过Chain获取这些传进来的参数。我们知道，为了让每个拦截器都有机会处理请求，okhttp使用了责任链模式来把各个拦截器串联起来，拦截器就是责任链的节点，而Chain就是责任链中各个节点之间的连接点，负责把各个拦截器连接起来。那么是怎么连接的？看下面的Chain的proceed方法。 3、调用Chain的proceed(Request)方法处理请求实际是RealInterceptorChain的proceed(Request)方法，如下： 123456789101112131415161718192021222324252627282930313233public final class RealInterceptorChain implements Interceptor.Chain &#123; //... @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, transmitter, exchange); &#125; public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange) throws IOException &#123; //index不能越界 if (index &gt;= interceptors.size()) throw new AssertionError(); //... //再新建一个Chain，这里注意index加1， RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout); //获取interceptors列表中的下一个拦截器 Interceptor interceptor = interceptors.get(index); //调用下一个拦截器的intercept(Chain)方法，传入刚才新建的RealInterceptorChain，返回Response Response response = interceptor.intercept(next); //... //返回响应 return response; &#125;&#125; proceed方法里面首先会再新建一个Chain并且index + 1作为构造参数传了进去，然后通过index从interceptors列表中获取了一个拦截器，接着就会调用拦截器的intercept方法，并把刚刚新建的Chain作为参数传给拦截器，我们再回顾一下上面所讲的拦截器intercept方法的模板，intercept方法处理完Request逻辑后，会再次调用传入的Chain的proceed(Request)方法，这样又会重复Chain的proceed方法中的逻辑，由于index已经加1了，所以这次Chain就会通过index获取下一个拦截器，并调用下一个拦截器的intercept(Chain)方法，然后如此循环重复下去，这样就把每个拦截器通过一个个Chain连接起来，形成一条链，把Request沿着链传递下去，直到请求被处理，然后返回Response，响应同样的沿着链传递上去，如下： 从上图可知，当没有自定义拦截器时，责任链首节点就是RetryAndFollowUpInterceptor，尾节点就是CallServerInterceptor，Request按照拦截器的顺序正向处理，Response则逆向处理，每个拦截器都有机会处理Request和Response，一个完美的责任链模式的实现。 知道了getResponseWithInterceptorChain()的整体流程后，下面分别介绍各个默认拦截器的功能。 RetryAndFollowUpInterceptor在自定义拦截器的时候就讲过，Interceptor的intercept(Chain)方法就是拦截器的拦截实现，RetryAndFollowUpInterceptor的intercept(Chain)方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//RetryAndFollowUpInterceptor.java@Override public Response intercept(Chain chain) throws IOException &#123; //获取Request Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; //获取Transmitter Transmitter transmitter = realChain.transmitter(); //重定向次数 int followUpCount = 0; Response priorResponse = null; //一个死循环 while (true) &#123; //调用Transmitter的prepareToConnect方法，做好连接建立的准备 transmitter.prepareToConnect(request); if (transmitter.isCanceled()) &#123; throw new IOException(\"Canceled\"); &#125; Response response; boolean success = false; try &#123; //调用proceed方法，里面调用下一个拦截器BridgeInterceptor的intercept方法 response = realChain.proceed(request, transmitter, null); success = true; &#125;catch (RouteException e) &#123;//出现RouteException异常 //调用recover方法检测连接是否可以继续使用 if (!recover(e.getLastConnectException(), transmitter, false, request)) &#123; throw e.getFirstConnectException(); &#125; continue; &#125; catch (IOException e) &#123;//出现IOException异常，和服务端建立连接失败 boolean requestSendStarted = !(e instanceof ConnectionShutdownException); //调用recover方法检测连接是否可以继续使用 if (!recover(e, transmitter, requestSendStarted, request)) throw e; continue; &#125; finally &#123;//出现其他未知异常 if (!success) &#123; //调用Transmitter的exchangeDoneDueToException()方法释放连接 transmitter.exchangeDoneDueToException(); &#125; &#125; //执行到这里，没有出现任何异常，连接成功, 响应返回 //... //根据响应码来处理请求头 Request followUp = followUpRequest(response, route); //followUp为空，不需要重定向，直接返回Response if (followUp == null) &#123; //... return response; &#125; //followUp不为空，需要重定向 //... //MAX_FOLLOW_UPS值为20，重定向次数不能大于20次 if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount); &#125; //以重定向后的Request再次重试 request = followUp; priorResponse = response; &#125;&#125; RetryAndFollowUpInterceptor的intercept(Chain)方法中主要是失败重试和重定向的逻辑，该方法流程如下： 1、首先获取Transmitter类； 2、然后进入一个死循环，先调用Transmitter的prepareToConnect方法，准备建立连接；（连接真正的建立在ConnectInterceptor中） 3、接着调用Chain的proceed方法，继续执行下一个拦截器BridgeInterceptor的intercept方法： ​ 3.1、如果在请求的过程中抛出RouteException异常或IOException异常，就会调用recover方法检测连接是否可以继续使用，如果不可以继续使用就抛出异常，整个过程结束，否则就再次重试，这就是失败重试； ​ 3.2、如果在请求的过程中抛出除了3.1之外的异常，就会调用Transmitter的exchangeDoneDueToException()方法释放连接，整个过程结束。 4、没有任何异常抛出，当响应Response返回后，就会调用followUpRequest方法，里面根据返回的Response的响应码来决定是否需要重定向（构造followUp请求），如果不需要重定向，就直接返回Response，如果需要重定向，那么以重定向后的Request再次重试，重定向次数不能大于20次。 1、Transmitter在整个方法的流程中出现了一个Transmitter，这里介绍一下，它是okhttp中应用层和网络层的桥梁，管理同一个Cal的所有连接、请求、响应和IO流之间的关系，它在RealCall创建后就被创建了，如下： 12345678//RealCall.javastatic RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; //创建RealCall RealCall call = new RealCall(client, originalRequest, forWebSocket); //创建Transmitter，赋值给call的transmitter字段 call.transmitter = new Transmitter(client, call); return call;&#125; 创建后，在构造节点Chain时作为参数传了进去，在getResponseWithInterceptorChain方法中有讲到，所以在intercept方法中它可以通过chain.transmitter()获得，它的整个生命周期贯穿了所有拦截器，在接下来的ConnectInterceptor和CallServerInterceptor中你都可以见到它的身影，我们看一下它的主要成员，如下： 123456789101112131415161718192021222324252627282930313233public final class Transmitter &#123; private final OkHttpClient client;//OkHttpClient大管家 private final RealConnectionPool connectionPool;//连接池，管理着连接 public RealConnection connection;//本次连接对象 private ExchangeFinder exchangeFinder;//负责连接的创建 private @Nullable Exchange exchange;//负责连接IO流读写 private final Call call;//Call对象 //... public Transmitter(OkHttpClient client, Call call) &#123; this.client = client; this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool()); this.call = call; this.eventListener = client.eventListenerFactory().create(call); this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS); &#125; public void prepareToConnect(Request request) &#123; if (this.request != null) &#123; if (sameConnection(this.request.url(), request.url()) &amp;&amp; exchangeFinder.hasRouteToTry()) &#123; return; // Already ready. &#125; //... &#125; this.request = request; //创建ExchangeFinder this.exchangeFinder = new ExchangeFinder(this, connectionPool, createAddress(request.url()), call, eventListener); &#125; &#125; 在Transmitter中client和call我们都认识，剩下的RealConnectionPool、RealConnection、ExchangeFinder、Exchange都和okhttp的连接机制有关，都会在ConnectInterceptor中介绍，Transmitter就是负责管理它们之间的关系。这里我们只要记住，Transmitter的prepareToConnect方法中主要是创建了一个ExchangeFinder，为在ConnectInterceptor中连接的建立做了一个准备。 BridgeInterceptorBridgeInterceptor的intercept(Chain)方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//BridgeInterceptor.java@Override public Response intercept(Chain chain) throws IOException &#123; //获取Request Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); //下面都是根据需要为Request的header添加或移除一些信息 RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(\"Content-Type\", contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(\"Content-Length\", Long.toString(contentLength)); requestBuilder.removeHeader(\"Transfer-Encoding\"); &#125; else &#123; requestBuilder.header(\"Transfer-Encoding\", \"chunked\"); requestBuilder.removeHeader(\"Content-Length\"); &#125; &#125; if (userRequest.header(\"Host\") == null) &#123; requestBuilder.header(\"Host\", hostHeader(userRequest.url(), false)); &#125; if (userRequest.header(\"Connection\") == null) &#123; requestBuilder.header(\"Connection\", \"Keep-Alive\"); &#125; boolean transparentGzip = false; if (userRequest.header(\"Accept-Encoding\") == null &amp;&amp; userRequest.header(\"Range\") == null) &#123; transparentGzip = true; requestBuilder.header(\"Accept-Encoding\", \"gzip\"); &#125; List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header(\"Cookie\", cookieHeader(cookies)); &#125; if (userRequest.header(\"User-Agent\") == null) &#123; requestBuilder.header(\"User-Agent\", Version.userAgent()); &#125; //调用proceed方法，里面调用下一个拦截器CacheInterceptor的intercept方法 Response networkResponse = chain.proceed(requestBuilder.build()); //返回Response后 //下面都是根据需要为Response的header添加或移除一些信息 HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(\"Content-Encoding\") .removeAll(\"Content-Length\") .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(\"Content-Type\"); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125; BridgeInterceptor中的逻辑是在所有默认拦截器中是最简单，它主要就是对Request或Response的header做了一些处理，把用户构造的Request转换为发送给服务器的Request，还有把服务器返回的Response转换为对用户友好的Response。例如，对于Request，当开发者没有添加Accept-Encoding时，它会自动添加Accept-Encoding : gzip，表示客户端支持使用gzip；对于Response，当Content-Encoding是gzip方式并且客户端是自动添加gzip支持时，它会移除Content-Encoding、Content-Length，然后重新解压缩响应的内容。 CacheInterceptorCacheInterceptor的intercept(Chain)方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//CacheInterceptor.java@Overridepublic Response intercept(Chain chain) throws IOException &#123; //根据Request得到Cache中缓存的Response，Cache是什么，后面介绍 Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); //创建缓存策略：网络、缓存、或两者都使用，CacheStrategy是什么，后面介绍 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); //得到networkRequest Request networkRequest = strategy.networkRequest; //得到cacheResponse，cacheResponse等于上面的cacheCandidate Response cacheResponse = strategy.cacheResponse; //... //这个Response缓存无效，close掉它 if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); &#125; //1、networkRequest为null且cacheResponse为null：表示强制使用缓存，但是没有缓存，所以构造状态码为504，body为空的Response if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504)//状态码504 .message(\"Unsatisfiable Request (only-if-cached)\") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; //2、networkRequest为null但cacheResponse不为null：表示强制使用缓存，并且有缓存，所以直接返回缓存的Response if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; //networkRequest不为null，所以可以发起网络请求，调用chain.proceed(Request)，里面调用下一个拦截器BridgeInterceptor的intercept方法，会返回网络请求得到的networkResponse networkResponse = chain.proceed(networkRequest); &#125; finally &#123; //发起网络请求出现IO异常或其他异常的处理 //... &#125; //3、networkRequest不为null且cacheResponse不为null：因为cacheResponse不为null，所以根据网络请求得到的networkResponse和缓存的cacheResponse做比较，来决定是否更新cacheResponse if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;//HTTP_NOT_MODIFIED等于304，304表示服务器缓存有更新，所以客户端要更新cacheResponse //下面根据networkResponse更新(重新构造)cacheResponse Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); //更新cacheResponse在本地缓存 cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123;//不需要更新cacheResponse，close掉它 closeQuietly(cacheResponse.body()); &#125; &#125; //4、networkRequest不为null但cacheResponse为null：cacheResponse为null，没有缓存使用，所以从networkResponse读取网络响应，构造Response准备返回 Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); //把Response缓存到Cache中 if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; //cacheResponse为null，所以这里是第一次缓存，把Response缓存到Cache中 CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; //返回Response return response;&#125; CacheInterceptor的intercept(Chain)里面定义了okhttp的缓存机制，我们先来了解两个类：Cache和CacheStrategy，这样才能看懂intercept(Chain)里面的逻辑。 1、Cache - 缓存实现Cache是okhttp中缓存的实现，内部使用了DiskLruCache，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public final class Cache implements Closeable, Flushable &#123; //... //内部都是通过DiskLruCache实现 final DiskLruCache cache; //有一个InternalCache实现，都调用了Cache中的方法 final InternalCache internalCache = new InternalCache() &#123; @Override public @Nullable Response get(Request request) throws IOException &#123; return Cache.this.get(request); &#125; @Override public @Nullable CacheRequest put(Response response) throws IOException &#123; return Cache.this.put(response); &#125; @Override public void remove(Request request) throws IOException &#123; Cache.this.remove(request); &#125; @Override public void update(Response cached, Response network) &#123; Cache.this.update(cached, network); &#125; @Override public void trackConditionalCacheHit() &#123; Cache.this.trackConditionalCacheHit(); &#125; @Override public void trackResponse(CacheStrategy cacheStrategy) &#123; Cache.this.trackResponse(cacheStrategy); &#125; &#125; //可以通过下面两个构造函数构造一个Cache public Cache(File directory, long maxSize) &#123; this(directory, maxSize, FileSystem.SYSTEM); &#125; Cache(File directory, long maxSize, FileSystem fileSystem) &#123; this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize); &#125; //下面是主要方法 @Nullable Response get(Request request) &#123; //... &#125; @Nullable CacheRequest put(Response response) &#123; //... &#125; void remove(Request request) throws IOException &#123; //... &#125; void update(Response cached, Response network) &#123; //... &#125; synchronized void trackConditionalCacheHit() &#123; //... &#125; synchronized void trackResponse(CacheStrategy cacheStrategy) &#123; //... &#125; @Override public void flush() throws IOException &#123; //... &#125; @Override public void close() throws IOException &#123; //... &#125;&#125; Cache中有一个内部实现类InternalCache，见名知意，它是okhttp内部使用的，它实现了InternalCache接口，接口中的方法都和Cache中的方法同名，而且这个实现类的所有方法都是调用了Cache中相应的方法，也就是说InternalCache的方法实现和Cache相应的方法一样，但Cache和InternalCache不一样的是，Cache比InternalCache多了一些方法供外部调用如flush()、 close()等，提供了更多对缓存的控制，而InternalCache中的方法都只是缓存的基本操作，如get、put、remove、update等方法，这些方法的逻辑都是基于Cache中的DiskLruCache实现，详情可以看DiskLruCache的原理实现。 要知道，okhttp默认是不使用缓存，也就是Cache为null，如果要使用缓存，我们需要自行配置，通过下面方法使用okhttp的缓存机制： 123456789//缓存的路径File cacheDir = new File(Constant.PATH_NET_CACHE);//这里通过带有两个参数的构造函数构造一个CacheCache cache = new Cache(cacheDir, 1024 * 1024 * 10);//缓存的最大尺寸10M//然后设置给OkHttpClientOkHttpClient client = new OkHttpClient.Builder() .cache(cache) .build(); 通过上面全局设置后，Cache和InternalCache都不会为null，因为在创建Cache时InternalCache也一起创建了，okhttp的缓存机制就会生效。 我们先回到CacheInterceptor的intercept方法，它首先一开始就要判断cache是否等于null，那么CacheInterceptor的cache在哪里来的呢？是在构造函数中，如下： 12345678public final class CacheInterceptor implements Interceptor &#123; final @Nullable InternalCache cache; public CacheInterceptor(@Nullable InternalCache cache) &#123; this.cache = cache; &#125; //...&#125; 可用看到它是InternalCache实例，在 getResponseWithInterceptorChain()中添加拦截器时就通过client为这个InternalCache赋值了，如下： 1234567//RealCall.javaResponse getResponseWithInterceptorChain() throws IOException &#123; //... //添加负责缓存的拦截器 interceptors.add(new CacheInterceptor(client.internalCache())); //...&#125; 注意到new CacheInterceptor(client.internalCache())，所以我们看client的internalCache方法，如下： 1234//OkHttpClient.java@Nullable InternalCache internalCache() &#123; return cache != null ? cache.internalCache : internalCache; &#125; cache就是上面全局设置的cache实例，所以不为null，返回cache中的internalCache实例，这样CacheInterceptor中就持有internalCache实例。 2、CacheStrategy - 缓存策略CacheStrategy是okhttp缓存策略的实现，okhttp缓存策略遵循了HTTP缓存策略，因此了解okhttp缓存策略前需要有HTTP缓存相关基础：HTTP 协议缓存机制详解，了解了HTTP缓存策略后，我们再来看CacheStrategy，如下： 1234567891011121314151617181920212223242526272829303132333435public final class CacheStrategy &#123; //CacheStrategy两个主要的成员变量：networkRequest、cacheResponse public final @Nullable Request networkRequest; public final @Nullable Response cacheResponse; CacheStrategy(Request networkRequest, Response cacheResponse) &#123; this.networkRequest = networkRequest; this.cacheResponse = cacheResponse; &#125; //... //通过工厂模式创建CacheStrategy public static class Factory &#123; final long nowMillis; final Request request; final Response cacheResponse; public Factory(long nowMillis, Request request, Response cacheResponse) &#123; this.nowMillis = nowMillis; this.request = request; this.cacheResponse = cacheResponse; //... &#125; public CacheStrategy get() &#123; CacheStrategy candidate = getCandidate(); //... return candidate; &#125; //... &#125;&#125; CacheStrategy是通过工厂模式创建的，它有两个主要的成员变量：networkRequest、cacheResponse，CacheInterceptor的intercept方法通过CacheStrategy的networkRequest和cacheResponse的组合来判断执行什么策略，networkRequest是否为空决定是否请求网络，cacheResponse是否为空决定是否使用缓存，networkRequest和cacheResponse的4种组合和对应的缓存策略如下： 1、networkRequest为null且cacheResponse为null：没有缓存使用，又不进行网络请求，构造状态码为504的Response。 2、networkRequest为null但cacheResponse不为null：有缓存使用，且缓存在有效期内，所以直接返回缓存的Response。 3、networkRequest不为null且cacheResponse不为null：有缓存使用，但缓存在客户端的判断中表示过期了，所以请求服务器进行决策，来决定是否使用缓存的Response。 4、networkRequest不为null但cacheResponse为null：没有缓存使用，所以直接使用服务器返回的Response networkRequest和cacheResponse在创建CacheStrategy时通过构造参数赋值，那么CacheStrategy在那里被创建呢？当调用CacheStrategy.Factory(long, Request, Response).get()时就会返回一个CacheStrategy实例，所以CacheStrategy在Factory的get方法中被创建，我们来看Factory的get方法，如下： 123456//CacheStrategy.Factorypublic CacheStrategy get() &#123; CacheStrategy candidate = getCandidate(); //... return candidate;&#125; 可以看到CacheStrategy通过Factory的getCandidate方法创建，getCandidate方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//CacheStrategy.Factoryprivate CacheStrategy getCandidate() &#123; //1、没有Response缓存，直接进行网络请求 if (cacheResponse == null) &#123; return new CacheStrategy(request, null); &#125; //2、如果TLS握手信息丢失，直接进行网络请求 if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) &#123; return new CacheStrategy(request, null); &#125; //3、根据Response状态码，Expired和Cache-Control的no-Store进行判断Response缓存是否可用 if (!isCacheable(cacheResponse, request)) &#123; //Response缓存不可用，直接进行网络请求 return new CacheStrategy(request, null); &#125; //获得Request的缓存控制字段CacheControl CacheControl requestCaching = request.cacheControl(); //4、根据Request中的Cache-Control的noCache和header是否设置If-Modified-Since或If-None-Match进行判断是否可以使用Response缓存 if (requestCaching.noCache() || hasConditions(request)) &#123; //不可以使用Response缓存，直接进行网络请求 return new CacheStrategy(request, null); &#125; //走到这里表示Response缓存可用 //获得Response的缓存控制字段CacheControl CacheControl responseCaching = cacheResponse.cacheControl(); //获得该Response已经缓存的时长 long ageMillis = cacheResponseAge(); //获得该Response可以缓存的时长 long freshMillis = computeFreshnessLifetime(); if (requestCaching.maxAgeSeconds() != -1) //一般取max-age freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds())); &#125; long minFreshMillis = 0; if (requestCaching.minFreshSeconds() != -1) &#123; //一般取0 minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds()); &#125; long maxStaleMillis = 0; if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) &#123; //取max-stale， maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds()); &#125; //5、判断缓存是否过期，决定是否使用Response缓存：Response已经缓存的时长 &lt; max-stale + max-age if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123; Response.Builder builder = cacheResponse.newBuilder(); if (ageMillis + minFreshMillis &gt;= freshMillis) &#123; builder.addHeader(\"Warning\", \"110 HttpURLConnection \\\"Response is stale\\\"\"); &#125; long oneDayMillis = 24 * 60 * 60 * 1000L; if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123; builder.addHeader(\"Warning\", \"113 HttpURLConnection \\\"Heuristic expiration\\\"\"); &#125; //5.1、缓存没有过期，直接使用该Response缓存 return new CacheStrategy(null, builder.build()); &#125; //5.2、缓存过期了，判断是否设置了Etag或Last-Modified等标记 String conditionName; String conditionValue; if (etag != null) &#123; conditionName = \"If-None-Match\"; conditionValue = etag; &#125; else if (lastModified != null) &#123; conditionName = \"If-Modified-Since\"; conditionValue = lastModifiedString; &#125; else if (servedDate != null) &#123; conditionName = \"If-Modified-Since\"; conditionValue = servedDateString; &#125; else &#123; //缓存没有设置Etag或Last-Modified等标记，所以直接进行网络请求 return new CacheStrategy(request, null); &#125; //缓存设置了Etag或Last-Modified等标记，所以添加If-None-Match或If-Modified-Since请求头，构造请求，交给服务器判断缓存是否可用 Headers.Builder conditionalRequestHeaders = request.headers().newBuilder(); Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue); Request conditionalRequest = request.newBuilder() .headers(conditionalRequestHeaders.build()) .build(); //networkRequest和cacheResponse都不为null return new CacheStrategy(conditionalRequest, cacheResponse);&#125; getCandidate()方法中根据HTTP的缓存策略决定networkRequest和cacheResponse的组合，从getCandidate()方法中我们可以看到HTTP的缓存策略分为两种： 1、强制缓存：客户端参与决策决定是否继续使用缓存，客户端第一次请求数据时，服务端返回了缓存的过期时间：Expires或Cache-Control，当客户端再次请求时，就判断缓存的过期时间，没有过期就可以继续使用缓存，否则就不使用，重新请求服务端。 2、对比缓存：服务端参与决策决定是否继续使用缓存，客户端第一次请求数据时，服务端会将缓存标识：Last-Modified/If-Modified-Since、Etag/If-None-Match和数据一起返回给客户端 ，当客户端再次请求时，客户端将缓存标识发送给服务端，服务端根据缓存标识进行判断，如果缓存还没有更新，可以使用，则返回304，表示客户端可以继续使用缓存，否则客户端不能继续使用缓存，只能使用服务器返回的新的响应。 而且强制缓存优先于对比缓存，我们再贴出来自HTTP 协议缓存机制详解的一张图，它很好的解释了getCandidate()方法中1~5步骤流程，如下： 3、缓存机制我们再回到CacheInterceptor的intercept方法，它的1~4步骤就是CacheStrategy的networkRequest和cacheResponse的4种组合情况，都有详细的注释，每一种组合对应一种缓存策略，而缓存策略又是基于getCandidate()方法中写死的HTTP缓存策略，再结合okhttp本地缓存的实现Cache，我们得出结论：okhttp的缓存机制 = Cache缓存实现 + 基于HTTP的缓存策略，整个流程图如下： 了解了okhttp的缓存机制后，我们接着下一个拦截器ConnectInterceptor。 ConnectInterceptorConnectInterceptor的intercept(Chain)方法如下： 1234567891011121314151617//ConnectInterceptor.java@Overridepublic Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); //获取Transmitter Transmitter transmitter = realChain.transmitter(); boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); //1、新建一个Exchange Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks); //调用proceed方法，里面调用下一个拦截器CallServerInterceptor的intercept方法 //这里调用的proceed方法是带有三个参数的，它传进了Request、Transmitter和刚刚新建的Exchange return realChain.proceed(request, transmitter, exchange);&#125; ConnectInterceptor的intercept(Chain)方法很简洁，里面定义了okhttp的连接机制，它首先获取Transmitter，然后通过Transmitter的newExchange方法创建一个Exchange，把它传到下一个拦截器CallServerInterceptor，Exchange是什么？Exchange负责从创建的连接的IO流中写入请求和读取响应，完成一次请求/响应的过程，在CallServerInterceptor中你会看到它真正的作用，这里先忽略。所以注释1的newExchange方法是连接机制的主要逻辑实现，我们继续看Transmitter的newExchange方法，如下： 123456789101112131415//Transmitter.javaExchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; //...省略异常处理 //1、通过ExchangeFinder的find方法找到一个ExchangeCodec ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks); //创建Exchange，并把ExchangeCodec实例codec传进去，所以Exchange内部持有ExchangeCodec实例 Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec); //... return result;&#125; 重点是注释1，ExchangeFinder对象早在RetryAndFollowUpInterceptor中通过Transmitter的prepareToConnect方法创建，它的find方法是连接真正创建的地方，ExchangeFinder是什么？ExchangeFinder就是负责连接的创建，把创建好的连接放入连接池，如果连接池中已经有该连接，就直接取出复用，所以ExchangeFinder管理着两个重要的角色：RealConnection、RealConnectionPool，下面讲解一下RealConnectionPool和RealConnection，有助于连接机制的理解。 1、RealConnection - 连接实现连接的真正实现，实现了Connection接口，内部利用Socket建立连接，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public interface Connection &#123; //返回这个连接使用的Route Route route(); //返回这个连接使用的Socket Socket socket(); //如果是HTTPS，返回TLS握手信息用于建立连接，否则返回null @Nullable Handshake handshake(); //返回应用层使用的协议，Protocol是一个枚举，如HTTP1.1、HTTP2 Protocol protocol();&#125;public final class RealConnection extends Http2Connection.Listener implements Connection &#123; public final RealConnectionPool connectionPool; //路由 private final Route route; //内部使用这个rawSocket在TCP层建立连接 private Socket rawSocket; //如果没有使用HTTPS，那么socket == rawSocket，否则这个socket == SSLSocket private Socket socket; //TLS握手 private Handshake handshake; //应用层协议 private Protocol protocol; //HTTP2连接 private Http2Connection http2Connection; //okio库的BufferedSource和BufferedSink，相当于javaIO的输入输出流 private BufferedSource source; private BufferedSink sink; public RealConnection(RealConnectionPool connectionPool, Route route) &#123; this.connectionPool = connectionPool; this.route = route; &#125; public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) &#123; //... &#125; //...&#125; RealConnection中有一个connect方法，外部可以调用该方法建立连接，connect方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//RealConnection.javapublic void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) &#123; if (protocol != null) throw new IllegalStateException(\"already connected\"); RouteException routeException = null; List&lt;ConnectionSpec&gt; connectionSpecs = route.address().connectionSpecs(); ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs); //路由选择 if (route.address().sslSocketFactory() == null) &#123; if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123; throw new RouteException(new UnknownServiceException( \"CLEARTEXT communication not enabled for client\")); &#125; String host = route.address().url().host(); if (!Platform.get().isCleartextTrafficPermitted(host)) &#123; throw new RouteException(new UnknownServiceException( \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\")); &#125; &#125; else &#123; if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) &#123; throw new RouteException(new UnknownServiceException( \"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS\")); &#125; &#125; //开始连接 while (true) &#123; try &#123; if (route.requiresTunnel()) &#123;//如果是通道模式，则建立通道连接 connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener); if (rawSocket == null) &#123; // We were unable to connect the tunnel but properly closed down our resources. break; &#125; &#125; else &#123;//1、否则进行Socket连接，大部分是这种情况 connectSocket(connectTimeout, readTimeout, call, eventListener); &#125; //建立HTTPS连接 establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener); break; &#125; //...省略异常处理 if (http2Connection != null) &#123; synchronized (connectionPool) &#123; allocationLimit = http2Connection.maxConcurrentStreams(); &#125; &#125; &#125; 我们关注注释1，一般会调用connectSocket方法建立Socket连接，connectSocket方法如下： 1234567891011121314151617181920212223242526//RealConnection.javaprivate void connectSocket(int connectTimeout, int readTimeout, Call call, EventListener eventListener) throws IOException &#123; Proxy proxy = route.proxy(); Address address = route.address(); //根据代理类型的不同创建Socket rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy); eventListener.connectStart(call, route.socketAddress(), proxy); rawSocket.setSoTimeout(readTimeout); try &#123; //1、建立Socket连接 Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout); &#125; //...省略异常处理 try &#123; //获得Socket的输入输出流 source = Okio.buffer(Okio.source(rawSocket)); sink = Okio.buffer(Okio.sink(rawSocket)); &#125; //...省略异常处理&#125; 我们关注注释1，Platform是okhttp中根据不同Android版本平台的差异实现的一个兼容类，这里就不细究，Platform的connectSocket方法最终会调用rawSocket的connect()方法建立其Socket连接，建立Socket连接后，就可以通过Socket连接获得输入输出流source和sink，okhttp就可以从source读取或往sink写入数据，source和sink是BufferedSource和BufferedSink类型，它们是来自于okio库，它是一个封装了java.io和java.nio的库，okhttp底层依赖这个库读写数据，Okio好在哪里？详情可以看这篇文章Okio好在哪。 2、RealConnectionPool - 连接池连接池，用来管理连接对象RealConnection，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class RealConnectionPool &#123; //线程池 private static final Executor executor = new ThreadPoolExecutor( 0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;(), Util.threadFactory(\"OkHttp ConnectionPool\", true)); boolean cleanupRunning; //清理连接任务，在executor中执行 private final Runnable cleanupRunnable = () -&gt; &#123; while (true) &#123; //调用cleanup方法执行清理逻辑 long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) &#123; long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (RealConnectionPool.this) &#123; try &#123; //调用wait方法进入等待 RealConnectionPool.this.wait(waitMillis, (int) waitNanos); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125; &#125; &#125;; //双端队列，保存连接 private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); void put(RealConnection connection) &#123; if (!cleanupRunning) &#123; cleanupRunning = true; //使用线程池执行清理任务 executor.execute(cleanupRunnable); &#125; //将新建连接插入队列 connections.add(connection); &#125; long cleanup(long now) &#123; //... &#125; //...&#125; RealConnectionPool 在内部维护了一个线程池，用来执行清理连接任务cleanupRunnable，还维护了一个双端队列connections，用来缓存已经创建的连接。要知道创建一次连接要经历TCP握手，如果是HTTPS还要经历TLS握手，握手的过程都是耗时的，所以为了提高效率，就需要connections来对连接进行缓存，从而可以复用；还有如果连接使用完毕，长时间不释放，也会造成资源的浪费，所以就需要cleanupRunnable定时清理无用的连接，okhttp支持5个并发连接，默认每个连接keepAlive为5分钟，keepAlive就是连接空闲后，保持存活的时间。 当我们第一次调用RealConnectionPool 的put方法缓存新建连接时，如果cleanupRunnable还没执行，它首先会使用线程池执行cleanupRunnable，然后把新建连接放入双端队列，cleanupRunnable中会调用cleanup方法进行连接的清理，该方法返回现在到下次清理的时间间隔，然后调用wiat方法进入等待状态，等时间到了后，再次调用cleanup方法进行清理，就这样往复循环。我们来看一下cleanup方法的清理逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//RealConnectionPool.javalong cleanup(long now) &#123; int inUseConnectionCount = 0;//正在使用连接数 int idleConnectionCount = 0;//空闲连接数 RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; synchronized (this) &#123; //遍历所有连接，记录空闲连接和正在使用连接各自的数量 for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123; RealConnection connection = i.next(); //如果该连接还在使用，pruneAndGetAllocationCount种通过引用计数的方式判断一个连接是否空闲 if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123; //使用连接数加1 inUseConnectionCount++; continue; &#125; //该连接没有在使用 //空闲连接数加1 idleConnectionCount++; //记录keepalive时间最长的那个空闲连接 long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) &#123; longestIdleDurationNs = idleDurationNs; //这个连接很可能被移除，因为空闲时间太长 longestIdleConnection = connection; &#125; &#125; //跳出循环后 //默认keepalive时间keepAliveDurationNs最长为5分钟，空闲连接数idleConnectionCount最大为5个 if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) &#123;//如果longestIdleConnection的keepalive时间大于5分钟 或 空闲连接数超过5个 //把longestIdleConnection连接从队列清理掉 connections.remove(longestIdleConnection); &#125; else if (idleConnectionCount &gt; 0) &#123;//如果空闲连接数小于5个 并且 longestIdleConnection连接还没到期清理 //返回该连接的到期时间，下次再清理 return keepAliveDurationNs - longestIdleDurationNs; &#125; else if (inUseConnectionCount &gt; 0) &#123;//如果没有空闲连接 且 所有连接都还在使用 //返回keepAliveDurationNs，5分钟后再清理 return keepAliveDurationNs; &#125; else &#123; // 没有任何连接，把cleanupRunning复位 cleanupRunning = false; return -1; &#125; &#125; //把longestIdleConnection连接从队列清理掉后，关闭该连接的socket，返回0，立即再次进行清理 closeQuietly(longestIdleConnection.socket()); return 0;&#125; 从cleanup方法得知，okhttp清理连接的逻辑如下： 1、首先遍历所有连接，记录空闲连接数idleConnectionCount和正在使用连接数inUseConnectionCount，在记录空闲连接数时，还要找出空闲时间最长的空闲连接longestIdleConnection，这个连接是很有可能被清理的； 2、遍历完后，根据最大空闲时长和最大空闲连接数来决定是否清理longestIdleConnection， ​ 2.1、如果longestIdleConnection的空闲时间大于最大空闲时长 或 空闲连接数大于最大空闲连接数，那么该连接就会被从队列中移除，然后关闭该连接的socket，返回0，立即再次进行清理； ​ 2.2、如果空闲连接数小于5个 并且 longestIdleConnection的空闲时间小于最大空闲时长即还没到期清理，那么返回该连接的到期时间，下次再清理； ​ 2.3、如果没有空闲连接 且 所有连接都还在使用，那么返回默认的keepAlive时间，5分钟后再清理； ​ 2.4、没有任何连接，idleConnectionCount和inUseConnectionCount都为0，把cleanupRunning复位，等待下一次put连接时，再次使用线程池执行cleanupRunnable。 了解了RealConnectionPool和RealConnection后，我们再回到ExchangeFinder的find方法，这里是连接创建的地方。 3、连接创建（连接机制）ExchangeFinder的fing方法如下： 1234567891011121314151617181920212223242526272829303132//ExchangeFinder.javapublic ExchangeCodec find( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; //... try &#123; //调用findHealthyConnection方法，返回RealConnection RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); return resultConnection.newCodec(client, chain); &#125; //...省略异常处理 &#125; private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException &#123; //一个死循环 while (true) &#123; //调用findConnection方法，返回RealConnection RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled); //... //判断连接是否可用 if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123; candidate.noNewExchanges(); continue; &#125; return candidate; &#125; ExchangeFinder的find方法会调用findHealthyConnection方法，里面会不断调用findConnection方法，直到找到一个可用的连接返回。ExchangeFinder的findConnection方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//ExchangeFinder.javaprivate RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException &#123; boolean foundPooledConnection = false; RealConnection result = null;//返回结果，可用的连接 Route selectedRoute = null; RealConnection releasedConnection; Socket toClose; synchronized (connectionPool) &#123; if (transmitter.isCanceled()) throw new IOException(\"Canceled\"); hasStreamFailure = false; . //1、尝试使用已经创建过的连接，已经创建过的连接可能已经被限制创建新的流 releasedConnection = transmitter.connection; //1.1、如果已经创建过的连接已经被限制创建新的流，就释放该连接（releaseConnectionNoEvents中会把该连接置空），并返回该连接的Socket以关闭 toClose = transmitter.connection != null &amp;&amp; transmitter.connection.noNewExchanges ? transmitter.releaseConnectionNoEvents() : null; //1.2、已经创建过的连接还能使用，就直接使用它当作结果、 if (transmitter.connection != null) &#123; result = transmitter.connection; releasedConnection = null; &#125; //2、已经创建过的连接不能使用 if (result == null) &#123; //2.1、尝试从连接池中找可用的连接，如果找到，这个连接会赋值先保存在Transmitter中 if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) &#123; //2.2、从连接池中找到可用的连接 foundPooledConnection = true; result = transmitter.connection; &#125; else if (nextRouteToTry != null) &#123; selectedRoute = nextRouteToTry; nextRouteToTry = null; &#125; else if (retryCurrentRoute()) &#123; selectedRoute = transmitter.connection.route(); &#125; &#125; &#125; closeQuietly(toClose); //... if (result != null) &#123; //3、如果在上面已经找到了可用连接，直接返回结果 return result; &#125; //走到这里没有找到可用连接 //看看是否需要路由选择，多IP操作 boolean newRouteSelection = false; if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) &#123; newRouteSelection = true; routeSelection = routeSelector.next(); &#125; List&lt;Route&gt; routes = null; synchronized (connectionPool) &#123; if (transmitter.isCanceled()) throw new IOException(\"Canceled\"); //如果有下一个路由 if (newRouteSelection) &#123; routes = routeSelection.getAll(); //4、这里第二次尝试从连接池中找可用连接 if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, false)) &#123; //4.1、从连接池中找到可用的连接 foundPooledConnection = true; result = transmitter.connection; &#125; &#125; //在连接池中没有找到可用连接 if (!foundPooledConnection) &#123; if (selectedRoute == null) &#123; selectedRoute = routeSelection.next(); &#125; //5、所以这里新创建一个连接，后面会进行Socket连接 result = new RealConnection(connectionPool, selectedRoute); connectingConnection = result; &#125; &#125; // 4.2、如果在连接池中找到可用的连接，直接返回该连接 if (foundPooledConnection) &#123; eventListener.connectionAcquired(call, result); return result; &#125; //5.1、调用RealConnection的connect方法进行Socket连接，这个在RealConnection中讲过 result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener); connectionPool.routeDatabase.connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; connectingConnection = null; //如果我们刚刚创建了同一地址的多路复用连接，释放这个连接并获取那个连接 if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) &#123; result.noNewExchanges = true; socket = result.socket(); result = transmitter.connection; &#125; else &#123; //5.2、把刚刚新建的连接放入连接池 connectionPool.put(result); //5.3、把刚刚新建的连接保存到Transmitter的connection字段 transmitter.acquireConnectionNoEvents(result); &#125; &#125; closeQuietly(socket); eventListener.connectionAcquired(call, result); //5.4、返回结果 return result;&#125; 这个findConnection方法就是整个ConnectInterceptor的核心，我们忽略掉多IP操作和多路复用(HTTP2)，假设现在我们是第一次请求，连接池和Transmitter中没有该连接，所以跳过1、2、3，直接来到5，创建一个新的连接，然后把它放入连接池和Transmitter中；接着我们用同一个Call进行了第二次请求，这时连接池和Transmitter中有该连接，所以就会走1、2、3，如果Transmitter中的连接还可用就返回，否则从连接池获取一个可用连接返回，所以整个连接机制的大概过程如下： Transmitter中的连接和连接池中的连接有什么区别？我们知道每创建一个Call，就会创建一个对应的Transmitter，一个Call可以发起多次请求（同步、异步），不同的Call有不同的Transmitter，连接池是在创建OkhttpClient时创建的，所以连接池是所有Call共享的，即连接池中的连接所有Call都可以复用，而Transmitter中的那个连接只是对应它相应的Call，只能被本次Call的所有请求复用。 了解了okhttp的连接机制后，我们接着下一个拦截器CallServerInterceptor。 CallServerInterceptorCallServerInterceptor的intercept(Chain)方法如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//CallServerInterceptor.java@Overridepublic Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; //获取Exchange Exchange exchange = realChain.exchange(); //获取Request Request request = realChain.request(); //通过Exchange的writeRequestHeaders(request)方法写入请求的header exchange.writeRequestHeaders(request); boolean responseHeadersStarted = false; Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; //... if (responseBuilder == null) &#123; //通过okio写入请求的body if (request.body().isDuplex()) &#123; exchange.flushRequest(); BufferedSink bufferedRequestBody = Okio.buffer( exchange.createRequestBody(request, true)); request.body().writeTo(bufferedRequestBody); &#125; else &#123; BufferedSink bufferedRequestBody = Okio.buffer( exchange.createRequestBody(request, false)); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); &#125; &#125; else &#123; //... &#125; &#125; else &#123; exchange.noRequestBody(); &#125; //... //下面开始获取网络请求返回的响应 //通过Exchange的readResponseHeaders(boolean)方法读取响应的header if (responseBuilder == null) &#123; responseBuilder = exchange.readResponseHeaders(false); &#125; //获取响应后，通过Builder模式构造Response Response response = responseBuilder .request(request) .handshake(exchange.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); //... //构造Response的body if (forWebSocket &amp;&amp; code == 101) &#123; //构造一个空的body的Response response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; //通过Exchange的openResponseBody(Response)方法读取响应的body，然后通过响应的body继续构造Response response = response.newBuilder() .body(exchange.openResponseBody(response)) .build(); &#125; //... //返回响应Response return response; &#125; 在ConnectInterceptor中我们已经建立了连接，连接到了服务器，获取了输入输出流，所以CallServerInterceptor的intercept(Chain)方法逻辑就是把请求发送到服务器，然后获取服务器的响应，如下： 1、发送请求： ​ 1.1、通过Exchange的writeRequestHeaders(request)方法写入请求的header； ​ 1.2、如果请求的body不为空，通过okio写入请求的body。 2、获取响应： ​ 2.1、通过Exchange的readResponseHeaders(boolean)方法读取响应的header； ​ 2.2、通过Exchange的openResponseBody(Response)方法读取响应的body。 这个发送获取的过程通过Exchange进行，前面已经讲过它在ConnectInterceptor中创建，在process方法中传进来，所以这里可以通过Chain获取Exchange，Exchange它是负责从IO流中写入请求和读取响应，完成一次请求/响应的过程，它内部的读写都是通过一个ExchangeCodec类型的codec来进行，而ExchangeCodec内部又是通过Okio的BufferedSource和BufferedSink进行IO读写，这个过程在上一篇文章已经分析过了，这里不在累述。 结语结合上一篇文章，我们对okhttp已经有了一个深入的了解，首先，我们会在请求的时候初始化一个Call的实例，然后执行它的execute()方法或enqueue()方法，内部最后都会执行到getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、连接拦截器和用户自定义网络拦截器和访问服务器拦截器等拦截处理过程，来获取到一个响应并交给用户。okhttp的请求流程、缓存机制和连接机制是当中的重点，在阅读源码的过程中也学习到很多东西，下一次就来分析它的搭档Retrofit。","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"okhttp","slug":"okhttp","permalink":"http://yoursite.com/tags/okhttp/"}]},{"title":"okhttp3源码分析之请求流程","date":"2019-09-03T14:49:13.000Z","path":"2019/09/03/okhttp3源码分析之请求流程/","text":"前言在Android开发中，当下最火的网络请求框架莫过于okhttp和retrofit，它们都是square公司的产品，两个都是非常优秀开源库，值得我们去阅读它们的源码，学习它们的设计理念，但其实retrofit底层还是用okhttp来发起网络请求的，所以深入理解了okhttp也就深入理解了retrofit，它们的源码阅读顺序应该是先看okhttp，我在retrofit上发现它最近的一次提交才把okhttp版本更新到3.14，okhttp目前最新的版本是4.0.x，okhttp从4.0.x开始采用kotlin编写，在这之前还是用java，而我本次分析的okhttp源码版本是基本3.14.x，看哪个版本的不重要，重要的是阅读过后的收获，我打算分2篇文章去分析okhttp，分别是： 请求流程(同步、异步) 拦截器(Interceptor) 本文是第一篇 - okhttp的请求流程，okhttp项目地址：okhttp okhttp的简单使用我们通过一个简单的GET请求来回忆一下okhttp的使用步骤，并以这个实例为例讲解okhttp的请求流程，如下： 1234567891011121314151617181920212223242526272829303132333435//1、创建OkHttpClientOkHttpClient client = new OkHttpClient.Builder() .readTimeout(5, TimeUnit.SECONDS) .build();//2、创建请求RequestRequest request = new Request.Builder() .url(\"http://www.baidu.com\") .build();//3、创建一个Call，用于发起网络请求Call call = client.newCall(request);//4、发起GET请求//4.1、同步请求，调用Call的execute()方法try &#123; //接收到回复Response Response response = call.execute(); Log.d(TAG, response.body().string());&#125; catch (IOException e) &#123; e.printStackTrace();&#125;//4.2、异步请求, 调用Call的enqueue()方法call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; //接收到回复Response Log.d(TAG, response.body().string()); &#125;&#125;); 可以看到，使用okhttp发起网络请求要经过4步： 1、创建OkHttpClient 2、创建请求Request 3、通过OkHttpClient和Request创建一个Call，用于发起网络请求 4、调用Call的execute()或enqueue()方法发起同步或异步请求 当服务器处理完一个请求Request后，就会返回一个响应，在okhttp中用Response代表HTTP的响应，这就是一个典型的HTTP请求/响应流程。下面简单介绍1~3步骤： 1、创建OkHttpClientOkHttpClient是okhttp中的大管家，它将具体的工作分发到各个子系统中去完成，它使用Builder模式配置网络请求的各种参数如超时、拦截器、分发器等，Builder中可配置的参数如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//OkHttpClient.Builderpublic static final class Builder &#123; Dispatcher dispatcher;//分发器 @Nullable Proxy proxy;//代理 List&lt;Protocol&gt; protocols;//应用层协议 List&lt;ConnectionSpec&gt; connectionSpecs;//传输层协议 final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();//应用拦截器 final List&lt;Interceptor&gt; networkInterceptors = new ArrayList&lt;&gt;();//网络拦截器 EventListener.Factory eventListenerFactory;//http请求回调监听 ProxySelector proxySelector;//代理选择 CookieJar cookieJar;//cookie @Nullable Cache cache;//网络缓存 @Nullable InternalCache internalCache;//内部缓存 SocketFactory socketFactory;//socket 工厂 @Nullable SSLSocketFactory sslSocketFactory;//安全套接层socket 工厂，用于HTTPS @Nullable CertificateChainCleaner certificateChainCleaner;//验证确认响应证书，适用 HTTPS 请求连接的主机名 HostnameVerifier hostnameVerifier;//主机名字确认 CertificatePinner certificatePinner;//证书链 Authenticator proxyAuthenticator;//代理身份验证 Authenticator authenticator;//本地身份验证 ConnectionPool connectionPool;//连接池,复用连接 Dns dns;//域名 boolean followSslRedirects;//安全套接层重定向 boolean followRedirects;//本地重定向 boolean retryOnConnectionFailure;//错误重连 int callTimeout;//请求超时，它包括dns解析、connect、read、write和服务器处理的时间 int connectTimeout;//connect超时 int readTimeout;//read超时 int writeTimeout;//write超时 int pingInterval;//ping超时 //这里是配置默认的参数 public Builder() &#123; dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS;//Protocol.HTTP_2和Protocol.HTTP_1_1 connectionSpecs = DEFAULT_CONNECTION_SPECS; eventListenerFactory = EventListener.factory(EventListener.NONE); proxySelector = ProxySelector.getDefault(); if (proxySelector == null) &#123; proxySelector = new NullProxySelector(); &#125; cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; callTimeout = 0; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0; &#125; //这里通过另外一个OkHttpClient配置参数 Builder(OkHttpClient okHttpClient) &#123; this.dispatcher = okHttpClient.dispatcher; this.proxy = okHttpClient.proxy; this.protocols = okHttpClient.protocols; //... &#125; //... //配置完参数后，通过Builder的参数创建一个OkHttpClient public OkHttpClient build() &#123; return new OkHttpClient(this); &#125;&#125; 2、创建请求Request在okhttp中Request代表着一个HTTP请求，它封装了请求的具体消息，如url、header、body等，它和OkHttpClient一样都是使用Budiler模式来配置自己的参数，如下： 12345678910111213141516171819202122232425262728//Request.Budilerpublic static class Builder &#123; HttpUrl url; String method; Headers.Builder headers; RequestBody body; //这里配置默认的参数 public Builder() &#123; this.method = \"GET\";//默认是GET请求 this.headers = new Headers.Builder(); &#125; //这里通过另外一个Request配置参数 Builder(Request request) &#123; this.url = request.url; this.method = request.method; //... &#125; //... //配置完参数后，通过Builder的参数创建一个Request public Request build() &#123; if (url == null) throw new IllegalStateException(\"url == null\"); return new Request(this); &#125;&#125; 3、创建用于发起网络请求的CallCall是一个接口，它的具体实现类是RealCall，Call中定义了一些enqueue(Callback)、execute()等关键方法，如下： 123456789101112131415161718192021public interface Call extends Cloneable &#123; //返回当前请求 Request request(); //同步请求方法，此方法会阻塞当前线程直到请求结果放回 Response execute() throws IOException; //异步请求方法，此方法会将请求添加到队列中，然后等待请求返回 void enqueue(Callback responseCallback); //取消请求 void cancel(); //判断请求是否在执行 boolean isExecuted(); //判断请求是否取消 boolean isCanceled(); //返回请求的超时时间 Timeout timeout(); //克隆一个新的请求 Call clone(); interface Factory &#123; Call newCall(Request request); &#125;&#125; 我们看到Call接口中有一个Factory接口，Factory中有一个newCall(Request)方法，这说明Call是通过工厂模式创建，而OkHttpClient实现了Call.Factory接口，重写了newCall(Request)方法，返回了Call的具体实现类RealCall，如下： 123456789101112131415161718public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory &#123; //... @Override public Call newCall(Request request) &#123; //调用了RealCall的newRealCall() return RealCall.newRealCall(this, request, false /* for web socket */); &#125;&#125;final class RealCall implements Call &#123; //... static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; //返回RealCall对象 RealCall call = new RealCall(client, originalRequest, forWebSocket); call.transmitter = new Transmitter(client, call); return call; &#125;&#125; 所以调用client.newCall(request)其实返回的是RealCall对象，而RealCall封装了请求的调用逻辑。 到这里也就走到了注释4，也就是第4步，okhttp通过Call的实现类RealCall的execute()或enqueue()方法发起同步或异步请求，也就是本文的重点，下面分别详细介绍: 同步请求 - RealCall :: execute()1234567891011121314//RealCall.java@Overridepublic Response execute() throws IOException &#123; //... try &#123; //1、调用Dispatcher的executed(RealCall)方法 client.dispatcher().executed(this); //2、调用getResponseWithInterceptorChain()方法 return getResponseWithInterceptorChain(); &#125; finally &#123; //3、同步请求任务执行完毕，调用Dispatcher的finished(RealCall)方法 client.dispatcher().finished(this); &#125;&#125; client就是我们上面所讲的OkHttpClient的实例，它在创建RealCall时作为构造参数传了进去，而OkHttpClient的dispatcher()方法返回的是Dispatcher实例，它在OkHttpClient构造时被创建。 我们先讲一下Dispatcher，那Dispatcher是什么呢？Dispatcher是一个任务调度器，它负责进行请求任务的调度，它的内部维护着3个任务队列(readyAsyncCalls、runningAsyncCalls、runningSyncCalls)和1个线程池(executorService)，Dispatcher主要内容如下： 123456789101112131415161718192021222324252627282930313233343536373839public final class Dispatcher &#123; private int maxRequests = 64;//最大请求数64个 private int maxRequestsPerHost = 5;//每个主机最大请求数5个 private @Nullable Runnable idleCallback;//idle任务回调，类似于Android的idlehandler, 可以在Dispatcher没有任务调度（空闲时）时执行idleCallback中的任务 //线程池，执行runningAsyncCalls队列里面的请求任务 private @Nullable ExecutorService executorService; //等待执行的异步请求任务队列 private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); //正在执行的异步请求任务队列 private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); //正在执行的同步请求任务队列 private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); synchronized void executed(RealCall call) &#123; //... &#125; void enqueue(AsyncCall call) &#123; //... &#125; void finished(RealCall call) &#123; //... &#125; void finished(AsyncCall call) &#123; //... &#125; private boolean promoteAndExecute() &#123; //... &#125; //... &#125; Dispatcher提供了executed(RealCall)和enqueue(AsyncCall)方法来进行同步和异步请求任务的入队，还提供了finished(RealCall)和finished(AsyncCalll)方法来进行同步和异步请求任务的出队，可以看到okhttp把ReadCall当作同步请求任务的代表，把AsyncCall当作异步请求任务的代表，RealCall前面已经讲过了，而AsyncCal是RealCall的一个内部类，它本质上就是一个Runnable，Dispatcher的线程池执行任务主要执行的是runningAsyncCalls队列里面的异步请求任务，也就是AsyncCall异步任务，而Dispatcher的promoteAndExecute()方法就是用来进行异步任务的调度，它的逻辑主要是按顺序把readyAsyncCalls队列中准备执行的异步任务转移到runningAsyncCalls后，再由线程池执行，对于同步任务Dispatcher只是暂时保存在runningSyncCalls队列中，并不会由线程池执行。 我们继续回到RealCall的execute()方法，根据注释1、2、3分为3部分解释同步请求流程，如下： 1、Dispatcher :: executed(RealCall)看RealCall的execute()方法的注释1，它首先调用了Dispatcher的executed(RealCall)方法，Dispatcher的executed(RealCall)方法实现如下： 1234//Dispatcher.javasynchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; 可以看到没有做什么处理，只是简单的把同步请求任务放入runningSyncCalls队列。 2、RealCall :: getResponseWithInterceptorChain()看RealCall的execute()方法的注释2，调用getResponseWithInterceptorChain()方法，这里才是同步请求处理的地方，我们点进去，如下： 123456789101112131415161718192021222324252627282930313233//RealCall.java Response getResponseWithInterceptorChain() throws IOException &#123; //拦截器的添加 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); //添加用户自定义拦截器 interceptors.addAll(client.interceptors()); //添加默认拦截器 interceptors.add(new RetryAndFollowUpInterceptor(client)); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; //添加的最后一个拦截器是CallServerInterceptor interceptors.add(new CallServerInterceptor(forWebSocket)); //创建一个RealInterceptorChain，传入了interceptors和Request Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); try &#123; //调用RealInterceptorChain的proceed(Request)方法处理请求 Response response = chain.proceed(originalRequest); //... return response; &#125; catch (IOException e) &#123; //... &#125; finally &#123; //... &#125; &#125; getResponseWithInterceptorChain()方法最终返回一个Response，也就是网络请求的响应，该方法中首先把用户自定义的拦截器和okhttp默认的拦截器封装到一个List中，然后创建RealInterceptorChain并执行proceed(Request)方法处理请求，RealInterceptorChain的proceed(Request)方法如下： 1234567891011121314151617181920//RealInterceptorChain.java@Override public Response proceed(Request request) throws IOException &#123; return proceed(request, transmitter, exchange); &#125;public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange) throws IOException &#123; //... //再新建一个RealInterceptorChain，这里注意index加1， RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout); //获取interceptors列表中的下一个拦截器 Interceptor interceptor = interceptors.get(index); //调用下一个拦截器的intercept(Chain)方法，传入刚才新建的RealInterceptorChain，返回Response Response response = interceptor.intercept(next); //... return response;&#125; proceed()方法中再次新建了一个RealInterceptorChain，传入了index + 1，而获取拦截器时是通过index获取，这样每次都能获取到下一个拦截器，然后调用下一个拦截器的intercept(Chain)方法，intercept(Chain)方法中就是拦截器的主要功能实现，里面会继续调用传入的RealInterceptorChain的proceed()方法，这样又会重复上述逻辑，我们把拦截器看作一条链中的节点，这样每个拦截器就通过一个个RealInterceptorChain连接起来，形成一条链，这就是典型的责任链模式，从节点的首部开始把请求传递下去，每一个拦截器都有机会处理这个请求，这又像是一个递归的过程，直到最后一个拦截器器处理完请求后，才开始逐层返回Resquese，拦截器才是Okhttp核心功能所在，关于拦截器介绍下篇文章再讲，这里只需要知道每一个拦截器都代表了一个功能。 经过对拦截器的简单介绍后，我们知道最后一个添加的拦截器才是把请求发送出去并且返回响应的地方，我们看getResponseWithInterceptorChain()方法，最后一个拦截器的添加是CallServerInterceptor，所以我们直接看CallServerInterceptor的intercept(Chain)方法实现，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//CallServerInterceptor.java@Overridepublic Response intercept(Chain chain) throws IOException &#123; //强转成RealInterceptorChain RealInterceptorChain realChain = (RealInterceptorChain) chain; //获取Exchange Exchange exchange = realChain.exchange(); //获取Request Request request = realChain.request(); //1、通过Exchange的writeRequestHeaders(request)方法发送Request的header exchange.writeRequestHeaders(request); boolean responseHeadersStarted = false; Response.Builder responseBuilder = null; //因为前面已经讲了，默认是GET请求，而GET请求是没有body的，所以不会进入if分支 if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; //省略的是发送Request的body过程 //... &#125; else &#123; exchange.noRequestBody(); &#125; //GET请求body为空，进入这个分支，完成请求 if (request.body() == null || !request.body().isDuplex()) &#123; exchange.finishRequest(); &#125; //省略的是一些监听回调 //... //下面开始获取网络请求返回的响应 //2、通过Exchange的readResponseHeaders(boolean)方法获取响应的header if (responseBuilder == null) &#123; responseBuilder = exchange.readResponseHeaders(false); &#125; //获取响应后，通过Builder模式构造Response Response response = responseBuilder .request(request) .handshake(exchange.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); //省略的是response对状态码code的处理 //... //构造Response的body if (forWebSocket &amp;&amp; code == 101) &#123; //构造一个空的body的Response response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; //通过Exchange的openResponseBody(Response)方法获取响应的body，然后通过响应的body继续构造Response response = response.newBuilder() .body(exchange.openResponseBody(response)) .build(); &#125; //... //返回响应Response return response; &#125; intercept(Chain）方法中主要做的就是发送请求，获取响应的事情，注释中已经写的很清楚了，发送请求要把header和body分开发送，而获取响应时也要分别获取header和body，而发送请求和获取响应两个过程都是通过一个Exchange对象进行的，Exchange是在构造RealInterceptorChain时就作为构造参数传进RealInterceptorChain中，一直都为null，直到在ConnectInterceptor的intercept()中才通过Transmitter的newExchange()被赋值，而ConnectInterceptor的下一个拦截器就是CallServerInterceptor，所以CallServerInterceptor可以通过Chain获取到Exchange实例，这里不用细究这个赋值过程，Exchange它主要是用来负责完成一次网络请求和响应的过程。 这里我以intercept(Chain）方法中注释1和注释2请求header的发送(wirte)和获取(read)为例了解Exchange的工作过程，首先看Exchange的writeRequestHeaders(Request)方法，如下： 12345678910//Exchange.javapublic void writeRequestHeaders(Request request) throws IOException &#123; try &#123; //主要是调用了codec的writeRequestHeaders(request) codec.writeRequestHeaders(request); //... &#125; catch (IOException e) &#123; //... &#125;&#125; 我们再看Exchange的readResponseHeaders(boolean)方法，如下： 1234567891011//Exchange.javapublic @Nullable Response.Builder readResponseHeaders(boolean expectContinue) throws IOException &#123; try &#123; //主要是调用了codec的readResponseHeaders(boolean) Response.Builder result = codec.readResponseHeaders(expectContinue); //... return result; &#125; catch (IOException e) &#123; //... &#125; &#125; 从Exchange的两个方法可以看出，它把 wirt和read header的任务都交给了codec，codec是什么呢？codec是ExchangeCodec类型，它是一个接口，它主要用来编码http请求并解码http返回结果，所以Exchange中真正干活的是ExchangeCodec，它的有两个实现类，分别是Http2ExchangeCodec和Http1ExchangeCodec，分别对应Http2.x和Http1.x，这里我们以Http1ExchangeCodec为例，查看它的writeRequestHeaders(request)和readResponseHeaders(boolean)方法，首先看Http1ExchangeCodec的writeRequestHeaders(request)方法，如下： 12345678910111213141516171819202122//Http1ExchangeCodec.java@Override public void writeRequestHeaders(Request request) throws IOException &#123; String requestLine = RequestLine.get( request, realConnection.route().proxy().type()); //调用了writeRequest() writeRequest(request.headers(), requestLine); &#125; public void writeRequest(Headers headers, String requestLine) throws IOException &#123; if (state != STATE_IDLE) throw new IllegalStateException(\"state: \" + state); //可以看到通过sink把请求头写入IO流，发送到服务器，sink是BufferedSink类型 sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\"); for (int i = 0, size = headers.size(); i &lt; size; i++) &#123; sink.writeUtf8(headers.name(i)) .writeUtf8(\": \") .writeUtf8(headers.value(i)) .writeUtf8(\"\\r\\n\"); &#125; sink.writeUtf8(\"\\r\\n\"); state = STATE_OPEN_REQUEST_BODY; &#125; 我们再看Http1ExchangeCodec的readResponseHeaders(boolean)方法，如下： 123456789101112131415161718192021222324252627282930313233//Http1ExchangeCodec.java@Overridepublic Response.Builder readResponseHeaders(boolean expectContinue) throws IOException &#123; //... try &#123; StatusLine statusLine = StatusLine.parse(readHeaderLine()); Response.Builder responseBuilder = new Response.Builder() .protocol(statusLine.protocol) .code(statusLine.code) .message(statusLine.message) .headers(readHeaders());//调用了readHeaders() //... return responseBuilder; &#125; catch (EOFException e) &#123; //... &#125;&#125; private Headers readHeaders() throws IOException &#123; Headers.Builder headers = new Headers.Builder(); //调用了readHeaderLine()，一行一行的读取header for (String line; (line = readHeaderLine()).length() != 0; ) &#123; Internal.instance.addLenient(headers, line); &#125; return headers.build(); &#125; private String readHeaderLine() throws IOException &#123; //服务器响应返回，通过source从IO读取响应头，source是BufferedSource类型 String line = source.readUtf8LineStrict(headerLimit); headerLimit -= line.length(); return line; &#125; 从Http1ExchangeCodec的两个方法可以看出，底层是通过BufferedSink把信息写入IO流，通过BufferedSource从IO流读取信息，BufferedSink和BufferedSource都是来自okio这个开源库的，okhttp底层是通过okio来向网络中写入和读取IO的，想要了解更多可自行查看okio源码(okio也是square公司的产品)。 到此RealCall的 getResponseWithInterceptorChain()分析完，getResponseWithInterceptorChain()返回Response后，RealCall的execute() 方法就return了，我们就可以通过返回的Response获取我们想要的信息，但RealCall的execute() 方法就return后，还要继续执行finally 分支中的逻辑。 3、Dispatcher :: finished(RealCall)我们继续看RealCall的execute()方法的注释3，调用Dispatcher的finished(AsyncCall)方法，如下： 12345678910111213141516171819202122//Dispatcher.javavoid finished(RealCall call) &#123; //传进了runningSyncCalls队列 finished(runningSyncCalls, call);&#125;private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; //尝试移除队列中的同步请求任务 if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\"); idleCallback = this.idleCallback; &#125; //紧接着调用promoteAndExecute()方法进行异步任务的调度，如果没有异步任务要进行，promoteAndExecute()返回false boolean isRunning = promoteAndExecute(); //isRunning等于false且设置了idleCallback，会执行一遍idle任务 if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; finished()方法中首先尝试从runningSyncCalls队列把刚才通过 executed()入队的同步任务RealCall移除，如果移除失败，就抛出异常，如果移除成功，就紧接着调用promoteAndExecute()方法进行异步任务的调度并尝试执行一遍idle任务，promoteAndExecute()方法在异步请求中再详细介绍。 小结至此okhttp的同步请求过程分析完毕，这里总结一下：当我们调用call.execute()时，就会发起一个同步请求，而call的实现类是RealCall，所以实际执行的是realCall.execute()，realCall.execute()中执行Dispatcher的executed(RealCall)把这个同步请求任务保存进runningSyncCalls队列中，然后RealCall执行getResponseWithInterceptorChain()处理同步请求，请求经过层层拦截器后到达最后一个拦截器CallServerInterceptor，在这个拦截器中通过Exchange把请求发送到服务器，然后同样的通过Exchange获得服务器的响应，根据响应构造Response，然后返回，最后RealCall执行Dispatcher的finished(RealCall)把之前暂时保存的同步请求任务从runningSyncCalls队列中移除。 下面是同步请求过程的调用链： 异步请求 - RealCall.enqueue(Callback)1234567//RealCall.java@Overridepublic void enqueue(Callback responseCallback) &#123; //... //1、调用Dispatcher的enqueue(AsyncCall)方法 client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 异步请求执行的是RealCall的enqueue(Callback)方法，它比同步请求只是多了一个Callback，在Callback的 onResponse(Call, Response)回调中我们可以拿到网络响应返回的Response，RealCall的enqueue(Callback)方法中首先把Callback用AsyncCall包装起来，然后调用调用Dispatcher的enqueue(AsyncCall)方法。 1、Dispatcher :: enqueue(AsyncCall)我们看Dispatcher的enqueue(AsyncCall)方法，如下： 12345678//Dispatcher.javavoid enqueue(AsyncCall call) &#123; synchronized (this) &#123; readyAsyncCalls.add(call); //... &#125; promoteAndExecute();&#125; 该方法首先把异步请求任务AsyncCall放入readyAsyncCalls队列，然后调用promoteAndExecute()进行异步任务的调度，我们看一下Dispatcher 是如何进行异步任务的调度的。 2、Dispatcher :: promoteAndExecute()promoteAndExecute()方法如下： 123456789101112131415161718192021222324252627282930313233343536373839//Dispatcher.javaprivate boolean promoteAndExecute() &#123; //准备一个正在执行任务列表executableCalls List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; //1、这个for循环主要把readyAsyncCalls中等待执行的异步任务转移到runningAsyncCalls队列和executableCalls列表中去 for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; //取出readyAsyncCalls中等待执行的异步任务 AsyncCall asyncCall = i.next(); //判断条件：1、正在运行的异步请求任务不能大于maxRequests；2、等待执行的异步任务的主机请求数不能大于maxRequestsPerHost if (runningAsyncCalls.size() &gt;= maxRequests) break; if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; //满足条件，进入下面逻辑 //把这个等待执行的异步任务从readyAsyncCalls中移除 i.remove(); asyncCall.callsPerHost().incrementAndGet(); //把这个等待执行的异步任务添加进executableCalls列表 executableCalls.add(asyncCall); //把这个等待执行的异步任务添加进runningAsyncCalls队列 runningAsyncCalls.add(asyncCall); &#125; //runningCallsCount()里面的逻辑： return runningAsyncCalls.size() + runningSyncCalls.size(); isRunning = runningCallsCount() &gt; 0; &#125; //2、这个for循环主要是执行executableCalls列表中的异步任务 for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); //传进executorService，调用AsyncCall的executeOn()方法，由线程池执行这个异步任务 asyncCall.executeOn(executorService()); &#125; return isRunning;&#125; promoteAndExecute()方法中主要是2个for循环，注释1的第一个for循环是把符合条件的异步请求任务从readyAsyncCalls转移（提升）到runningAsyncCalls队列和添加到executableCalls列表中去，紧接着注释2的第二个for循环就是遍历executableCalls列表，从executableCalls列表中获取AsyncCall对象，并且调用它的executeOn()方法，executeOn()方法传进了一个Dispatcher的executorService，所以我们看AsyncCall的executeOn()方法，里面是真正执行异步请求任务的地方。 2.1、AsyncCall :: executeOn(ExecutorService)AsyncCall的executeOn()方法如下： 123456789101112131415//AsyncCall.javavoid executeOn(ExecutorService executorService) &#123; boolean success = false; try &#123; //传进this，执行AsyncCall异步任务，AsyncCall本质是Runnable executorService.execute(this); success = true; &#125; catch (RejectedExecutionException e) &#123; //... &#125; finally &#123; if (!success) &#123; //异步任务执行失败，调用Dispatcher的finished(AsyncCall)方法 client.dispatcher().finished(this); &#125; &#125; 可以看到，里面的主要逻辑就是调用 executorService.execute(this)执行当前的AsyncCall异步任务，前面已经说过AsyncCall实现了NamedRunnable，本质是Runnable，如下： 1234567891011121314151617181920final class AsyncCall extends NamedRunnable &#123; //...&#125;public abstract class NamedRunnable implements Runnable &#123; //... @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; //run方法中执行execute()方法 execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125; 线程池执行到此异步任务时，它的run方法就会被执行，而run方法主要调用execute()方法，而execute()方法是一个抽象方法，AsyncCall实现了NamedRunnable，所以AsyncCall重写了execute()实现了执行逻辑，所以我们直接看AsyncCal的execute()方法。 2.2、AsyncCal :: execute()AsyncCal的execute()方法如下： 1234567891011121314151617//AsyncCall.java@Override protected void execute() &#123; //... try &#123; //调用RealCall的getResponseWithInterceptorChain()方法处理请求 Response response = getResponseWithInterceptorChain(); signalledCallback = true; //请求处理完毕，返回响应，回调Callback的onResponse()方法 responseCallback.onResponse(RealCall.this, response); &#125; catch (IOException e) &#123; //... &#125; finally &#123; //异步请求任务执行完毕，调用Dispatcher的finished(AsyncCall)方法 client.dispatcher().finished(this); &#125;&#125; AsyncCal的execute()方法的逻辑和前面介绍的同步请求过程殊途同归，首先调用RealCall的getResponseWithInterceptorChain()方法处理请求，请求处理完毕后，返回响应Response，这时回调我们调用Call.enqueue(Callback)时传进来的Callback的onResponse()方法，最后在finally语句中调用Dispatcher的finished(AsyncCall)方法来把异步请求任务从runningAsyncCalls队列中移除出去，这个移除逻辑和上面同步请求任务的移除逻辑一样，只是这次是从runningAsyncCalls移除而不是runningSyncCalls，如下： 12345//Dispatcher.javavoid finished(AsyncCal call) &#123; //传进runningAsyncCalls，而不是runningSyncCalls finished(runningSyncCalls, call);&#125; 小结至此okhttp的异步请求过程分析完毕，这里再次总结一下，当我们调用call.enqueue(Callback)时，就会发起一个异步请求，实际执行的是realCall.enqueue(Callback)，它比同步请求只是多了一个Callback参数，然后realCall.execute()中先把传进来的Callback包装成一个AsyncCall，然后执行Dispatcher的enqueue(AsyncCall)把这个异步请求任务保存进readyAsyncCalls队列中，保存后开始执行 promoteAndExecute()进行异步任务的调度，它会先把符合条件的异步请求任务从readyAsyncCalls转移到runningAsyncCalls队列和添加到executableCalls列表中去，然后遍历executableCalls列表，逐个执行AsyncCall 的executeOn(ExecutorService)，然后在这个方法中AsyncCall会把自己放进Dispatcher 的线程池，等待线程池的调度，当线程池执行到这个AsyncCall时，它的run方法就会被执行，从而执行重写的execute()方法，execute()方法中的流程和同步请求流程大致相同。 下面是异步请求过程的调用链： 结语okhttp通过Builder模式创建OkHttpClient、Request和Response，通过client.newCall(Resquest)创建一个Call，用于发起异步或同步请求，请求会经过Dispatcher、一系列拦截器，最后通过okio与服务器建立连接、发送数据并解析返回结果，这个过程如图： 以上就是对okhttp的请求流程的分析，如有错误，欢迎指出。 参考文章： OkHttp 3.x 源码解析之Dispather分发器","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"okhttp","slug":"okhttp","permalink":"http://yoursite.com/tags/okhttp/"}]},{"title":"View的事件分发机制","date":"2019-07-29T15:14:42.000Z","path":"2019/07/29/View的事件分发机制/","text":"前言前几天写过一篇文章View的工作原理，讲述的View工作的三大流程，其实与View的工作流程同样重要还有View的事件分发机制，平时我们经常通过setOnClickListener()方法来设置一个View的点击监听，那你有没有想过这个点击事件底层是怎么样传递到这个View的呢？当你自定义控件时，如果要处理滑动事件，那么到底返回true还是false？还有当你遇到了滑动嵌套的情景，你要怎么解决滑动嵌套引起的冲突？所以，本文通过 源码 + 流程图 来深入了解一个事件分发机制，当你掌握了它之后，当你遇到与滑动相关的问题时就更加的游刃有余。 本文源码基于Android8.0 准备知识1、什么是触摸事件触摸事件事件就是当你的手触摸到手机屏幕时所产生的最小单元事件，所谓最小单元，就是不可再拆分的，它一般有4种类型：按下（down)、移动（move）、抬起（up）、取消(cancel)。然后由若干个不可再拆分的最小单元事件就组成了点击事件、长按事件、滑动事件等。 2、什么是MotionEventMotionEvent就是Android对上面触摸事件相关信息的封装，View的事件分发中的事件就是这个MotionEvent，当这个MotionEvent产生后，那么系统就会将这个MotionEvent传递给View的层级，MotionEvent在View的层级传递的过程就是事件分发。MotionEvent封装了事件类型和坐标两类信息。 事件类型可以通过 motionEvent.getAction() 方法获得，它返回一个常量，对应着一个事件类型，事件类型主要有以下4种： 12345678910111213//MotionEvent.javapublic final class MotionEvent extends InputEvent implements Parcelable &#123; //按下（down) public static final int ACTION_DOWN = 0; //抬起（up） public static final int ACTION_UP = 1; //移动（move） public static final int ACTION_MOVE = 2; //取消(cancel) public static final int ACTION_CANCEL = 3; //还有很多就不一 一列举 //...&#125; 坐标信息也是通过MotionEvent获取，motionEvent.getRawX()、motionEvent.getRawY() 可以获得以屏幕作为参考系的坐标值，motionEvent.getX()、motionEvent.getY() 可以获得以被触摸的 View 作为参考系的坐标值。参考下面的视图坐标： 蓝色点想象成手指触摸屏幕的位置。 3、一个事件序列从手指按下屏幕到抬起，在这个过程中所产生的一系列事件，就是一个事件序列，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。所以可能会有下面两种事件序列： ACTION_DOWN -&gt; ACTION_UP：手指按下屏幕后又抬起 ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_MOVE -&gt; ACTION_UP：手指按下屏幕，滑动一会，然后抬起 在分析事件分发的过程时，会有事件序列这个概念。 4、事件分发的起点，事件从何而来我想大家都知道View的事件分发机制的起点是View的dispatchTouchEvent()方法，但是如果从View的dispatchTouchEvent()继续追溯上去，事件是从哪里来的呢？ Android的输入设备有很多种，如屏幕、键盘、鼠标、轨迹球等，而屏幕是我们接触最多的设备，当用户手指触摸屏幕时就会产生触摸事件，这时Android的输入系统就会为这个触摸事件在/dev/input/路径下写入以event[NUMBER]为名的输入设备节点，这时输入系统中的EventHub就会监听到这个输入事件，然后InputReader就会把这个原始输入事件读取并经过加工后交给输入系统中的InputDispatcher，InputDispatcher会在Window列表中会找到合适的Window，然后把这个输入事件分发给合适的Window，然后Window就会把这个事件分发给顶级View，然后顶级View就把这个输入事件在View树中层层分发下去，直到找到合适的View来处理这个事件，这来到了我们熟悉的View的事件分发机制。 上面的一些名词如EventHub、InputReader、InputReader都是属于Android的输入系统，这部分是一个很复杂的知识，我只是概括了一下。所以我们只要知道，输入系统监听到输入事件后，就会先交给Window，然后Window再交给顶级View，然后顶级View在把它分发下去。(关于Window和View的关系可以看这篇文章Window, WindowManager和WindowManagerService之间的关系) 这个顶级View可能是View，也有可能是ViewGroup，具体情况看你添加Window到WMS时你的addView(View view, ViewGroup.LayoutParams params)方法中的View是View实例还是ViewGroup实例，所以本文接下来就分别分析View的事件分发和ViewGroup的事件分发。 View的事件分发1、View::dispatchTouchEvent()View的事件分发比ViewGroup的简单，因为它只是一个单独的元素，所以它只需要处理自己的事件，View的事件分发从View的dispatchTouchEvent()方法开始，所以我们看它的dispatchTouchEvent方法，如下： 1234567891011121314151617181920212223242526272829303132//View.javapublic boolean dispatchTouchEvent(MotionEvent event) &#123; //... //result默认为false boolean result = false; //... ListenerInfo li = mListenerInfo; if ( li != null//如果ListenerInfo不为空 &amp;&amp; li.mOnTouchListener != null//如果触摸事件的监听不为空 &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED//如果该控件是ENABLED状态 &amp;&amp; li.mOnTouchListener.onTouch(this, event)//如果onTouch方法返回了true )&#123; result = true; &#125; if ( !result//如果上面四个条件都不满足，result默认为false &amp;&amp; onTouchEvent(event)//如果onTouchEvent()方法返回了true ) &#123; result = true; &#125; //... return result;&#125;//View.javastatic class ListenerInfo &#123; public OnClickListener mOnClickListener;//点击事件的监听 protected OnLongClickListener mOnLongClickListener;//长按事件的监听 private OnTouchListener mOnTouchListener;//触摸事件的监听 //...&#125; 从View的dispatchTouchEvent()方法的伪代码可以看出，dispatchTouchEvent()方法首先会根据4个条件来决定是否调用View的onTouchEvent方法，如下： 1、如果ListenerInfo不为空：ListenerInfo里面有View的各种监听，那么mListenerInfo是什么时候被赋值的呢？答案是给View设置监听的时候，在我们给View设置任何监听的时候，如果这个mListenerInfo还没初始化就会先初始化，比如设置触摸事件的监听，我们看setOnTouchListener()方法，如下： 1234567891011121314//View.javapublic void setOnTouchListener(OnTouchListener l) &#123; //先调用getListenerInfo方法初始化mListenerInfo，然后把触摸事件的监听赋值给mOnTouchListener getListenerInfo().mOnTouchListener = l;&#125;//View.javaListenerInfo getListenerInfo() &#123; if (mListenerInfo != null) &#123; return mListenerInfo; &#125; mListenerInfo = new ListenerInfo(); return mListenerInfo; &#125; 2、如果触摸事件的监听不为空：即ListenerInfo的mOnTouchListener不为空，从1可以看出，当你给View设置OnTouchListener时，就已经满足了1、2条件了。 3、如果该控件是ENABLED状态：即该Vew处于enable状态，如果你没有手动调用过View的setEnable(false)设置控件为不可用的话，这个条件就为true，控件默认为enable状态。 4、如果onTouch方法返回了true：当你给View设置OnTouchListener，并且在onTouch方法中返回了true，表示消费了这次事件，那么这个条件就为true。所以到这里，如果4个条件都满足的话，result就会等于true，就会导致下面无法调用View的onTouchEvent()方法。 但是如果你没有给你给View设置OnTouchListener或者你给View设置了OnTouchListener，但是onTouch方法返回了false，只要满足这两个条件之一，就会让result保持默认值false，从而满足下面的条件调用View的onTouchEvent()方法。这里得出一个结论：OnTouchListener的onTouch方法的优先级高于onTouchEvent()方法。 假设现在不满足上面4个条件，从而调用View的onTouchEvent()方法，我们来看View的onTouchEvent()方法。 2、View::onTouchEvent()onTouchEvent()方法里面会处理View点击事件、长按事件，即回调你设置的OnClickListener的onClick()方法和OnLongClickListener的OnLongClick()方法，在你设置OnClickListener或OnLongClickListener回调时会同时把你的View设置为可点击状态即clickable状态，有些控件默认可点击如Button，而有些控件需要设置点击回调或setClickable(true)才可以点击如TextView。 接下来我们看View的onTouchEvent()方法的主要源码，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//View.javapublic boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); //该View是否可点击，可以看到这里点击包含3种点击：CLICKABLE、LONG_CLICKABLE和CONTEXT_CLICKABLE(回调OnContextClickListener) //这里我们关注CLICKABLE和LONG_CLICKABLE就行，即点击和长按 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //1、如果View处于disabled状态，即不可用状态 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; //这里说明了即使View处于不可用状态，但是如果它可以点击，它还是会消费点击事件 return clickable; &#125; //2、如果View设置有代理机制，那么就会执行TouchDelegate的onTouchEvent()方法 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; //3、下面是onTouchEvent()对点击事件和长按事件的处理 //如果控件可以点击 if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: //... break; case MotionEvent.ACTION_DOWN: //... break; case MotionEvent.ACTION_CANCEL: //... break; case MotionEvent.ACTION_MOVE: //... break; &#125; //从这里看出，如果我们的View是可以点击的，最终一定返回true，表示消费了此事件 return true; &#125; //4、最终虽然控件可用，但是不可点击，返回false，不消费此事件 return false;&#125; 这个onTouchEvent()方法有点长，这里我截取了整体框架，这里我们先明确一点的是onTochEvent()中返回true就表示这个事件由这个View消费，返回false就表示这个View不消费这个事件然后它的父容器会继续找合适的View消费。首先我们看注释1，它说明了即使View处于不可用状态，但是如果它可以点击即clickable = true，它会返回true，表明不可用状态下的View它还是会消费事件，即使这个View会没有响应，反之返回false；接着注释2，如果设置了mTouchDelegate，则会将事件交给代理者处理，直接return true，如果大家希望自己的View增加它的touch范围，可以尝试使用TouchDelegate；接着注释3，如果控件可以点击，就判断事件类型：ACTION_UP、ACTION_DOWN、ACTION_CANCEL、ACTION_MOVE，然后根据不同的事件类型做出不同的行为，然后都返回了true，表示消费了此事件；最后注释4如果控件不可点击，就返回false，不消费此事件。 接下来我们重点看注释3，看onTouchEvent()是如何在ACTION_UP、ACTION_DOWN、ACTION_CANCEL、ACTION_MOVE中触发onClick()和onLingClick()回调的。 2.1、case ACTION_DOWN:1234567891011121314 switch (action) &#123; case MotionEvent.ACTION_DOWN: //... //1、设置mHasPerformedLongPress为false mHasPerformedLongPress = false; //... //2、给mPrivateFlags设置一个PREPRESSED标识 mPrivateFlags |= PFLAG_PREPRESSED; //3、通过postDelayed发送一个延时100毫秒后执行的任务mPendingCheckForTap postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); //... break; &#125;return true; 我们想象一下，我们的手指按下这个View，这时进入ACTION_DOWN分支，在这个分支里，在注释1中它首先设置mHasPerformedLongPress为false，表示长按事件还没有触发，然后在注释2给mPrivateFlags设置一个PREPRESSED的标识，表示开始检查长按事件，然后在注释3通过postDelayed发送了一个延时消息，ViewConfiguration.getTapTimeout()返回100毫秒，即100毫秒后会执行任务mPendingCheckForTap，它一个CheckForTap类型任务，它是用来检测长按事件的。我们看这个任务是什么，如下： 1234567891011121314151617181920212223242526272829303132333435//View.java //用来检测长按事件private final class CheckForTap implements Runnable &#123; public float x; public float y; @Override public void run() &#123; //1、mPrivateFlags清除PFLAG_PREPRESSED标识 mPrivateFlags &amp;= ~PFLAG_PREPRESSED; //2、见下面调用链，这里传入true，即给mPrivateFlags设置一个PFLAG_PRESSED标识 setPressed(true, x, y); //3、调用checkForLongClick()方法，传入100毫秒 checkForLongClick(ViewConfiguration.getTapTimeout(), x, y); &#125; &#125;private void setPressed(boolean pressed, float x, float y) &#123; //... //主要调用了带一个参数的setPressed(pressed)方法 setPressed(pressed); &#125;//设置控件是否处于按下状态public void setPressed(boolean pressed) &#123; //... if (pressed) &#123;//如果pressed为true //给mPrivateFlags设置一个PFLAG_PRESSED标识 mPrivateFlags |= PFLAG_PRESSED; &#125; else &#123;//如果pressed为false //清除mPrivateFlags之前设置的PFLAG_PRESSED标识 mPrivateFlags &amp;= ~PFLAG_PRESSED; &#125; //...&#125; mPendingCheckForTap的run方法里面在注释1首先会先清除mPrivateFlags中PFLAG_PREPRESSED标识，然后在注释2设置PFLAG_PRESSED标识，表示准备执行长按事件，最主要的是注释3，我们看checkForLongClick方法里面干了什么，如下： 1234567891011121314151617//View.javaprivate void checkForLongClick(int delayOffset, float x, float y) &#123; //1、检查mViewFlags，如果可以进行长按事件LONG_CLICKABLE if ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags &amp; TOOLTIP) == TOOLTIP) &#123; //此时mHasPerformedLongPress标志位还是false mHasPerformedLongPress = false; if (mPendingCheckForLongPress == null) &#123; //2、创建了一个CheckForLongPress类型的任务 mPendingCheckForLongPress = new CheckForLongPress(); &#125; //... //3、ViewConfiguration.getLongPressTimeout()返回500毫秒，再减100毫秒等于400毫秒 //通过postDelayed()发送延时400毫秒后执行的任务mPendingCheckForLongPress postDelayed(mPendingCheckForLongPress, ViewConfiguration.getLongPressTimeout() - delayOffset); &#125;&#125; 这个方法在注释1首先检测该View是否可以进行长按事件，View的LONG_CLICKABLE属性默认为false，但是在setOnLongClickListener（）时就会把它设置为true，然后在注释2创建了一个CheckForLongPress类型的任务，然后在注释3通过postDelayed()发送了一个延时消息，即400毫秒后执行mPendingCheckForLongPress任务，它是用来执行长按事件的，我们看这个任务的具体实现，如下： 1234567891011121314151617181920212223242526272829//View.java//用来执行长按事件private final class CheckForLongPress implements Runnable &#123; private float mX; private float mY; @Override public void run() &#123; if ((mOriginalPressedState == isPressed())//1、首先检查mPrivateFlags中是否清除了PFLAG_PRESSED标识，如果清除了表示长按事件取消 &amp;&amp; (mParent != null) &amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) &#123; //2、调用performLongClick()方法 if (performLongClick(mX, mY)) &#123; //3、设置mHasPerformedLongPress为true mHasPerformedLongPress = true; &#125; &#125; //... if (performLongClick(mX, mY)) &#123; mHasPerformedLongPress = true; &#125; &#125; //...&#125;public boolean isPressed() &#123; //返回true表示检测mPrivateFlags中清除了PFLAG_PRESSED标识，false反之 return (mPrivateFlags &amp; PFLAG_PRESSED) == PFLAG_PRESSED;&#125; CheckForLongPress就是用于执行长按事件的，它的run方法里面会先检查mPrivateFlags中是否清除了PFLAG_PRESSED标识，如果清除了就表示长按事件取消，否则就调用performLongClick()方法，里面会最终回调onLongClick()方法回调，如果performLongClick()返回true，就会设置mHasPerformedLongPress为true，否则mHasPerformedLongPress还是为false，即mHasPerformedLongPress是否为true取决performLongClick(float x, float y)是否返回true，接下来我们看performLongClick(float x, float y)方法，如下： 1234567891011121314151617181920212223//View.javapublic boolean performLongClick(float x, float y) &#123; //... final boolean handled = performLongClick(); //... return handled; &#125;public boolean performLongClick() &#123; return performLongClickInternal(mLongClickX, mLongClickY);&#125;private boolean performLongClickInternal(float x, float y) &#123; boolean handled = false; final ListenerInfo li = mListenerInfo; //如果设置了OnLongClickListener回调 if (li != null &amp;&amp; li.mOnLongClickListener != null) &#123; //回调OnLongClickListener的onLongClick方法 handled = li.mOnLongClickListener.onLongClick(View.this); &#125; //... return handled;&#125; 在这个方法中一路跟进，最终来到了performLongClickInternal(float x, float y)方法中，在performLongClickInternal()方法中，如果我们通过setOnLongClickListener()设置了OnLongClickListener回调，这里就会回调我们熟悉的onLongClick()方法，而performLongClickInternal()是否返回true取决于我们在onLongClick()方法中是否返回true，performLongClick()是否返回true取决于performLongClickInternal()是否返回true，然后这里结合上面的黑体字得出一个结论：如果你设置了onLongClickListener，mHasPerformedLongPress是否为true取决我们在onLongClick()方法中是否返回true，如果没有设置，mHasPerformedLongPress就一直为false，这个mHasPerformedLongPress是否为true会影响我们在ACTION_UP是否能够回调onClick()方法的关键。 现在我们通过case ACTION_DOWN知道：如果我们按下手指在500毫秒内没有抬起，就会触发长按事件。下面分析ACTION_UP。 2.2、case ACTION_UP:12345678910111213141516171819202122232425262728293031323334353637383940414243switch (action) &#123; case MotionEvent.ACTION_UP: //... boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; //1、如果mPrivateFlags中包含PFLAG_PRESSED或PFLAG_PREPRESSED标识，都会进入if分支 if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; //... if (prepressed) &#123;//如果mPrivateFlags中只包含PFLAG_PREPRESSED标识，表示用户在100毫秒内抬起了手指，还没执行CheckForTap任务 //2、这里传入为true，即给mPrivateFlags设置一个PFLAG_PRESSED标识 //这里主要让用户看到控件还是按下状态 setPressed(true, x, y); &#125; //3、这个mHasPerformedLongPress为false就进入if分支，mIgnoreNextUpEvent默认为false if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; //4、移除长按事件CheckForLongPress任务消息，即取消长按事件 removeLongPressCallback(); //... if (mPerformClick == null) &#123; //5、如果mPerformClick为null，初始化一个实例 mPerformClick = new PerformClick(); &#125; //6、通过Handler把mPerformClick添加到消息队列，但其实PerformClick中的run方法还是执行performClick()方法，所以我们只要看performClick()方法就行 if (!post(mPerformClick)) &#123; //如果post一个PerformClick失败就执行performClick()方法 performClick(); &#125; &#125; //... //7、移除检测长按事件CheckForTap任务消息，即取消检测长按事件 removeTapCallback(); &#125; break;&#125;return true;//View.java//PerformClick中的run方法还是执行performClick()方法 private final class PerformClick implements Runnable &#123; @Override public void run() &#123; performClick(); &#125; &#125; 我们想象一下，现在我们抬起了手指，分三个时间段抬起： 1、如果你在100毫秒内抬起手指，那么mPrivateFlags肯定只有PFLAG_PREPRESSED标识，且mHasPerformedLongPress为false，根据注释1和3，这样就会执行PerformClick()方法，在执行PerformClick()方法前，在注释4调用removeLongPressCallback()移除长按事件CheckForLongPress任务，即不会触发onLongClick()回调。 2、如果你在100毫秒后到500毫秒才抬起，那么mPrivateFlags肯定只有PFLAG_PRESSED标识，且mHasPerformedLongPress为false，接下来的逻辑和1一样。 3、如果你在500毫秒后才抬起，那么mPrivateFlags肯定只有PFLAG_PRESSED标识，而mHasPerformedLongPress是否为true取决我们是否设置onLongClickListener并在onLongClick()方法中是否返回true。如果你设置了onLongClickListener回调并在onLongClick()方法中返回了false或者你没有设置onLongClickListener回调，那么你还是可以走到注释6执行performClick()方法；但是如果你设置了onLongClickListener回调并在onLongClick()方法中返回了true，那么你就不能执行performClick()方法了。 对照ACTION_DOWN的流程和ACTION_UP的流程就能更好的理解上面3个时间段，所以从这里我们知道：如果你在500毫秒内抬起手指，那么你就只能执行点击事件，不能执行长按事件；如果你在500毫秒后抬起，并且你设置了onLongClickListener并在onLongClick()方法中返回了false 或者 你没有设置onLongClickListener回调，那么你执行完长按事件后还可以执行点击事件，但是如果你设置了onLongClickListener回调并在onLongClick()方法中返回了true，那么你就不能执行点击事件。performClick()和 performLongClick()方法类似，它里面最终回调onClick()方法，如下： 1234567891011121314//View.javapublic boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; //1、执行了OnClickListener的onClick()方法 li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; //... return result; &#125; performClick()方法中的逻辑是，如果你设置了OnClickListener回调，那么就会执行onClick(）方法，大家也注意到performClick()会返回一个true或者false，但是这个返回值对于onTouchEvent()方法没有任何意义，因为上面提到switch语句块的后面一定返回true。这里我们再得出一个结论：OnLongClickListener的onLongClick()方法的优先级高于onClickListener的onClick()方法。 好了现在我们的手指从按下到抬起，就已经分析完onTouchEvent()中的ACTION_DOWN和ACTION_UP分支，如果你的手指在抬起前，不小心移动了一下，就会触发ACTION_CANCEL或ACTION_MOVE，这个时候它就会根据条件(手指是否移出View的范围)通过调用 removeLongPressCallback()或 removeTapCallback()方法移除CheckForLongPress或CheckForTap任务，即取消长按或点击，这里限于篇幅就不再展开分析，大家可自行分析。 3、小结1、View没有子View，所以它的的分发比较简单，从View的dispatchTouchEvent()方法开始进入View的事件分发流程，该方法只负责事件的分发，没有进行实际事件的处理，进行实际事件的处理有两处地方：1、通过外部设置的onTouchListener的onTouch()方法，2、View的onTouchEvent()方法。 2、当一个View要处理点击事件时，如果它设置了onTouchListener，那么onTouch方法就会回调，这时事件如何处理还要看onTouch()方法的返回值，如果返回true，那么onTouchEvent()方法将不会被调用，dispatchTouchEvent()方法直接返回true；如果返回false，onTouchEvent()方法会被调用，这时事件如何处理就要看onTouchEvent()的返回值，在onTouchEvent()中，不管控件可用还是不可用，返回值取决于控件是否可点击，如果控件可点击(clickabale或longClickabale，只要有一个为true)，onTouchEvent()返回true，如果控件不可点击(clickabale和longClickabale都为false)，onTouchEvent()返回false。 3、如果我们同时设置了OnTouchListener、OnLongClickListener和OnClickListener回调，根据优先级，事件的传递顺序是：onTouch() -&gt; onLongClick() -&gt; onClick()，其中除了onClick()都有boolean返回值，返回值能决定下一个方法是否被调用，onClick()优先级最低，连返回值都没有。 4、 对于ViewGroup（也就是当前 View 的父容器）而言，它只认识子 View的dispatchTouchEvent()方法，不认识另外两个处理事件的方法。子View的 onTouch() 和 onTouchEvent() 都是在自己的 dispatchTouchEvent() 里面调用的，他们两个会影响 dispatchTouchEvent() 的返回值，但是对于上级 ViewGroup 而言，它只认识 dispatchTouchEvent() 的返回值。 流程图： ViewGroup的事件分发1、ViewGroup::dispatchTouchEvent()ViewGroup是View的子类，它是一组View的集合，它包含很多子View和子ViewGroup，所以ViewGroup的事件分发比View的复杂，但是ViewGroup的事件分发才是整个事件分发机制的精髓，和View一样ViewGroup的事件分发的起点也是dispatchTouchEvent()，虽然这个方法在View中，但是ViewGroup重写了它，因为它们的分发逻辑不一样。所以我们看ViewGroup的dispatchTouchEvent()方法，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//ViewGroup.java@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; //... //本次事件处理结果 boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; //1、如果本次事件是ACTION_DOWN if (actionMasked == MotionEvent.ACTION_DOWN) &#123; //置空mFirstTouchTarget cancelAndClearTouchTargets(ev); //清除mGroupFlags中的FLAG_DISALLOW_INTERCEPT标志位，这个标志等同于下面的disallowIntercept resetTouchState(); &#125; //ViewGroup是否拦截本次事件标志 final boolean intercepted; //2、如果本次事件是ACTION_DOWN 或者 mFirstTouchTarget为空 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //子View是否禁止ViewGroup拦截事件标志 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123;//如果子View允许ViewGroup拦截事件 //调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定 intercepted = onInterceptTouchEvent(ev); //... &#125; else &#123;//如果子View禁止ViewGroup拦截事件 intercepted = false;//intercepted值为false &#125; &#125; else &#123;//如果本次事件不是ACTION_DOWN又没有target //intercepted值为true，在此之后，当前事件序列中的所有事件序列都由ViewGroup处理，不会再传递给子View intercepted = true; &#125; //... //检查本次事件是否是ACTION_CANCEL final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; //3、如果本次事件不取消并且不拦截，就寻找合适的子View处理 if (!canceled &amp;&amp; !intercepted) &#123; //... //3.1、如果本次事件是ACTION_DOWN if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int childrenCount = mChildrenCount; //如果target是null并且ViewGroup有子View，就寻找某个子View当mFirstTouchTarget if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); final View[] children = mChildren; //从后往前逐个取出子View for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); //判断子View能否接受点击事件：子View可见或在播放动画，并且触摸点在子View范围内 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; //走到这里表示子View满足处理事件的条件 //... //dispatchTransformedTouchEvent()里面会调用子View的dispatchTouchEvent()方法，在这个方法里把事件分发给子View if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; //... //如果dispatchTransformedTouchEvent()返回true，表示找到子View消费本次事件了，就会走到这里, 所以这个子View就被当作mFirstTouchTarget，这里会调用addTouchTarget()方法为mFirstTouchTarget赋值 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; //... &#125;//end...for（） //... &#125;//end...if(newTouchTarget == null &amp;&amp; childrenCount != 0) &#125;//end...if(actionMasked == MotionEvent.ACTION_DOWN...) &#125;///end...if(!canceled &amp;&amp; !intercepted) //4、根据mFirstTouchTarget是否为null做出不同行为 if (mFirstTouchTarget == null) &#123;//这一般有三种情况导致mFirstTouchTarget为空： //1、ViewGroup没有子View； //2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false； //3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true //在这三种情况下ViewGroup就会自己处理事件 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; //有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target： //1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target； //2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target //所以接下来就直接把事件分发给mFirstTouchTarget的child处理处理就行 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; //mFirstTouchTarget是一个单链表结构 while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;//情况1的处理 //因为在找到target时已经调用过dispatchTransformedTouchEvent()了，表示该target的View已经消费了该事件，handle直接等于true handled = true; &#125; else &#123;//情况2的处理 final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;//注意这个intercepted，如果为true，cancelChild为true，会导致子View收到一个ACTION_CANCEL, 表示子View的本次事件取消 //调用dispatchTransformedTouchEvent()方法把事件分发给target if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; //handle的是否为true取决于子View的dispatchTouchEvent()返回值 handled = true; &#125; //清空这个子View对应的target，导致该事件序列的后序事件该子View都无法再收到 if (cancelChild) &#123; //... target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125;//end...while (target != null) &#125;//end...if (mFirstTouchTarget == null) //... &#125;//end...if (onFilterTouchEventForSecurity(ev)) &#125; 这个方法特别长，里面就是整个ViewGroup的事件分发逻辑，我知道大家也没有想看的欲望了，这个方法对应的流程图如下： 可以看到，在同一个事件序列内（从down开始，到up结束），ViewGroup的dispatchTouchEvent()方法可以分为两大过程：1、ACTION_DOWN事件的处理流程；2、除了ACTION_DOWN以外的事件处理流程。下面跟着这两个流程分别走一遍。 2、ViewGroup处理ACTION_DOWN事件的流程ACTION_DOWN事件的处理流程又可以分为两个流程即：ViewGroup拦截事件(intercepted = true)与不拦截事件（intercepted = false）。 看流程图，在dispatchTouchEvent()方法注释2中的if语句会决定 intercepted 的值，如下： 12345678910111213141516//ViewGroup是否拦截本次事件标志final boolean intercepted;//2、如果本次事件是ACTION_DOWN 或者 mFirstTouchTarget为空if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //2.1、子View是否禁止ViewGroup拦截事件标志 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123;//如果子View允许ViewGroup拦截事件 //调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定 intercepted = onInterceptTouchEvent(ev); //... &#125; else &#123;//如果子View禁止ViewGroup拦截事件 intercepted = false;//intercepted值为false &#125;&#125; else &#123; //...&#125; 如果本次事件是ACTION_DOWN也会进入这个if分支，看注释2.1检查 mGroupFlags 中是否包含FLAG_DISALLOW_INTERCEPT标识，默认没有，即默认disallowIntercept为false，所以就会调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent()决定，onInterceptTouchEvent()默认返回false，所以intercepted = false。 2.1、intercepted = false当DOWN事件没有被ViewGroup拦截，intercepted = false，它就会进入dispatchTouchEvent()方法注释3的if语句，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //检查本次事件是否是ACTION_CANCELfinal boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;//...//3、如果本次事件不取消并且不拦截，就寻找合适的子View处理if (!canceled &amp;&amp; !intercepted) &#123; //... //如果本次事件是ACTION_DOWN if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int childrenCount = mChildrenCount; //如果target是null并且ViewGroup有子View，就寻找某个子View当mFirstTouchTarget if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); final View[] children = mChildren; //从后往前逐个取出子View for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); //3.1、判断子View能否接受点击事件：子View可见或在播放动画，并且触摸点在子View范围内 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; //走到这里表示子View满足处理事件的条件 //... //3.2、dispatchTransformedTouchEvent()里面会调用子View的dispatchTouchEvent()方法，在这个方法里把事件分发给子View if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; //... //3.3、如果dispatchTransformedTouchEvent()返回true，表示找到子View消费本次事件了，就会走到这里, 所以这个子View就被当作mFirstTouchTarget，这里会调用addTouchTarget()方法为mFirstTouchTarget赋值 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; //... &#125;//end...for（） //... &#125;//end...if(newTouchTarget == null &amp;&amp; childrenCount != 0) &#125;//end...if(actionMasked == MotionEvent.ACTION_DOWN...)&#125;///end...if(!canceled &amp;&amp; !intercepted) 如果是DOWN事件，假设ViewGroup有子View，就会进入for循环，ViewGroup就会遍历所有子View，先在注释3.1中判断这个子View是否满足接收事件的条件，如果不满足，就再找下一个子View，如果满足，就来到了注释3.2，然后调用dispatchTransformedTouchEvent()方法看这个子View是否消费DOWN事件。 dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)方法如下： 12345678910111213141516171819202122232425262728293031//ViewGroup.java//dispatchTransformedTouchEvent（）只需要关注两个参数：//@params cancel 是否取消本次事件//@params child 准备接收分发事件的子Viewprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; final int oldAction = event.getAction(); //1、如果cancel为true，进入这个if分支 if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; //设置ACTION_CANCEL事件 event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; //... //2、如果cancel为false，进入这个if分支 if (child == null) &#123;//如果child为空 //调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件 handled = super.dispatchTouchEvent(event); &#125; else &#123;//如果child不为空 //... //调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件 handled = child.dispatchTouchEvent(event); &#125; return handled;&#125; 因为传入cancel为false，所以来带注释2的if分支，因为传入的child不为空，所以调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件，到这里DOWN事件就传递给子View，如果子View是一个View，那么它的处理流程就像前面介绍的View的事件分发一样，如果子View是一个ViewGroup，那么它的处理流程就又是ViewGroup的事件分发。 好了，假设子View消费这个事件，返回true，则dispatchTransformedTouchEvent()返回true，ViewGrou找到了要消费这个DOWN事件的子View，这时进入注释3.3，调用addTouchTarget(child, idBitsToAssign)方法，如下： 123456789101112131415//ViewGroup.javaprivate TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; //给mFirstTouchTarget赋值 mFirstTouchTarget = target; return target;&#125;//ViewGroup::TouchTargetpublic static TouchTarget obtain(@NonNull View child, int pointerIdBits) &#123; //... target.child = child; return target;&#125; 如果找到了要消费这个DOWN事件的子View，那么这个子View就会被赋值给mFirstTouchTarget的child字段，这个就相当于做了一个记录，当下一个事件到来时，如果发现mFirstTouchTarget不为空，我就可以直接把事件分发给mFirstTouchTarget中的View，就不用再去遍历子View了。那么mFirstTouchTarget是什么？它是一个TouchTarget类型，如下： 12345678///ViewGroup::TouchTargetprivate static final class TouchTarget &#123; //当前消费事件的View public View child; //它的下一个结点 public TouchTarget next; //...&#125; 它是一个链表结构，为什么mFirstTouchTarget是一个链表？我的猜测是由于多点触控的存在，例如我5个手指可以同时触摸到列表的5个子View，如果5个子View都是要消费这个DOWN事件的话，那么就要用链表把它们记录起来，当下一个事件到来时，5个子View都能分发到事件。 好了，现在找到可以消费事件的子View了，并且mFirstTouchTarget也被赋值了，就一个break跳出for循环，直接来到dispatchTouchEvent()方法的注释4，如下： 1234567891011121314151617181920212223 //4、根据mFirstTouchTarget是否为null做出不同行为if (mFirstTouchTarget == null) &#123; //...&#125; else &#123;//有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target： //1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target； //2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target //所以接下来就直接把事件分发给mFirstTouchTarget的child处理就行 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; //mFirstTouchTarget是一个单链表结构 while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;//情况1的处理 //因为在找到target时已经调用过dispatchTransformedTouchEvent()了，表示该target的View已经消费了该事件，handle直接等于true handled = true; &#125; else &#123;//情况2的处理 //... &#125; predecessor = target; target = next; &#125;//end...while (target != null) &#125;//end...if (mFirstTouchTarget == null) mFirstTouchTarget不为空，就来到else分支，然后因为是DOWN事件，在上面的for循环中找到子View消费事件后alreadyDispatchedToNewTouchTarget赋值为true并且mFirstTouchTarget等于newTouchTarget实例，就来到情况1的处理的if分支，这里直接返回了true，因为上面在for循环中target的View已经消费了该事件，handle直接等于true。 到这里在DOWN事件下ViewGroup不拦截的情况下分析完毕。上面是假设找到了子View并且子View消费了事件，这样当下一次事件到来时mFirstTouchTarget不为空，就直接把这个事件给子View；但是如果上面是找到子View而这个子View不消费这个DOWN事件，即子View的dispatchTouchEvent()方法返回false，那么dispatchTransformedTouchEvent()返回false，就导致无法为mFirstTouchTarget赋值，mFirstTouchTarget为空，当下一次事件序列到来时，ViewGroup会直接处理，而不再转发给子View。这里得出一个结论：子View如果不消费ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，而是交给它的父ViewGroup处理；子View一旦消费ACTION_DOWN事件，那么同一事件序列的其他事件都会交给它处理。 所以如果此时子View没有消费ACTION_DOWN事件，或者我重写了ViewGroup的onInterceptTouchEvent()并返回了true，那么ViewGroup就会开始拦截事件，接下来看在DOWN事件下ViewGroup拦截的情况，即intercepted = true。 2.2、intercepted = true如果ViewGroup拦截DOWN事件，那么intercepted = true，就不会进入dispatchTouchEvent()方法的注释3的if语句，这样在DOWN事件下ViewGroup就不会遍历它的子View，也就无法调用dispatchTransformedTouchEvent()找到要消费事件的子View，同理无法调用addTouchTarget()方法为mFirstTouchTarget赋值，就会导致在DOWN事件下mFirstTouchTarget为空，这样就直接来到了dispatchTouchEvent()方法的注释4的if语句，如下： 123456789101112131415 //检查本次事件是否是ACTION_CANCEL final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;//... //4、根据mFirstTouchTarget是否为null做出不同行为if (mFirstTouchTarget == null) &#123;//这一般有三种情况导致mFirstTouchTarget为空： //1、ViewGroup没有子View； //2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false； //3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true //在这三种情况下ViewGroup就会自己处理事件 //注意第三个参数传入null，表示ViewGroup自己处理事件 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; else &#123; //... &#125;//end...if (mFirstTouchTarget == null) 很明显这里是情况3，所以没有找到子View，dispatchTransformedTouchEvent()方法的第三个参数为空，而第二个参数为false，因为不是ACTION_CANCEL事件，我们参考上面的dispatchTransformedTouchEvent()方法分析，如下： 123456789101112131415161718//ViewGroup.java//dispatchTransformedTouchEvent（）只需要关注两个参数：//@params cancel 是否取消本次事件//@params child 准备接收分发事件的子Viewprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; //... //2、如果cancel为false，进入这个if分支 if (child == null) &#123;//如果child为空 //调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件 handled = super.dispatchTouchEvent(event); &#125; else &#123;//如果child不为空 //... //调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件 handled = child.dispatchTouchEvent(event); &#125; return handled;&#125; 里面就会调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件，ViewGroup的父类是View，所以super.dispatchTouchEvent(event)里面的处理逻辑就是View的事件分发的处理逻辑，见前面分析的View的事件分发。 到这里在DOWN事件下ViewGroup拦截的情况分析完毕。这里得出一个结论：ViewGroup如果在onInterceptTouchEvent()方法的ACTION_DOWN事件中返回true，那么整个事件序列都会交给ViewGroup处理，不再交给子View。 我们回到dispatchTouchEvent()方法，还有一点要注意的是在ACTION_DOWN下不管拦截还是不拦截都会进入dispatchTouchEvent()方法中注释1的if语句，如下： 1234567 //1、如果本次事件是ACTION_DOWNif (actionMasked == MotionEvent.ACTION_DOWN) &#123; //置空mFirstTouchTarget cancelAndClearTouchTargets(ev); //清除mGroupFlags中的FLAG_DISALLOW_INTERCEPT标志位，这个标志等同于下面的disallowIntercept resetTouchState();&#125; 这个if语句的作用就是防止前一次事件序列对本次事件序列造成影响，所以它会向先调用 cancelAndClearTouchTargets(ev)清空mFirstTouchTarget，然后调用resetTouchState()清除FLAG_DISALLOW_INTERCEPT标志位，因为ACTION_DOWN事件是一个新的事件序列的开始，所以dispatchTouchEvent()方法首先要做的就是判断是不是迎来了一个新的事件序列，所以要判断该事件是否是ACTION_DOWN 事件，如果是 ACTION_DOWN 事件，作为一个事件序列的开头，应当要消除前面的事件序列可能留下的影响。关于FLAG_DISALLOW_INTERCEPT标志位后面会讲。 到这里ViewGroup处理ACTION_DOWN事件的流程分析完毕，下面我们来看除了ACTION_DOWN以外的事件的处理流程。 3、ViewGroup处理除了ACTION_DOWN以外的事件的流程ACTION_DOWN事件的处理流程又可以分为两个流程即：mFirstTouchTarget != null与mFirstTouchTarget == null。你会发现intercepted这个标记位似乎已经没有多大作用， 它如果是true，它根本不会进入dispatchTouchEvent()方法的注释3，就算是false进入了dispatchTouchEvent()方法的注释3，它也不会满足注释3.1的条件。所以我们就直接来到注释4。 3.1、mFirstTouchTarget == null123456789101112131415 //检查本次事件是否是ACTION_CANCEL final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;//... //4、根据mFirstTouchTarget是否为null做出不同行为if (mFirstTouchTarget == null) &#123;//这一般有三种情况导致mFirstTouchTarget为空： //1、ViewGroup没有子View； //2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false； //3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true //在这三种情况下ViewGroup就会自己处理事件 //注意第三个参数传入null，表示ViewGroup自己处理事件 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; else &#123; //... &#125;//end...if (mFirstTouchTarget == null) 这里1、2、3情况都有可能发生，从ACTION_DOWN的处理流程我们知道为mFirstTouchTarget赋值的过程只会在处理ACTION_DOWN事件的时候出现，所以如果在处理ACTION_DOWN事件的时候ViewGroup没有子View，不会进入for循环，导致mFirstTouchTarget为空；如果ViewGroup有子View，进入了for循环，但是View不消费DOWN事件，即在dispatchTouchEvent()返回了false，导致无法调用addTouchTarget()方法为mFirstTouchTarget赋值，导致mFirstTouchTarget为空；ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true，不会进入注释3的if语句，导致mFirstTouchTarget为空；所以在处理ACTION_DOWN事件的时候没有找到mFirstTouchTarget，就会导致在除了ACTION_DOWN其他事件到来时mFirstTouchTarget == null，这里就直接让ViewGroup自己处理事件了。 3.2、mFirstTouchTarget != null123456789101112131415161718192021222324252627282930313233343536373839 //4、根据mFirstTouchTarget是否为null做出不同行为if (mFirstTouchTarget == null) &#123; //...&#125; else &#123;//有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target： //1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target； //2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target //所以接下来就直接把事件分发给mFirstTouchTarget的child处理就行 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; //mFirstTouchTarget是一个单链表结构 while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;//情况1的处理 //... &#125; else &#123;//情况2的处理 //4.1 final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;//注意这个intercepted，如果为true，cancelChild为true，会导致子View收到一个ACTION_CANCEL, 表示子View的本次事件取消 //4.2、调用dispatchTransformedTouchEvent()方法把事件分发给target if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; //handle的是否为true取决于子View的dispatchTouchEvent()返回值 handled = true; &#125; //4.3、清空这个子View对应的target，导致该事件序列的后序事件该子View都无法再收到 if (cancelChild) &#123; //... target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; predecessor = target; target = next; &#125;//end...while (target != null) &#125;//end...if (mFirstTouchTarget == null) mFirstTouchTarget != null，表示在处理ACTION_DOWN事件的时候已经找到mFirstTouchTarget，就会进入注释4的else分支，这里是情况2，就会进入情况2的处理的else分支，注释4.1的cancelChild这个值会决定子View是收到ACTION_CANCEL事件还是其他事件，而cancelChild的值取决于intercepted的值，所以如果ViewGroup在除了ACTION_DOWN以外的其他事件中的onInterceptTouchEvent(ev)方法返回了true，导致intercepted = true，从而cancelChild = true，而如果ViewGroup一直保持默认状态，intercepted = false，从而cancelChild = false，紧接着在注释4.2把cancelChild和target.child传进了dispatchTransformedTouchEvent()方法中。 我再贴一下dispatchTransformedTouchEvent()方法的代码，如下： 1234567891011121314151617181920212223242526272829//ViewGroup.javaprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; final int oldAction = event.getAction(); //1、如果cancel为true，进入这个if分支 if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; //设置ACTION_CANCEL事件 event.setAction(MotionEvent.ACTION_CANCEL); //分发ACTION_CANCEL事件 if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; //... //2、如果cancel为false，进入这个if分支 if (child == null) &#123; //调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件 handled = super.dispatchTouchEvent(event); &#125; else &#123; //... //调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件 handled = child.dispatchTouchEvent(event); &#125; return handled;&#125; 可以看到如果cancel为true，进入注释1这个if分支，里面会set一个ACTION_CANCEL事件，然后传递给target记录的子View；如果cancel为false，进入注释2这个else分支，调用child.dispatchTouchEvent(event)，表示让target记录的子View决定是否处理本次事件，前面已经讲过了。 好，现在我们走出dispatchTransformedTouchEvent()方法，来到注释4，如果cancelChild为true，就会调用TouchTarget的recycler()方法回收这个target，这样做的后果是什么呢？这样相当于清空了mFirstTouchTarget，当下一次事件到来时mFirstTouchTarget == null，ViewGroup直接处理事件，不会再分发给子View。 到这里ViewGroup处理除了ACTION_DOWN以外事件的流程分析完毕。 4、子View如何禁止ViewGroup拦截事件前面的分析都是默认子View不禁止ViewGroup拦截事件，所以ViewGroup可以通过onInterceptTouchEvent()返回true从而拦截下子View的事件，但此时子View希望依然能够响应这些事件该怎么办呢？Android给我们提供了一个方法：requestDisallowInterceptTouchEvent(boolean) 用于设置是否允许拦截，如下： 1234567891011121314//ViewGroup.java@Overridepublic void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; //... if (disallowIntercept) &#123; mGroupFlags |= FLAG_DISALLOW_INTERCEPT; &#125; else &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; // Pass it up to our parent if (mParent != null) &#123; mParent.requestDisallowInterceptTouchEvent(disallowIntercept); &#125;&#125; 当子View调用getParent.requestDisallowInterceptTouchEvent(true)，mGroupFlags就会有FLAG_DISALLOW_INTERCEPT标识，当子View调用getParent.requestDisallowInterceptTouchEvent(false)，mGroupFlags就会清除FLAG_DISALLOW_INTERCEPT标识，那么FLAG_DISALLOW_INTERCEPT标识又是怎么控制ViewGroup的拦截的呢？如下： 12345678final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;if (!disallowIntercept) &#123;//如果子View允许ViewGroup拦截事件 //调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定 intercepted = onInterceptTouchEvent(ev); //...&#125; else &#123;//如果子View禁止ViewGroup拦截事件 intercepted = false;//intercepted值为false&#125; 子View通过调用getParent.requestDisallowInterceptTouchEvent(true)，来禁止ViewGroup拦截除了ACTION_DOWN以外的其他事件，这样当下一个事件到来时就会交给这个子View， 为什么是除了ACTION_DOWN以外的其他事件？因为ACTION_DOWN事件是事件序列的开始，ACTION_DOWN事件会先经过ViewGroup的onInterceptTouchEvent()方法，从ACTION_DOWN事件的处理流程 - intercepted = true我们知道，如果ViewGroup一开始在onInterceptTouchEvent()的ACTION_DOWN返回true，它就不会进入dispatchTouchEvent()方法的注释3的if语句，这样在DOWN事件下就无法找到mFirstTouchTarget，这样当同一个事件序列的其他事件到来时，mFirstTouchTarget == null，这样ViewGroup只能把事件交给自己处理，无法传递给子View，也就无法调用子View的dispatchTouchEvent()方法，这样子View在dispatchTouchEvent()方法中调用getParent.requestDisallowInterceptTouchEvent(true)就没有意义了。 5、小结从ViewGroup的事件分发中得出几个结论： 1、ViewGroup如果在onInterceptTouchEvent()方法的ACTION_DOWN事件中返回true，那么整个事件序列都会交给ViewGroup处理，不再交给子View，从而导致无法调用子View的dispatchTouchEvent()方法，导致子View调用getParent.requestDisallowInterceptTouchEvent(true)失效。 2、ViewGroup如果在onInterceptTouchEvent()方法中一旦拦截除了ACTION_DOWN的事件，那么子View将会收到一个ACTION_CANCEL事件，并且接下来的事件都是交给ViewGroup处理。 3、1、2点的含义都是ViewGroup决定拦截事件，那么一旦ViewGroup决定拦截事件，那么接下来的事件都是交给ViewGroup处理，并且ViewGroup的onInterceptTouchEvent()方法在这个事件序列内不会再调用，这说明ViewGroup的onInterceptTouchEvent()方法不是每次都调用,只有ViewGroup的dispatchTouchEvent()才能保证每次调用。 3、在ViewGroup中ACTION_DOWN 事件负责寻找 target，即寻找能够消费ACTION_DOWN事件的子View，如果找到，那么接下来同一事件序列内的所有事件都会交给这个子View处理，不再交给ViewGroup；如果没有找到，有两种情况：1、ViewGroup没有子View，2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false，那么接下来同一事件序列下的所有事件都是ViewGroup自己处理。 4、子View如果不消费ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，而是交给它的父ViewGroup处理；子View一旦消费ACTION_DOWN事件，如果ViewGroup不拦截，那么同一事件序列的其他事件都会交给子View处理。 5、当调用super.dispatchTouchEvent(event)就代表ViewGroup开始自己处理事件，里面会执行ViewGroup的onTouchEvent(), 逻辑和View的事件分发一样。 结语当点击事件到达ViewGroup时，它的dispatchTouchEvent()方法就会被调用，如果这个ViewGroup的onInterceptTouchEvent()方法返回true，就表示它要拦截当前事件，接下来这个事件序列内的事件都会交给它处理，即super.dispatchTouchEvent()方法得到调用；如果这个ViewGroup的onInterceptTouchEvent()方法返回false，就表示它不拦截当前事件，这时当前事件就会传递给它的子View，接着子View的dispatchTouchEvent()方法就会被调用，如果子View是一个View，那么它的处理流程就像前面介绍的View的事件分发一样，如果子View是一个ViewGroup，那么它的处理流程就又是ViewGroup的事件分发，如此递归，从上到下，直到整颗View树都收到事件，接下来递归返回，从下到上，每一层的返回值都决定是否消费本次事件，如果消费，返回true，它的上一层就无法处理这个事件，如果不消费，返回false，它的上一层又继续传给上一层，直到根视图。 View的事件分发小结和ViewGroup的事件分发小结都可以在源码中找到证明，可以自行验证一下，本文通过源码 + 流程图 说明了整个View的事件分发体制，在看的过程最好要结合上下文来看，始终记住这是在同一个事件序列内，跟着流程图的每一个分支在源码中走一遍，那样你就会有更深刻的理解。 参考资料： Android事件分发完全解析之事件从何而来 通过流程图来分析Android事件分发","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"view","slug":"view","permalink":"http://yoursite.com/tags/view/"}]},{"title":"View的工作原理","date":"2019-07-22T11:57:11.000Z","path":"2019/07/22/View的工作原理/","text":"前言在Android中View一直扮演着一个很重要的角色，它是我们开发中视觉的呈现，我平常也使用着Android提供的丰富且功能强大的控件，有时候遇到一个很炫酷的自定义View的开源库，我们也是拿来主义，时间长了你就会发现你只是一个只会使用控件和依赖被人开源库的程序员，这并不是一个开发者，所以我们并不能只满足于使用，我们要理解它背后的工作原理和流程，这样才能自己做出一个属于自己的控件，一直都说自定View是Android进阶中的一道门槛，当其实自定义View当你理解了它的原理后，你就会发现它也不过如此。本文将从源码的角度探讨View工作的三大流程，对View做进一步的认识。俗话说的好：源码才是最好的老师。 本文代码基于Android8.0，相关源码位置如下： frameworks/base/core/java/android/*.java(*代表View, ViewGroup, ViewRootImpl) frameworks/base/core/java/android/FrameLayout.java View何时开始绘制？- requestLayout()提到View，就不得不讲起Window，在Window,WindowManager和WindowManagerService之间的关系文章中讲过，Widnow是View得载体，在ViewRootImpl的setView方法中添加Winodw到WMS之前，会先调用requestLayout绘制整颗View Hierarchy的绘制，如下： 所以我们先从requestLayout()中看起，该方法如下： 123456789101112131415161718//ViewRootImpl.javapublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; //检查是否在主线程，在子线程绘制UI会抛出异常，见下方 checkThread(); //是否measure和layout布局的开关 mLayoutRequested = true; //1、准备开始遍历View Hierarchy绘制 scheduleTraversals(); &#125;&#125;void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); &#125;&#125; requestLayout()中首先会检查线程的合法性，Android规定必须在主线程中操作UI，那么为什么不能在子线程中访问UI呢？这是因为Android的UI控件都不是线程安全的，如果在多线程环境下并发访问控件会导致控件处于不可预测状态。接着我们来看注释1，调用了ViewRootImpl的scheduleTraversals方法，如下： 123456789101112//ViewRootImpl.javavoid scheduleTraversals() &#123; if (!mTraversalScheduled) &#123;//防止同一帧绘制多次 mTraversalScheduled = true; //拦截同步Message，优先处理异步Message mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //1、Choreographer回调，里面执行最终会执行mTraversalRunnable中的绘制任务 mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); //... &#125; &#125; 在Android4.1之前Android的UI流畅性很差，所以在Android4.1之后引入了Choreographer机制和Vsync机制用来解决这个问题，Choreographer管理者动画、输入和绘制的时机，Vsync叫Vertical Synchronization（垂直同步）信号，每隔 16ms Choreographer就会收到来自native层的Vsync信号，这时Choreographer就会根据事件类型进行相应的回调操作，Choreographer支持4种事件类型回调：输入(CALLBACK_INPUT)、绘制(CALLBACK_TRAVERSAL)、动画(CALLBACK_ANIMATION)、提交(CALLBACK_COMMIT)，并通过postCallback方法在对应需要同步Vsync刷新处进行注册，等待回调，关于这个细节和原理可以看Android图形系统-Choreographer和Android垂直同步和三重缓存，这里我们并不深究Choreographer机制和Vsync机制，我们看到注释1中的Choreographer的postCallback方法提交了CALLBACK_TRAVERSAL类型的回调，它对应着mTraversalRunnable绘制操作，而mTraversalRunnable是一个TraversalRunnable类型的绘制任务，最终回调会执行这个任务，mTraversalRunnable的run方法源码如下： 12345678//ViewRootImpl.javafinal class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; //1、里面会执行performTraversals() doTraversal(); &#125;&#125; doTraversal()里面会执行performTraversals方法，点开doTraversal方法看一下，如下： 1234567891011//ViewRootImpl.javavoid doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; //移除拦截同步Message屏障 mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); //1、今天的主角，performTraversals()方法 performTraversals(); //... &#125;&#125; 在doTraversal() 方法里面我们终于看到我们熟悉的方法：performTraversals()。 View树绘制的起点 - performTraversals()performTraversals()它是整个View Hierarchy绘制的起点，它里面会执行View绘制的三大工作流程，我们先看一下精简版的performTraversals方法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243//ViewRootImpl.javaprivate void performTraversals() &#123; //mView是在View与ViewRootImpl建立关联的时候被赋值的，即调用ViewRootImpl的setView方法时，它代表着View Hierarchy的根节点，即根视图 final View host = mView; //... WindowManager.LayoutParams lp = mWindowAttributes; //desiredWindowWidth和desiredWindowHeight分别代表着屏幕的宽度和高度 int desiredWindowWidth; int desiredWindowHeight; //... if (mLayoutRequested) &#123; final Resources res = mView.getContext().getResources(); //... //1、这里调用了measureHierarchy方法，里面会调用performMeasure方法，执行View Hierarchy的measure流程，见下方 windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); //... &#125; //... if(didLayout)&#123; //2、这里调用了performLayout方法，执行View Hierarchy的layout流程 performLayout(lp, mWidth, mHeight); //... &#125; //... if (!cancelDraw &amp;&amp; !newSurface) &#123; //... //3、这里调用了performDraw方法，执行View Hierarchy的draw流程 performDraw(); &#125; //...&#125; private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) &#123; int childWidthMeasureSpec; int childHeightMeasureSpec; //... //1.1、顶级View在调用performMeasure方法之前，会先调用getRootMeasureSpec方法来生成自身宽和高的MeasureSpec childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); //1.2、这里调用performMeasure方法，执行View Hierarchy的measure流程 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; performTraversals方法里面非常复杂，我们看的时候千万不要深究其中的细节，不然就走火入魔了，我们找出个整体框架就行，我们先看注释1、2、3，可以看到依此调用measureHierarchy() -&gt; performLayout() -&gt; performDraw()，而measureHierarchy()里面最终调用performMeasure()，所以performTraversals()可以看作依此调用了performMeasure() -&gt; performLayout() -&gt; performDraw()，分别对应顶级View的measure、layout和draw流程，顶级View可以理解为View Hierarchy的根节点，它一般是一个ViewGroup，就像Activity的DecorView一样。 ps： 1、在performTraversals()方法中，performMeasure()可能会执行多次，而performLayout()和performDraw()最多执行一次。 2、本文讨论的顶级View你可以把它类比成Activity的DecorView，但是它其实就是View树的根结点，DecorView也是Activity中View树的根结点。 接下来我们就照着performTraversals() 中的整体框架来讲解View工作的三大流程。 View的测量流程 - performMeasure()1、MeasureSpec讲解View的measure流程前，不得不先讲解一下MeasureSpec的含义，MeasureSpec是一个32位的int值，它是View的一个内部类，它的高2位代表着SpecMode，表示测量模式，它的低30位表示SpecSize，表示测量大小，系统通过位运算把SpecMode和SpecSize合二为一组成一个32位int值的MeasureSpec。 下面看一下MeasureSpec的里面组成，如下： 123456789101112131415161718192021222324252627282930//View.javapublic static class MeasureSpec &#123; //左移位数 private static final int MODE_SHIFT = 30; //位掩码 private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; //代表着三种SpecMode public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; //makeMeasureSpec方法是把SpecMode和SpecSize通过位运算组成一个MeasureSpec并返回 public static int makeMeasureSpec(int size,int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; //getMode方法是从给定的MeasureSpec中取出SpecMode public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; //getSize方法是从给定的MeasureSpec中取出SpecSize public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125;&#125; 可以看到MeasureSpec提供了三个工具方法分别用来组合MeasureSpec、从MeasureSpec中取出SpecMode、从MeasureSpec中取出SpecSize，其中SpecMode有三种取值，如下： UNSPECIFIED：它表示父容器对子View的绘制的大小没有任何限制，要多大给多大，这种情况一般适用于系统内部，表示一种测量状态。 EXACTLY：它表示父容器已经测量出子View需要的精确大小SpecSize，这个时候View的最终大小就是SpecSize的值，它对应于LayoutParams中match_parcent和具体的数值这两种模式。 AT_MOST：它表示父容器为子View的大小指定了一个最大值SpecSize，这个时候View的大小不能大于这个值，它对应于LayoutParams中的wrap_content这种模式。 1.1 如何确定View的MeasureSpec？除了顶级View，其他View的MeasureSpec都是由父容器的MeasureSpec和自身的LayoutParams共同决定的，LayoutParams就是你平时在编写View的xml属性时那些带有layout_XX前缀开头的布局属性，对于顶级View和在View树中子View的MeasureSpec的生成规则有点不一样，见下面分析： 1.1.1、顶级View的MeasureSpec的创建 - getRootMeasureSpec()由于顶级View是View树的根结点，所以它没有父容器，所以它的MeasureSpec是由屏幕窗口的尺寸和自身的LayoutParams来共同决定，上面注释1.1我们讲到顶级View在调用performMeasure方法之前，会先调用ViewRootImpl的getRootMeasureSpec方法来生成自身宽和高的MeasureSpec，我们来看一下getRootMeasureSpec方法，如下： 12345678910111213141516//ViewRootImpl.javaprivate static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT://如果是MATCH_PARENT,那么就是EXACTLY measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT://如果是WRAP_CONTENT,就是AT_MOST measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default://如果是固定的值,也是EXACTLY measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; windowSize就是是传入的desiredWindowWidth或desiredWindowHeight，它表示屏幕的大小，rootDimension就是传入的屏幕窗口的LayoutParams的大小模式，对应我们平时写的layout_width或layout_height属性，该属性无非就三个值：match_parent、wrap_content和固定的数值，所以从getRootMeasureSpec方法可以看到，顶级View的MeasureSpec的创建规则如下： 其中rootSize表示顶级View大小。 1.1.2、子View的MeasureSpec的创建 - getChildMeasureSpec()在1中，顶级View的MeasureSpec已经创建好了，这时候就要根据这个MeasureSpec去生成子View的MeasureSpec，子View的MeasureSpec的创建是从ViewGroup的measureChildWithMargins方法开始，如下： 1234567891011//ViewGroup.javarotected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; //得到子View的margin final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //1、这里调用了getChildMeasureSpec方法，里面就是创建子View的MeasureSpec，这里创建子View宽的MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); //同理，这里创建子View高的MeasureSpec final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); //如果子View是一个ViewGroup，递归measure下去 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 上述方法会对子View进行measure，由注释1得知，在调用子View的measure方法前，会先调用getChildMeasureSpec方法获得子View的MeasureSpec，从getChildMeasureSpec方法的参数可以看出，子View的MeasureSpec的创建与父容器的MeasureSpec和子View本身的LayoutParams有关，此外还和View的margin及padding有关，下面我们来看ViewGroup的getChildMeasureSpec方法，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//ViewGroup.javapublic static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; //取出父容器的测量模式specMode int specMode = MeasureSpec.getMode(spec); //取出父容器的测量大小specSize int specSize = MeasureSpec.getSize(spec); // padding是指父容器中已占用的空间大小，因此子View最大可用大小size == 父容器剩余大小 == 父容器的尺寸减去padding int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; case MeasureSpec.EXACTLY://如果父容器是EXACTLY if (childDimension &gt;= 0) &#123;//如果子View的LayoutParams是固定大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;//如果子View的LayoutParams是MATCH_PARENT //子View的MeasureSpec为父容器剩余大小 + EXACTLY resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;//如果子View的LayoutParams是WRAP_CONTENT //子View的MeasureSpec为父容器剩余大小 + AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; case MeasureSpec.AT_MOST://如果父容器是AT_MOST if (childDimension &gt;= 0) &#123; //子View的MeasureSpec为子View大小 + EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; //子View的MeasureSpec为父容器剩余大小 + AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; //子View的MeasureSpec为父容器剩余大小 + AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; case MeasureSpec.UNSPECIFIED://如果父容器是UNSPECIFIED，这个平时开发用不到 if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 可以看到getChildMeasureSpec方法里面的逻辑还是很清楚的，首先根据父容器的测量模式specMode分为三大类：EXACTLY、AT_MOST和UNSPECIFIED，每一类又和子View的LayoutParams的的三种大小模式：固定大小、MATCH_PARENT和WRAP_CONTENT组合，所以总共有3 X 3 = 9种组合，所以根据getChildMeasureSpec方法可以得出子View的MeasureSpec的创建规则如下： 其中childSize表示子View的大小，parentSize表示父容器剩余大小。 2、View和ViewGroup的measure流程分析完View的MeasureSpec的创建后，我们继续回到View的measure流程，大家都知道ViewGroup是继承自View的，所以View的measure流程，分为两种情况，一种是View的measure流程，一种是ViewGroup的measure流程，但是不管是View的measure流程还是ViewGroup的measure流程都是从ViewRootImpl的performMeasure()开始，并且都会先调用View的measure方法，如下： 123456//ViewRootImpl.java private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; //... //1、调用了View的measure方法 mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 我们继续看View的measure方法，如下： 1234567//View.java public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; //... //1、调用了onMeasure方法 onMeasure(widthMeasureSpec, heightMeasureSpec); //... &#125; 可以看到measure方法是一个final方法，说明这个方法不能够被子类重写，这个方法把measure的具体过程交给了onMeasure方法去实现，所以View和ViewGroup的measure流程的差异就从这个onMeasure方法开始，见下面分析。 2.1、View的measure流程从上述知道View的measure起点在View的measure方法中，并且View的measure方法会调用View的onMeasure方法，View::measure() -&gt; View::onMeasure()，所以我们直接看onMeasure方法在View中的实现，如下： 12345678//View.javaprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //1、 如果View没有重写onMeasure方法，则会调用setMeasuredDimension方法设置宽高，在设置之前先调用getDefaultSize方法获取默认宽高 setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec) );&#125; View中的onMeasure方法的默认实现是先调用getDefaultSize方法获取默认宽高，然后再调用调用setMeasuredDimension方法设置View的宽高，当调用setMeasuredDimension方法设置View的宽高后，就可以通过getMeasureWidth()或getMeasureHeight()获得View测量的宽高，所以我们先看一下 getDefaultSize()方法是如何获取默认的宽高，该方法源码如下： 123456789101112131415161718//View.javapublic static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; //如果specMode是UNSPECIFIED，返回的大小就是传进来的size，而这个size就是通过getSuggestedMinimumWidth()或getSuggestedMinimumHeight()方法获得的 case MeasureSpec.UNSPECIFIED: result = size; break; //如果specMode是AT_MOST或EXACTLY，返回的大小就是MeasureSpec中的specSize case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; getDefaultSize方法的逻辑很简单，除了UNSPECIFIED这种模式，其他测量模式都返回MeasureSpec中的specSize，而这个specSize就等于父容器给View测量后的大小，所以我们可以得出一个结论：直接继承View写自定义控件时需要重写onMeasure方法并设置wrap_content时自定义View自身的大小，这是因为如果自定义View在xml文件写了layout_XX = wrap_content这个属性，那么在创建它的MeasureSpec时，它的specMode就会等于AT_MOST，而从getDefaultSize方法看出，如果specMode是AT_MOST或EXACTLY，它们两个返回的值是一样的，都是MeasureSpec中的specSize，通过上面所讲的子View的MeasureSpec的创建规则可知specSize是等于parentSize即父容器剩余的大小，这样就会造成这个自定义View会填充满整个父容器，效果和match_parent一样，并不按你想象那样的大小。所以以后在自定义View时，如果有wrap_content这个场景，就要重写onMeasure方法，可以参考下面的模板，如下： 12345678910111213141516//View.javaprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int width, height; //经过计算，控件所占的宽和高分别对应width和height // ………… //我们只需要在View为wrap_content时设置我们经过计算得出的View的默认宽高width和height即可 //其他模式如EXACTLY，就直接设置父容器给我们测量出来的宽高即可 setMeasuredDimension( (measureWidthMode == MeasureSpec.AT_MOST) ? width : measureWidth , (measureHeightMode == MeasureSpec.AT_MOST) ? height : measureHeight );&#125; 讲完了getDefaultSize()中AT_MOST和EXACTLY模式情况，接着讲UNSPECIFIED这种模式的情况，从getDefaultSize方法中可以看出如果specMode是UNSPECIFIED，返回的大小就是传进来的size，而这个size就是通过getSuggestedMinimumWidth()或getSuggestedMinimumHeight()方法获得的，所以我们以getSuggestedMinimumWidth方法为例子，看一些如果获取在UNSPECIFIED模式下的宽，getSuggestedMinimumHeight()方法同理，getSuggestedMinimumWidth方法源码如下： 123456789101112//View.java protected int getSuggestedMinimumWidth() &#123; //根据View有无背景返回大小，getMinimumWidth()见下方 return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;//Drawable.javapublic int getMinimumWidth() &#123; //getIntrinsicWidth()返回Drawable的宽，默认返回-1 final int intrinsicWidth = getIntrinsicWidth(); return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;&#125; mBackground就等于View的背景，即android:background属性，mMinWidth就等于你在View的xml布局中写了“android:minWidth”这个属性，mBackground.getMinimumWidth()就是获取View的背景的宽度，所以我们得出结论：在UNSPECIFIED模式下，如果View没有设置背景，那么View的宽就等于android:minWidth，如果View设置了背景，那么View的宽就等于View的背景background的宽和android:minWidth的最大值，高度同理。 View的onMeasure方法执行完后，就可以通过getMeasureWidth()或getMeasureHeight()获得View测量的宽高，但是有可能会不准确，因为有时候系统会进行多次measure，才能确定最终测量宽高，所以最好是在onLayout方法中去获取View的宽高。 2.2、ViewGroup的measure流程 (以FrameLayout为例)从上述知道ViewGroup的measure起点也在View的measure方法中，而View的measure方法会调用View的onMeasure方法，ViewGroup继承自View，但是它是一个抽象类并没有重写View的onMeasure方法，而是由ViewGroup的子类如LinearLayout、FrameLayout等重写onMeasure方法以实现不同的measure流程，这里以FrameLayout为例，View::measure() -&gt; FrameLayout::onMeasure() ，我们来看FrameLayout的onMeasure方法，如下： 12345678910111213141516171819202122//FrameLayout.javaprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //获取子View的个数 int count = getChildCount(); //... //遍历所有子View，测量每个子View的大小 for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123;//如果子View可见 //1、调用ViewGroup的measureChildWithMargins方法，测量子View的大小 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); //子View测量完后，FrameLayout就可以通过View的getMeasuredWidth或getMeasuredHeight获得子View的宽高，从而得出自己的宽高 //根据FrameLayout的叠加特性，它自身的测量宽高就是所有子View宽高中的最大值 maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); &#125; &#125; //...&#125; 可以看到与View的onMeasure方法不同的是，FrameLayout的onMeasure方法是遍历它所有的子View，然后逐个测量子View的大小，这个测量子View是通过注释1的measureChildWithMargins方法来完成，这个方法已经在上面子View的MeasureSpec的创建中讲过一点，measureChildWithMargins方法是在FrameLayout的父类ViewGroup中，如下： 123456protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; //省略的这部分在上面已经讲过，主要是创建子View的MeasureSpec（childWidthMeasureSpec, childHeightMeasureSpec） //... //1、调用子View的measure方法，叫子View自己测量自己 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; measureChildWithMargins方法中首先会根据父容器传进来的parenXXMeasureSpec来创建子View的childXXMeasureSpec，然后调用子View的measure方法，把测量子View的任务又推给了子View，这个过程又回到了2.1所讲的View的measure流程，就不再赘述，所有子View测量完后，ViewGroup就可以得出自己的测量宽高。 3、小结measure流程是三大流程中最复杂的一个，它的整体流程是：从ViewRootImp的performTraversals()方法进入performMeasure()方法，开始整颗View树的测量流程，在performMeasure方法里面会调用View的measure方法，然后measure方法会调用onMeasure方法，如果是View就直接开始测量，设置View的宽高，如果是ViewGroup，则在onMeasure方法中则会对所有的子View进行measure过程，如果子View是一个ViewGroup，那么继续向下传递，直到所有的View都已测量完成。如图： measure过后就可以通过getMeasureWidth()或getMeasureHeight()获得View测量的宽高。 View的布局流程 - performLayout()前面讲解了View的measure过程，如果你理解了，那么View的布局过程也很容易理解的，和measure相似，View的布局过程是从ViewRootImpl的performLayout()开始的，如下： 123456789//ViewRootImpl.javaprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; //... final View host = mView; //... //1、调用了顶级View的layout方法 host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); //...&#125; 在performLayout中主要调用了顶级View的layout方法，顶级View的实例有可能是View也有可能是ViewGroup，但是这个layout方法是在View中，它不像measure方法那样，它不是final修饰，所以它可以被重写，并且ViewGroup重写了layout方法，我们先看一下ViewGroup中的layout方法，如下： 1234567891011//ViewGroup.java@Overridepublic final void layout(int l, int t, int r, int b) &#123; if (...) &#123; //... //1、ViewGroup中的重写的layout方法还是调用了父类即View的layout方法 super.layout(l, t, r, b); &#125; else &#123; //... &#125;&#125; 可以看到ViewGroup重写的layout方法只是做了一些判断，然后最终还是还是调用了父类即View的layout方法，所以我们直接看View的layout方法即可。 1、View和ViewGroup的layout流程View的layout方法如下： 123456789101112131415161718192021//View.javapublic void layout(int l, int t, int r, int b) &#123; // 注意传进来的四个参数： // l 表示子View的左边缘相对于父容器的上边缘的距离 // t 表示子View的上边缘相对于父容器的上边缘的距离 // r 表示子View的右边缘相对于父容器的右边缘的距离 // b 表示子View的下边缘相对于父容器的下边缘的距离 //... int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //1、调用setFrame方法设定View的四个顶点的位置 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; //2、调用onlayout方法 onLayout(changed, l, t, r, b); //... &#125; //...&#125; layout方法传进来的l、t、r、b分别代表着View的上下左右四个点的坐标，这个四个点的坐标是相对于它的父容器来说的，这个layout方法主要干了两件事： 1、注释1：调用View的setFrame方法设定View的四个顶点的位置，我们先看View的setFrame()方法，如下： 1234567891011121314//View.javaprotected boolean setFrame(int left, int top, int right, int bottom) &#123; boolean changed = false; if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123; changed = true; //... mLeft = left; mTop = top; mRight = right; mBottom = bottom; //... &#125; return changed;&#125; 可以看到，setFrame方法主要把l、t、r、b分别赋值给mLeft、mTop、mBottom、mRight，即更新View的四个顶点的位置，这个四个顶点一旦确定，那么View在父容器中的位置也就确定了。 2、我们继续看注释2：调用了onLayout方法，这个方法在View中是一个空实现，如下： 123//View.java protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; 但是在ViewGroup中是一个抽象方法，如下： 123//ViewGroup.java@Overrideprotected abstract void onLayout(boolean changed, int l, int t, int r, int b); 这是因为onLayout方法主要用途是给父容器确定子View的位置，所以如果本身就是一个View，就无需实现这个方法，但是如果是ViewGroup，它还要布局子View，所以是ViewGroup的子类就要强制实现这个方法，不同的ViewGroup具有不同的布局方式，所以不同的ViewGroup的onLayout方法的实现就不一样，我们还是以FrameLayout为例，看一下FrameLayout的onLayout方法的实现，如下： 1234//FrameLayout.javaprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125; FrameLayout的onLayout方法只调用了layoutChildren方法，该方法如下： 12345678910111213141516171819202122232425262728293031void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; final int count = getChildCount(); //获取padding值 final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); //遍历所有子View，布局每个子View for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); //如果子View可见 if (child.getVisibility() != GONE) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); //获得measue流程测量出来的子View的宽高 final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); //子View的左边缘位置 int childLeft; //子View的上边缘位置 int childTop; //下面是获取布局方向 //... //下面根据布局方向计算出childLeft和childTop //... //1、根据上面的计算，就算出了一个子View的左边缘位置childLeft和上边缘位置childTop //从而根据childLeft和childTop得出子View的右边缘位置childRight = childLeft + width，下边缘位置childButtom = childTop + height //然后调用子View的layout方法 child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125; &#125; 可以发现layoutChildren里面过程和onMeasure里面的过程很像，只是注释1中调用的是子View的layout方法而不是measure方法，如果这个子View是一个View，那么layout方法里面就可以通过setFrame方法直接确定自身的位置，如果这个子View是一个ViewGroup，除了调用setFrame方法确定自身的位置外，还要重复onLayout方法中确定子View位置的过程，最后一层一层的往下，直到全部都子View的layout完成。 2、小结我们再来看一下layout的整体流程：从ViewRootImp的performTraversals()方法进入performLayout()方法，开始整颗View树的布局流程，在performLayout方法里面会调用layout方法，我们发现，View的布局过程其实也可想测量过程那样分为View的layout流程和ViewGroup的layout流程，对于View来说，执行layout方法时只需要直接确定自身四个顶点的位置即可，而onLayout方法是一个空实现；对于ViewGroup来说，执行layout方法时除了要确定自身的四个顶点的位置外，那么它在onLayout方法中还要对自己所有的子View进行layout，最后一层一层的往下，直到全部都layout完成。如下： layout过后就可以通过View的getWidth()和getHeight()来获取最终的宽高的，这个两个方法的实现如下： 12345678//View.javapublic final int getWidth() &#123; return mRight - mLeft;&#125;public final int getHeight() &#123; return mBottom - mTop;&#125; 可以发现就是通过View的四个顶点的差值来得到View的准确宽高。 View的绘制流程 - performDraw()和上面两步相似，View的绘制从ViewRootImpl的performDraw()开始的，如下： 123456789//ViewRootImpl.javaprivate void performDraw() &#123; //... final boolean fullRedrawNeeded = mFullRedrawNeeded; //... //1、调用ViewRootImpl的draw方法 draw(fullRedrawNeeded); //...&#125; performDraw()方法中并不是先调用View的draw方法，而是先调用ViewRootImpl的draw方法，如下： 12345678910111213141516171819202122//ViewRootImpl.javaprivate void draw(boolean fullRedrawNeeded) &#123; //获取surface绘制表面 Surface surface = mSurface; //... //如果surface表面需要更新 if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123; //判断是否启用硬件加速，即是否使用GPU绘制 if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123; //... //使用GPU绘制 mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this); &#125;else &#123; //... //1、调用drawSoftware方法，使用CPU绘制 if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123; return; &#125; &#125; &#125; //...&#125; 在ViewRootImpl的draw方法中首先获取需要绘制的区域，然后判断是否使用GPU进行绘制，使用硬件加速是为提高了Android系统显示和刷新的速度，是在在API 11之后引入GPU加速的支持，关于这部分知识可自行查阅资料，不是本文重点，这里我们只关心注释1，通常情况下我们使用的是CPU绘制，也就是调用ViewRootImpl的drawSoftware方法来绘制，ViewRootImpl的drawSoftware()方法如下： 1234567891011121314151617181920212223242526272829303132//ViewRootImpl.javaprivate boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; final Canvas canvas; //... try &#123; final int left = dirty.left; final int top = dirty.top; final int right = dirty.right; final int bottom = dirty.bottom; //1、获取指定区域的Canvas对象，即画布，用于绘制 canvas = mSurface.lockCanvas(dirty); //... &#125;//省略catch try &#123; //... try &#123; //... //2、从View树的根节点开始绘制，触发整颗View树的绘制 mView.draw(canvas); &#125; finally &#123; //... &#125; &#125; finally &#123; try &#123; //3、释放Canvas锁，然后通知SurfaceFlinger更新这块区域 surface.unlockCanvasAndPost(canvas); &#125; catch (IllegalArgumentException e) &#123; //... &#125; &#125; return true;&#125; drawSoftware方法中主要做了3件事： 1、获取Surface对象并锁住Canvas绘图对象 2、从View树的根视图开始绘制整颗视图树 3、释放Surface对象并解锁Canvas，通知SurfaceFlinger更新视图 1、View和ViewGroup的draw流程第1和第3点都是操作Surface的基本流程，我们主要看第二点即注释2，调用了View的draw方法，它就是一个模板方法，定义了几个固定的绘制步骤，如下： 1234567891011121314151617181920212223242526272829303132333435//View.javapublic void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ //1、绘制背景 if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; //... //2、保存Canvas图层，为fadin做准备 saveCount = canvas.getSaveCount(); //... //3、 绘制自身内容，setWillNotDraw()可以控制dirtyOpaque这个标志位 if(!dirtyOpaque) onDraw(canvas); //4、如果是ViewGroup，绘制子View dispatchDraw(canvas); //... //5、如果需要的话，绘制View的fading边缘并恢复图层 canvas.drawRect(left, top, right, top + length, p); //... //6、绘制装饰，如滚动条 onDrawForeground(canvas);&#125; 你看那英文注释，它已经替我们把draw方法中的6大步骤写出来了，其中最重要的就是注释3和4，我们分别来介绍一下： onDraw(canvas)：onDraw方法是用来绘制自身内容，如果你的自定义View或ViewGroup需要绘制内容，就要重写这个方法在Canvas上绘制自身内容。 dispatchDraw(canvas)：如果是ViewGroup，除了绘制自身内容外，还需要绘制子View的内容，所以dispatchDraw就是把View的绘制一层一层的传递下去，直到整颗View树绘制完毕，ViewGroup重写了该方法，我们看一下它的主要源码如下： 123456789101112131415161718192021//ViewGroup.java@Overrideprotected void dispatchDraw(Canvas canvas) &#123; final int childrenCount = mChildrenCount; final View[] children = mChildren; //... for (int i = 0; i &lt; childrenCount; i++) &#123; //... //如果子View可见 if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; //调用drawChild方法，见下面 more |= drawChild(canvas, child, drawingTime); &#125; &#125;&#125;//ViewGroup.java protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; //还是调用了View的draw方法 return child.draw(canvas, this, drawingTime); &#125; 可以看到，dispatchDraw方法把绘制子View的任务通过drawChild方法分发给它的子View，如果是一个ViewGroup，又会重复dispatchDraw()过程。 2、onDraw()绘制开关 - setWillNotDraw()1234//View.javapublic void setWillNotDraw(boolean willNotDraw) &#123; setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);&#125; 但是如果你不需要绘制任何内容，你可以通过View的setWillNotDraw(true)方法关闭绘制，在默认情况下，View没有启用这个优化标志位，但是ViewGroup会启用，所以当你的自定义ViewGroup需要通过onDraw来绘制内容时，需要显式的打开这个开关setWillNotDraw(false)，当你的自定义View不需要onDraw来绘制内容时，需要显式的关闭这个开关setWillNotDraw(true)。 3、小结到这里，我们走完了View的绘制过程，我们再来看一下draw的整体流程：从ViewRootImp的performTraversals()方法进入performDraw()方法，开始整颗View树的绘制流程，在performDraw()方法中经过层层调用：ViewRootImpl :: draw() -&gt; ViewRootImpl :: drawSoftware() -&gt; View :: draw()，来到View的draw()方法，它里面定义了View绘制的6大步骤，其中对于View来说，直接调用onDraw()方法绘制自身，对于ViewGroup来说，还要通过dispatchDraw()把绘制子View的流程分发下去，一层层传递，直到所有View都绘制完毕。如图： 总结我们一直讲View的工作原理，但有没有发现ViewRootImpl也出现的很频繁，它虽然不是一个View，但它是连接View和Window之间的纽带，View三大工作流程的起点就是ViewRootImpl的performTraversals()方法，performTraversals()中依此调用了performMeasure() -&gt; performLayout() -&gt; performDraw()，分别对应顶级View的measure、layout和draw流程，然后顶级View的measure流程和layout流程又会分别调用我们熟悉的onMeasure()、onLayout()方法 ，draw流程有点特别，它是通过dispatchDraw()方法来进行draw流程的传递, 而onDraw()方法只是单纯的绘制自身内容，在onMeasure()方法中会对所有child进行measure过程，同理onLayout()方法中会对所有child进行layout过程，dispatchDraw()方法中会对所有child进行draw过程，如此递归直到完成整颗View Hierarchy的遍历。 该过程如图: 有的人说分析源码的阅读，只是追踪方法的调用链，这种过程毫无意义，但是我想说的是，要想更加深入的了解Android的机制，只有源码才能给你答案，在这个阅读过程要加入自己的思考，把它的知识点用自己的语言整理，然后有所收获，我觉得这就是它的意义所在。 参考资料： 《Android开发艺术探索》","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"view","slug":"view","permalink":"http://yoursite.com/tags/view/"}]},{"title":"java面向对象","date":"2019-07-19T04:29:50.000Z","path":"2019/07/19/java面向对象/","text":"前言 上一篇文章java基础本篇文章继续Java知识点的归纳，梳理一下关于面向对象的知识点，涉及到封装、继承、多态，还有接口，类之间的关系。 接口和抽象类1、抽象类抽象类和抽象方法都用abstract关键字进行声明，抽象类不能被实例化，不能直接创建，抽象方法必须放在抽象类中。 123456789101112public abstract class Hero&#123; public abstract void fight();&#125;//子类实现抽象方法，完成实际操作public class Warrior extends Hero&#123; @Override public void fight()&#123;&#125;&#125;//子类继续声明为抽象类public abstract class LongRange extends Hero&#123;&#125; 2、接口接口被认为是一种特殊的抽象类，同样不能使用new实例化，包含常量和待实现的方法，java8以后接口中可以有方法的实现，如下： 123456interface Eat&#123; //... default public void eating()&#123; System.out.println(\"eating\"); &#125;&#125; 3、接口和抽象类的比较 变量 成员方法 构造方法 使用场合 抽象类 无限制 无限制 可以有 强的“is a”关系（是一种） 接口 所有变量必须是public static final 所有方法必须是public abstract 无 弱的“is a”关系（is kind of，是一类） 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低，而且接口可以实现多继承。 面向对象三大特性1、封装尽可能地隐藏对象内部的实现细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。 2、继承继承是一种“is a”关系，父类和子类之间必须存在“is a”关系，父类的私有属性在子类中不能直接访问，例如Cat 和 Animal 就是一种 “is a” 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。 2.1、父类构造和子类构造 构造方法不可继承，使用super关键字调用父类构造 默认会先调用父类构造，再调用子类构造 2.2、子类调用父类信息 使用super关键字 可以调用父类的公有属性和方法 可以调用父类的protected属性和方法 下面一张表给出java中访问权限修饰符的访问范围： 修饰符 在同一类中可访问 在同一包内可访问 在子类内可访问 在不同包可访问 public 可以 可以 可以 可以 protected 可以 可以 可以 – default 可以 可以 – – private 可以 – – – 2.3、方法重写在子类中提供一个对方法的新的实现。 方法重写发生在通过继承而相关的不同类中 方法重写具有相同的方法签名和返回值 子类重写方法时子类方法访问权限大于父类的 子类重写方法时子类抛出的异常类型是父类抛出异常的子类。 @Overiide称为重写标注，用来保证重写的方法和原方法的签名和返回值一致 ps:方法重载：方法重载是指在于同一个类中，一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。 3、多态同一个实体，具有多种形式，多态分为以下两种： 编译时多态：主要指方法的重载 运行时多态：指程序中定义的对象引用所指向的具体类型在运行期间才确定（运行时多态有三个条件：继承，方法重写，向上转型） 例如下面的代码中，子类Warrior继承父类Hero，它重写了父类的fight方法，并且在main函数中父类Hero引用子类Warrior（父类引用指向子类对象称为向上转型），在Hero引用调用fight方法时，会执行实际对象所在类的fight方法，即Warrior类的fight方法，而不是Hero的fight方法。 12345678910111213141516171819public class Hero&#123; public void fight()&#123; System.out.println(\"hero\"); &#125;&#125;public class Warrior extends Hero&#123; @Override public void fight()&#123; System.out.println(\"Warrior\"); &#125;&#125;public static void main(String[] args) &#123; Hero warrior = new Warrior(); warrior.fight();&#125;输出：Warrior 类图了解下面6种关系有助于看懂UML图。 1、泛化关系（Generalization）泛化关系用一条带空心箭头的直线表示，在类图中表示为类的继承关系（“is a”关系），在java中用extends关键字表示，最终代码中，泛化关系表现为继承非抽象类。例如下面ASUS继承自Laptop，ASUS是一台笔记本，ASUS与Laptop之间是泛化关系。 2、实现关系（Realization）实现关系用一条带空心箭头的虚线表示，在类图中表示实现了一个接口（在java中用implements 关键字表示），或继承抽象类，实现了抽象类中的方法。例如下面Laptop实现了IO接口，同时它继承Computer这个抽象类，Laptop是它们的具体实现。 3、聚合关系（Aggregation）聚合关系用一条带空心菱形箭头的直线表示，表示整体是由部分组成的，但是整体和部分之间并不是强依赖的，整体不存在了，部分还是会存在。例如下面表示Staff聚合到Department，或者说部门是由员工组成的，部门不存在了，员工还是会存在的。 4、组合关系 ( Composition )组合关系是用一条带实心菱形箭头的直线表示，和聚合关系不同，组合关系中整体和部分是强依赖的，即整体不存在了部分也不存在，组合关系是一种强依赖的特殊聚合关系。例如下面表示Department组合到Company中，或者说Company是由Department组成的，但是公司不存在了，部门也将不存在。 5、关联关系（Association）关联关系用一条直线表示，表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示.。例如下面学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。 关联关系默认不强调方向，表示对象之间相互知道，如果要特别强调方向，如下图，表示A知道B，但是B不知道A，这又叫DirectedAssociation。 1ps: 在最终代码中，关联对象通常以成员变量的形式存在。 6、依赖关系（Dependency）依赖关系用一条带箭头的虚线表示，与关联关系不同的是，他描述一个对象在运行期间会用到另一个对象的关系，是一种动态关系，并且随着运行时的变化， 依赖关系也可能发生变化。依赖也有方向，但是我们总是应该保持单向依赖，避免双向依赖的产生。例如下面表示A依赖于B，A的一个方法中使用到了B作为参数。 1234ps: 在最终代码中，依赖关系主要表现为：1、A 类是 B 类方法的局部变量；2、A 类是 B 类方法或构造的传入参数；3、A 类向 B 类发送消息，从而影响 B 类发生变化; 箭头的指向为调用关系。 结语本文都是关于面向对象的一些知识，虽然简单，但是也挺繁琐的，积少成多，希望大家阅读过后有所收获。 参考资料： 看懂UML类图和时序图","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}]},{"title":"java线程池","date":"2019-07-19T04:26:00.000Z","path":"2019/07/19/java线程池/","text":"前言 上一篇文章：java线程 当我们需要频繁的创建多个线程时，每次都通过new一个Thread是一种不好的操作，创建一个线程是要消耗资源，频繁的创建会导致性能较差，而且我们还要管理多个线程的状态，管理不好还可能会出现死锁，浪费资源。这时就需要java提供的线程池，它能够有效的管理、调度线程，避免过多资源的消耗，通过线程池的统一调度、管理，使得多线程开发变得更简单。本文讲解一下有关线程池的知识点。 Executor、ExecutorService、Executors、ThreadPoolExecutor之间的关系Executor是一个接口，里面只有一个方法execute(Runnable command)，用来提交任务到线程池执行。ExecutorService继承Executor，同样是一个接口，里面提供了更多的方法用于操作线程池，如Future&lt;?&gt; submit(Runnable task)可以提交有返回值的任务到线程池执行，shutdown()用来关闭线程池。ThreadPoolExecutor是真正的线程池的实现，它实现了上面接口的方法，还提供了一系列参数来配置线程池。Executors是一个工厂类，通过它提供的工厂方法可以创建不同的线程池。 下面一张图说明的它们之间的关系。 ThreadPoolExecutorThreadPoolExecutor是线程池的真正实现，它的构造方法提供了一系列的参数来配置线程池，如下： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 下面对这几个参数进行说明： 1、int corePoolSize线程池中的核心线程数。 线程池启动后默认是空的，只有任务到来时才会创建线程以处理请求，ThreadPoolExecutor的prestartAllCoreThreads()方法可以在线程池启动后立即创建所有的核心线程以等待任务。 还有在默认情况下，核心线程一旦创建后就会在线程池中一直存活，即使它们处于空闲状态，如果设置ThreadPoolExecutor的allowCoreThreadTimeOut(boolean value)方法为true，那么空闲的核心线程在等待新任务到来时就会有超时策略，这个超时时间由keepAliveTime指定，当等待时间超过keepAliveTime后，核心线程就会被终止。 2、int maximumPoolSize线程池所能创建的最大线程数，它与corePoolSize、workQueue共同调整线程池中实际运行的线程数量。 当线程池中的工作线程数小于corePoolSize时，每次来任务的时候都会创建一个新的工作线程。不管工作线程集合中有没有线程是处于空闲状态。 当池中工作线程数大于等于 corePoolSize 的时候，每次任务来的时候都会首先尝试将线程放入队列，而不是直接去创建线程。 如果放入队列失败，说明队列满了，且当线程中线程数小于 maximumPoolSize 的时候，则会创建一个工作线程（非核心线程）来执行这个任务，如果线程池中的线程数大于maximumPoolSize，调用给定的拒绝策略。 如果任务成功放入队列，则看看是否需要开启新的线程来执行任务，只有当当前工作线程数为0的时候才会创建新的线程，因为之前的线程有可能因为都处于空闲状态或因为工作结束等待超时而被移除，否则就从队列中一个个取出任务给空闲的线程执行。 如图，线程池的工作流程如下: 3、 long keepAliveTime非核心线程空闲时的超时时长，超过这个时长，非核心线程就会被回收。 这是一种减少不必要资源消耗的策略，这个参数可以在运行时被改变，我们同样可以将这种策略应用给核心线程，我们可以通过调用 allowCoreThreadTimeout 来实现。 4、TimeUnit unit指定keepAliveTime的单位，可选值有毫秒、秒、分等。 5、 BlockingQueue workQueue线程池中的任务队列，用来保存等待执行任务的阻塞队列。 首先 BlockingQueue 是一个接口，这是一个很特殊的队列，如果 BlockQueue 是空的，从 BlockingQueue 取东西的操作将会被阻断进入等待状态，直到 BlockingQueue 进了东西才会被唤醒。同样，如果 BlockingQueue 是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到 BlockingQueue 里有空间才会被唤醒继续操作。 BlockingQueue 大致有四个实现类，如下： ArrayBlockingQueue：规定大小的基于数据结构的 BlockingQueue，即有界队列，其构造函数必须带一个 int 参数来指明其大小。其所含的对象是以 FIFO(先入先出)顺序排序的。如果队列满了调用给定的拒绝策略。 LinkedBlockingQueue： 大小不定的基于链表结构的 BlockingQueue，既可以有界也可以无界，若其构造函数带一个规定大小的参数，生成的 BlockingQueue 有大小限制，若不带大小参数，所生成的 BlockingQueue 的大小由 Integer.MAX_VALUE 来决定。其所含的对象是以 FIFO(先入先出)顺序排序的。所以如果该队列是无界的，则可以忽略给定的拒绝策略，因为它永远都不会满，同时还可以忽略maximumPoolSize 参数，因为起当核心线程都在忙的时候，新的任务被放在队列上，永远不会有大于 corePoolSize 的线程被创建。 PriorityBlockingQueue：类似于 LinkedBlockQueue，但其所含对象的排序不是 FIFO，而是依据对象的自然排序顺序或者是构造函数的 Comparator 决定的顺序。 SynchronousQueue：特殊的 BlockingQueue，对其的操作必须是放和取交替完成的。因为其特殊的操作，所以如果有一个任务要插入队列，那么它必须要等到另一个移除任务的操作。所以使用该队列会直接把任务提交给线程池，而不会将任务加入队列，如果线程池没有任何可用的线程处理，就调用给定的拒绝策略。 BlockingQueue 的常用方法： add(anObject)：把 anObject 加到 BlockingQueue 里，即如果 BlockingQueue 可以容纳，则返回 true，否则报异常。 offer(anObject)：表示如果可能的话，将 anObject 加到 BlockingQueue 里，即如果 BlockingQueue 可以容纳，则返回 true，否则返回 false。 put(anObject)：把 anObject 加到 BlockingQueue 里，如果 BlockQueue 没有空间，则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续。 take()：取走 BlockingQueue 里排在首位的对象，若 BlockingQueue 为空，阻断进入等待状态直到 Blocking 有新的对象被加入为止。 poll(time)：取走 BlockingQueue 里排在首位的对象，若不能立即取出，则可以等 time 参数规定的时间，取不到时返回 null。 6、ThreadFactory threadFactory线程工厂，让用户可以定制创建线程的过程。 ThreadFactory 是一个接口，它只有一个Thread newThread(Runnable r)方法，如果没有指定threadFactory，默认的 Executors的defaultThreadFactory 将被使用，这个时候创建的线程将都属于同一个线程组，拥有同样的优先级和 daemon 状态。 我们可以扩展配置 ThreadFactory，我们可以配置线程的名字、线程组合 、daemon 状态。如果调用 ThreadFactory的newThread失败，将返回 null，executor 将不会执行任何任务。 7、RejectedExecutionHandler handler当新任务到来时，线程池被关闭或线程数和队列已经达到上限的时候，对新任务采取的处理策略。 RejectedExecutionHandler 同样是一个接口，里面只有一个rejectedExecution(Runnable r, ThreadPoolExecutor executor)方法，下面介绍一下几个默认的实现，都定义在ThreadPoolExecutor中： AbortPolicy：直接抛出 RejectedExecutionException 异常。线程池的默认实现。 CallerRunsPolicy：这个策略将会使用 Caller 线程来执行这个任务，这是一种 feedback 策略，可以降低任务提交的速度。 DiscardPolicy：这个策略将会直接丢弃任务。 DiscardOldestPolicy：这个策略将会把任务队列头部的任务丢弃，然后重新尝试执行，如果还是失败则继续实施策略。这样的结果是最后加入的任务反而更有可能被执行。 线程池的生命周期线程池的生命周期包含3种状态，如下： 1、运行线程池创建后就进入运行状态，这个时候可以向线程池提交任务，可以通过ThreadPoolExecutor的execute()和submit()方法。 execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。 而submit方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get方法来获取返回值，get方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程timeout时间后立即返回，这时候有可能任务没有执行完，当线程池的任务还没有执行完时，会报超时异常。 2、关闭当调用ThreadPoolExecutor的shutdown或shutdownNow方法后，便会进入关闭状态，这时意味线程池不再接受新的任务。这时isShutdown方法返回true。 调用shutdown方法会等待线程执行完毕后再关闭线程池，但是如果调用的是shutdownNow方法，则相当于调用每个线程的interrupt方法。 如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。 3、终止在关闭状态的线程池执行完所有已经提交的任务后，就变为终止状态，这时调用isTerminated方法会返回true。 线程池的分类通过配置ThreadPoolExecutor的构造函数的参数就可以实现不同类形的线程池，它们分别是：FixedThreadPool、CachedThreadPool、ScheduleThreadPool和SingleThreadExecutor。 1、FixedThreadPool顾名思义，就是一种固定线程数量的线程池。前面讲过，创建线程池是通过工厂类来Executors创建的，代码如下： 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 可以看到核心线程数和最大线程数相同，并且没有超时机制，而且任务队列为无界队列。 这说明当线程处于空闲状态时，它们并不会被回收，除非线程池关闭，当有新任务到来时，它能快速的处理这个任务，如果所有的线程都处于工作状态，那么新任务就会被放入等待队列，并且任务队列能容纳无限个任务。 2、CachedThreadPool 与第一种相反，它是一种线程数量不定的线程池。代码如下： 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 它的核心线程数为0，最大线程数为Integer.MAX_VALUE，相当于无限大，这说明线程池中的线程足够多，每个线程的超时时间为60秒，超过60秒空闲的线程就会被回收，它的任务队列是SynchronousQueue，它是一种特殊的队列，每当有任务插入队列，它都会把它直接提交给线程池处理。 所以这个线程池适用于任务并发量比较大的场景，每当有新任务到来，如果没有空闲线程，它都会创建一个线程处理，如果有空闲线程就交给空闲线程处理。 3、ScheduleThreadPool它的核心线程数是固定，但是非核心线程数是不定的线程池。代码如下： 123456789101112public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); &#125; private static final long DEFAULT_KEEPALIVE_MILLIS = 10L; MILLISECONDS(TimeUnit.MILLI_SCALE), 它主要用于执行定时任务和具有固定周期的重复任务，下面演示一下如何使用： 123456789101112131415161718192021ublic class ScheduledThreadPoolDemo &#123; public void doWork()&#123; //创建定时执行的线程池 ScheduledExecutorService executor = Executors.newScheduledThreadPool(3); //参数1是执行的任务，参数2是第一次运行任务延迟的时间，参数3是定视任务的周期，参数4是单位 executor.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"工作线程： \" + Thread.currentThread().getName() + \", 结果：\" + fibc(10)); &#125; &#125;, 1, 2, TimeUnit.SECONDS); &#125; private int fibc(int n)&#123; if(n == 0) return 0; if(n == 1) return 1; return fibc(n - 1) + fibc(n - 2); &#125;&#125; 上面设计了一个定时任务，计算10的斐波那契数，它会延时1秒后开始执行，然后每隔2秒重复执行一次。 使用： 123public static void main(String[] args) throws InterruptedException &#123; new ScheduledThreadPoolDemo().doWork(); &#125; 输出结果： 12345工作线程： pool-1-thread-1, 结果：55工作线程： pool-1-thread-1, 结果：55工作线程： pool-1-thread-2, 结果：55工作线程： pool-1-thread-2, 结果：55... 4、SingleThreadExecutor它是只有一个核心线程的线程池。如下： 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 它相当于大小为一的FixedThreadPool。 因为只有一个线程用来执行任务，所以使得这些任务之间不需要处理线程同步的问题，任务都按顺序的排队执行。 结语有关线程池的知识先介绍到这里了，了解线程池后，才能更好得去运用它。 参考资料： Java并发之线程池","tags":[{"name":"线程池","slug":"线程池","permalink":"http://yoursite.com/tags/线程池/"}]},{"title":"java线程","date":"2019-07-19T04:25:50.000Z","path":"2019/07/19/java线程/","text":"前言在java中，线程非常重要，我们要分清楚进程和线程的区别：进程是指一个内存中运行的应用程序，每个进程都拥有自己的一块独立的内存空间，进程之间的资源不共享；线程是CPU调度的最小单元，一个进程可以有多个线程，线程之间的堆空间是共享的，但栈空间是独立的，java程序的进程至少包含主线程和后台线程(垃圾回收线程)。了解这些知识后，来看下文有关线程的知识。 并发和并行我们先来看一下概念： 并行：指两个或多个事件在同一时刻点发生 并发：指两个或多个事件在同一时间段内发生 对于单核CPU的计算机来说，它是不能并行的处理多个任务，它的每一时刻只能有一个程序执行时间片（时间片是指CPU分配给各个程序的运行时间），故在微观上这些程序只是分时交替的运行，所以在宏观看来在一段时间内有多个程序在同时运行，看起来像是并行运行。 对于多核CPU的计算机来说，它就可以并行的处理多个任务，可以做到多个程序在同一时刻同时运行。 同理对线程也一样，但系统只有一个CPU时，线程会以某种顺序执行，我们把这种情况称为线程调度，所以从宏观角度上看线程是并行运行的，但是从微观角度来看，却是串行运行，即一个线程一个线程的运行。 线程的创建与启动有3种方式使用线程。 方式1：继承Thread类定义一个类继承java.lang.Thread类，重写Thread类中的run方法，如下： 1234567891011public class MyThread extends Thread &#123; public void run() &#123; // ... &#125;&#125;//使用线程public static void main(String[] args) &#123; Thread thread = new MyThread(); thread.start();&#125; 方式2：实现Runnable接口2.1：定义一个类实现Runnable接口实现 Runnable只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用，如下： 123456789101112public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125;//使用线程public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 2.2、使用匿名内部类这种方式只适用于这个线程只使用一次的情况，如下： 12345678910public class MyRunnable implements Runnable &#123;//使用线程public static void main(String[] args) &#123; new Thread(new Runnable()&#123; public void run()&#123; // ... &#125; &#125;).start();&#125; 方式3：实现Callable接口与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装，所以在创建Thread时，要把FutureTask 传进去，如下： 1234567891011121314public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125;//使用线程public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 继承与实现的区别1、继承方式： （1）java中类是单继承的，如果继承了Thread，该类就不能有其他父类了，但是可以实现多个接口 （2）从操作上分析，继承方式更简单，获取线程名字也简单 2、实现方式： （1）java中类可以实现多接口，此时该类还可以继承其他类，并且还可以实现其他接口 （2）从操作上分析，实现方式稍复杂，获取线程名字也比较复杂，得通过Thread.currentThread来获取当前线程得引用 综上所述，实现接口会更好一些。 线程的中断与终止1、interrupt()、isInterrupted()、interrupted()的作用中断就是线程的一个标识位，它表示一个运行中的线程是否被其他线程调用了中断操作，其他线程可以通过调用线程的interrupt()方法对其进行中断操作，线程可以通过调用isInterrupted()方法判断是否被中断，线程也可以通过调用Thread的interrupted()静态方法对当前线程的中断标识位进行复位。 大家不要认为调用了线程的interrupt()方法，该线程就会停止，它只是做了一个标志位，如下： 1234567891011121314151617181920212223public class InterruptThread extends Thread&#123; @Override public void run() &#123; //一个死循环 while (true)&#123; System.out.println(\"InterruptThread正在执行\"); &#125; &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; InterruptThread interruptThread = new InterruptThread(); interruptThread.start(); interruptThread.interrupt();//调用线程的interrupt() System.out.println(\"interruptThread是否被中断，interrupt = \" + interruptThread.isInterrupted());//此时isInterrupted()方法返回true&#125;输出结果：interruptThread是否被中断，interrupt = trueInterruptThread正在执行InterruptThread正在执行InterruptThread正在执行//... 可以看到当你调用了线程的interrupt()方法后，此时调用isInterrupted()方法会返回true，但是该线程还是会继续执行下去。所以怎么样才能终止一个线程的运行呢？ 2、终止线程的运行一个线程正常执行完run方法之后会自动结束，如果在运行过程中发生异常也会提前结束；所以利用这两种情况，我们还可以通过以下三种种方式安全的终止运行中的线程： 2.1、利用中断标志位前面讲到的中断操作就可以用来取消线程任务，如下： 12345678public class InterruptThread extends Thread&#123; @Override public void run() &#123; while (!isInterrupted())&#123;//利用中断标记位 System.out.println(\"InterruptThread正在执行\"); &#125; &#125;&#125; 当不需要运行InterruptThread线程时，通过调用InterruptThread.interrupt()使得isInterrupted()返回true，就可以让线程退出循环，正常执行完毕之后自动结束。 2.2、利用一个boolean变量利用一个boolean变量和上述方法同理，如下： 123456789101112131415public class InterruptThread extends Thread&#123; private volatile boolean isCancel; @Override public void run() &#123; while (!isCancel)&#123;//利用boolean变量 System.out.println(\"InterruptThread正在执行\"); &#125; &#125; public void cancel()&#123; isCancel = true; &#125;&#125; 当不需要运行InterruptThread线程时，通过调用InterruptThread.cancel()使isCancel等于true，就可以让线程退出循环，正常执行完毕之后自动结束，这里要注意boolean变量要用volatile修饰保证内存的可见性。 2.3、响应InterruptedException通过调用一个线程的 interrupt() 来中断该线程时，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程，例如当你调用Thread.sleep()方法时，通常会让你捕获一个InterruptedException异常，如下: 12345678910111213public class InterruptThread extends Thread&#123; @Override public void run() &#123; try&#123; while (true)&#123; Thread.sleep(100);//Thread.sleep会抛出InterruptedException System.out.println(\"InterruptThread正在执行\"); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 当不需要运行InterruptThread线程时，通过调用InterruptThread.interrupt()使得 Thread.sleep() 抛出InterruptedException，就可以让线程退出循环，提前结束。在抛出InterruptedException异常之前，JVM会把中断标识位复位，此时调用线程的isInterrupted()方法将会返回false。 线程的生命周期1、线程的6种状态线程也是有生命周期，也就是存在不同的状态，状态之间相互转换，线程可以处于以下的状态之一： 1.1、NEW(新建状态)使用new创建一个线程对象，但还没有调用线程的start方法，Thread t = new Thread()，此时属于新建状态。 1.2、RUNNABLE(可运行状态)但在新建状态下线程调用了start方法，t.start()，此时进入了可运行状态。可运行状态又分为两种状态： ready(就绪状态)：线程对象调用stat方法后，等待JVM的调度，此时线程并没有运行。 running(运行状态)：线程对象获得JVM调度，此时线程开始运行，如果存在多个CPU，那么允许多个线程并行运行。 线程的start方法只能调用一次，否则报错（IllegalThreadStateException）。 1.3、BLOCKED(阻塞状态)正在运行的线程因为某些原因放弃CPU，暂时停止运行，就会进入阻塞状态，此时JVM不会给该线程分配CPU，直到线程重新进入就绪状态，才有机会转到运行状态，阻塞状态只能先进入就绪状态，不能跳过就绪状态直接进入运行状态。线程进入阻塞状态常见的情况有： 1、当A线程处于运行状态时，试图获取同步锁，却被B线程获取，此时JVM把当前A线程放到对象的锁池(同步队列)中，A线程进入阻塞状态，等待获取对象的同步锁。 2、当线程处于运行状态时，发出了IO请求，此时进入阻塞状态。 1ps: 如果是使用Synchronize关键字，那么尝试获取锁的线程会进入BLOCKED状态；如果是使用java.util.concurrent 类库中的Lock，那么尝试获取锁的线程则会进入WAITING或TIMED WAITING状态，因为java.util.concurrent 类库中的Lock是使用LockSupport来进行同步的。 1.4、WAITING(等待状态)正在运行的线程调用了无参数的wait方法，此时JVM把该线程放入对象的等待池（等待队列）中，此时线程进入等待状态，等待状态的线程只能被其他线程唤醒，否则不会被分配 CPU 时间片。下面是让线程进入等待状态的方法： 进入方法 退出方法 无Timeout参数的Object.wait() Object.notify() / Object.notifyAll() 无Timeout参数的Thread.join() 方法 被调用的线程执行完毕 LockSupport.park() 方法 LockSupport.unpark(Thread) 1.5、TIMED WAITING(计时等待状态)正在运行的线程调用了有参数的wait方法，此时JVM把该线程放入对象的等待池中，此时线程进入计时等待状态，计时等待状态的线程被其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。下面是让线程进入等待状态的方法： 进入方法 退出方法 调用Thread.sleep(int timeout) 方法 时间结束 有Timeout 参数的 Object.wait() 方法 时间结束 / Object.notify() / Object.notifyAll() 有Timeout 参数的 Thread.join() 方法 时间结束 / 被调用的线程执行完毕 LockSupport.parkNanos() 方法 LockSupport.unpark(Thread) LockSupport.parkUntil() 方法 LockSupport.unpark(Thread) 1ps：阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。 1. 6、TREMINATED(终止状态)又称死亡状态，表示线程的终止。线程进入终止状态的情况有： 1、正常执行完run方法，线程正常退出。 2、遇到异常而退出 线程一旦终止了，就不能再次启动，否则报错（IllegalThreadStateException） 2、线程的状态转换图 线程之间的通信如果一个线程从头到尾的执行完一个任务，不需要和其他线程打交道的话，那么就不会存在安全性问题了，由于java内存模式的存在，如下： 每一个java线程都有自己的工作内存，线程之间要想协作完成一个任务，就必须通过主内存来通信，所以这里就涉及到对共享资源的竞争，在主内存中的东西都是线程之间共享，所以这里就必须通过一些手段来让线程之间完成正常通信。主要有以下两种方法： 1、wait() / notify() notifyAll() 机制它们都是Object类中的方法，它们的主要作用如下： wait()：执行该方法的线程对象释放同步锁（这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁），然后JVM把该线程存放在等待池中，等待其他线程唤醒该线程 notify()：执行该方法的线程唤醒在等待池中等待的任意一个线程，把线程转到锁池中等待 notifyAll()：执行该方法的线程唤醒在等待池中等待的所有线程，把线程转到锁池中等待 注意：上述方法只能在同步方法或者同步代码中使用，否则会报IllegalMonitorStateException异常，还有上述方法只能被同步监听锁对象来调用，不能使用其他对象调用，否则会报IllegalMonitorStateException异常。 假设A线程和B线程共同操作一个X对象，A、B线程可以通过X对象的wait方法和notify方法进行通信，流程如下： 1、当A线程执行X对象的同步方法时，A线程持有X对象的锁，则B线程没有执行同步方法的机会，B线程在X对象的锁池中等待。 2、A线程在同步方法中执行X.wait()时，A线程释放X对象的锁，进入X对象的等待池中。 3、在X对象的锁池中等待获取锁的B线程在这时获取X对象的锁，执行X对象的另一个同步方法。 4、B线程在同步方法中执行X.notify()或notifyAll()时，JVM把A线程从X对象的等待池中移到X对象的锁池中，等待获取锁。 5、B线程执行完同步方法，释放锁，A线程获取锁，从上次停下来的地方继续执行同步方法。 下面以一个ATM机存钱取钱的例子说明，ATM机要在银行把钱存进去后，其他人才能取钱，如果没钱取，只能先回家等待，等银行通知你有钱取了，再来取，如果有钱取，就直接取钱。 ATM机，存钱和取钱方法都是同步方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ATM &#123; private int money; private boolean isEmpty = true;//标志ATM是否有钱的状态 /** * 往ATM机中存钱 */ public synchronized void push(int money)&#123; try&#123; //ATM中有钱，等待被人把钱取走 while (!isEmpty)&#123; this.wait(); &#125; //ATM中没钱了，开始存钱 System.out.println(Thread.currentThread().getName() + \":\" + \"发现ATM机没钱了，存钱中...\"); Thread.sleep(2000); this.money = money; System.out.println(Thread.currentThread().getName() + \":\" + \"存钱完毕，存了\" + money + \"元\"); //存钱完毕，把标志置为false isEmpty = false; //ATM中有钱了，通知别人取钱 this.notify(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; /** * 从ATM机中取钱 */ public synchronized void pop()&#123; try &#123; //ATM中没钱取，等待通知 while (isEmpty)&#123; System.out.println(Thread.currentThread().getName() + \":\" + \"ATM机没钱，等待中...\"); this.wait(); &#125; //ATM中有钱了，开始取钱 System.out.println(Thread.currentThread().getName() + \":\" + \"收到通知，取钱中...\"); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + \":\"+ \"取出完毕，取出了\" + this.money + \"钱\"); //取钱完毕，把标志置为true isEmpty = true; //ATM没钱了，通知银行存钱 this.notify(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 银行， 需要传入同一个ATM示例： 12345678910111213141516public class Blank implements Runnable &#123; private ATM mAtm;//共享资源 public Blank(ATM atm)&#123; this.mAtm = atm; &#125; @Override public void run() &#123; //银行来存钱 for(int i = 0; i &lt; 2; i++)&#123; mAtm.push(100); &#125; &#125;&#125; 小明， 需要传入同一个ATM示例： 1234567891011121314public class Person implements Runnable&#123; private ATM mAtm;//共享资源 public Person(ATM atm)&#123; this.mAtm = atm; &#125; @Override public void run() &#123; //这个人来取钱 mAtm.pop(); &#125;&#125; 客户端操作，我特地让小明提前来取钱，此时ATM机中是没钱的，小明要等待： 12345678910111213141516public static void main(String[] args)&#123; //创建一个ATM机 ATM atm = new ATM(); //小明来取钱 Thread tPerson = new Thread(new Person(atm), \"XiaoMing\"); tPerson.start(); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //银行来存钱 Thread tBlank = new Thread(new Blank(atm), \"Blank\"); tBlank.start(); &#125; 输出结果： 1234567XiaoMing:ATM机没钱，等待中...Blank:发现ATM机没钱了，存钱中...Blank:存钱完毕，存了100元XiaoMing:收到通知，取钱中...XiaoMing:取出完毕，取出了100钱Blank:发现ATM机没钱了，存钱中...Blank:存钱完毕，存了100元 可以看到，小明总是在收到ATM的通知后才来取钱，如果通过这个存钱取钱的例子还不了解wait/notify机制的话，可以看看这个修厕所的例子。 1ps: wait() 和 sleep() 的区别是什么，首先wait()是Object的方法，而sleep()是Thread的静态方法，其次调用wait()会释放同步锁，而sleep()不会，最后一点不同的是调用`wait`方法需要先获得锁，而调用`sleep`方法是不需要的。 2、await() / signal() signalAll()机制从java5开始，可以使用Lock机制取代synchronized代码块和synchronized方法，使用java.util.concurrent 类库中提供的Condition 接口的await / signal() signalAll()方法取代Object的wait() / notify() notifyAll() 方法。 下面使用Lock机制和Condition 提供的方法改写上面的那个例子，如下： ATM2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class ATM2 &#123; private int money; private boolean isEmpty = true;//标志ATM是否有钱的状态 private Lock mLock = new ReentrantLock();//新建一个lock private Condition mCondition = mLock.newCondition();//通过lock的newCondition方法获得一个Condition对象 /** * 往ATM机中存钱 */ public void push(int money)&#123; mLock.lock();//获取锁 try&#123; //ATM中有钱，等待被人把钱取走 while (!isEmpty)&#123; mCondition.await(); &#125; //ATM中没钱了，开始存钱 System.out.println(Thread.currentThread().getName() + \":\" + \"发现ATM机没钱了，存钱中...\"); Thread.sleep(2000); this.money = money; System.out.println(Thread.currentThread().getName() + \":\" + \"存钱完毕，存了\" + money + \"元\"); //存钱完毕，把标志置为false isEmpty = false; //ATM中有钱了，通知别人取钱 mCondition.signal(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;finally &#123; mLock.unlock();//释放锁 &#125; &#125; /** * 从ATM机中取钱 */ public void pop()&#123; mLock.lock();//获取锁 try &#123; //ATM中没钱取，等待通知 while (isEmpty)&#123; System.out.println(Thread.currentThread().getName() + \":\" + \"ATM机没钱，等待中...\"); mCondition.await(); &#125; //ATM中有钱了，开始取钱 System.out.println(Thread.currentThread().getName() + \":\" + \"收到通知，取钱中...\"); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + \":\"+ \"取出完毕，取出了\" + this.money + \"钱\"); //取钱完毕，把标志置为true isEmpty = true; //ATM没钱了，通知银行存钱 mCondition.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; mLock.unlock();//释放锁 &#125; &#125;&#125; 可以看到ATM2改写ATM后，把方法的synchronized去掉，因为Lock机制没有同步锁的概念，然后获取lock锁，在finally里释放lock锁，还把原本Object.wait()用Condition.await()代替，原本Object.notify()用Condition.signal()代替。 客户端操作只是把ATM换成ATM2，输出结果和上面的一样，就不在累述。 死锁多线程通信的时候很容易造成死锁，死锁无法解决，只能避免。 1、死锁是什么？当A线程等待获取由B线程持有的锁，而B线程正在等待获取由A线程持有的锁，发生死锁现象，JVM既不检测也不会避免这种情况，所以程序员必须保证不导致死锁。 2、如何避免死锁？1、当多个线程都要访问共享资源A、B、C时，保证每一个线程都按照相同的顺序去访问去访问他们，比如先访问A，接着访问B，最后访问C。 2、不要使用Thread类中过时的方法，因为容易导致死锁，所以被废弃，例如A线程获得对象锁，正在执行一个同步方法，如果B线程调用A线程的suspend()，此时A线程暂停运行，放弃CPU，但是不会放弃锁，所以B就永远不会得到A持有的锁。 3、 Thread类中过时的方法由于线程安全问题，被弃用，如下： void suspend()：暂停当前线程。 void resume()：恢复当前线程。 void stop()：结束当前线程 suspend()方法在调用之后不会释放已经占有的资源(锁)，然后进入睡眠状态，这样很容易导致死锁； stop()方法直接终止线程，不会保证线程资源的正常释放，导致程序处于不确定状态。对于suspend()和 resume()可以用上面提到的等待/通知机制代替，而 stop()方法可以用上面提到的终止线程运行的3种方式代替。 线程的控制操作下面来看一些可以控制线程的操作。 1、线程休眠让执行的线程暂停等待一段时间，进入计时等待状态，使用如下： 123public static void main(String[] args)&#123; Thread.sleep(1000);&#125; 调用sleep()后，当前线程放弃CPU，在指定的时间段内，sleep所在的线程不会获得执行的机会，在此状态下该线程不会释放同步锁。 2、联合线程在线程中调用另一个线程的 join() 方法，会将当前线程置于阻塞状态，等待另一个线程完成后才继续执行，原理就是等待/通知机制，使用如下： 12345678910111213141516171819202122232425public class JoinThread extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"JoinThread执行完毕！\"); &#125;&#125; public static void main(String[] args) throws InterruptedException &#123; JoinThread joinThread = new JoinThread(); joinThread.start(); System.out.println(\"主线程等待...\"); joinThread.join();//主线程等join线程执行完毕后才继续执行 System.out.println(\"主线程执行完毕\"); &#125;输出结果：主线程等待...JoinThread执行完毕！主线程执行完毕 对于以上代码，主线程会等join线程执行完毕后才继续执行，因此最后的结果能保证join线程的输出先于主线程的输出。 3、后台线程顾名思义，在后台运行的线程，其目的是为其他线程提供服务，也称“守护线程”，JVM的垃圾回收线程就是典型的后台线程，通过t.setDaemon(true)把一个线程设置为后台线程，如下： 1234567891011121314151617public class DeamonThread extends Thread &#123; @Override public void run() &#123; System.out.println(getName()); &#125;&#125; public static void main(String[] args) throws InterruptedException &#123; //主线程不是后台线程，是前台线程 DeamonThread deamonThread = new DeamonThread(); deamonThread.setDaemon(true);//设置子线程为后台线程 deamonThread.start(); //通过deamonThread.isDaemon()判断是否是后台线程 System.out.println(deamonThread.isDaemon()); &#125;输出结果：true 后台线程有以下几个特点： 1、若所有的前台线程死亡，后台线程自动死亡，若前台线程没有结束，后台线程是不会结束的。 2、前台线程创建的线程默认是前台线程，可以通过setDaemon(true)设置为后台线程，在后台线程创建的新线程，新线程是后台线程。 注意：t.setDaemon(true)方法必须在start方法前调用，否则会报IllegalMonitorStateException异常 4、线程优先级当线程的时间片用完时就会发生线程调度，而线程优先级就是决定线程需要多或少分配一些CPU时间片的线程属性，在java中，通过一个成员变量priority来控制优先级，在线程构建时可以通过setPriority(int)方法来修改线程的优先级，如下： 123456789101112public class PriorityThread extends Thread&#123; @Override public void run() &#123; super.run(); &#125; &#125;public static void main(String[] args) throws InterruptedException &#123; PriorityThread priorityThread = new PriorityThread(); priorityThread.setPriority(Thread.MAX_PRIORITY);//10 priorityThread.start();&#125; 优先级范围从1到10，默认是5，优先级高的线程分配的时间片数量要多于优先级低的线程。 1ps: 在不同的JVM以及操作系统上，线程优先级规划会有差异，有些操作系统会忽略对线程优先级的设定，所以线程优先级不能作为程序正确性的依赖保证，因为操作系统可以完全不用理会线程优先级的设定 5、线程礼让对静态方法 Thread.yield() 的调用，声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。如下： 1234567public class YieldThread extends Thread &#123; @Override public void run() &#123; System.out.println(\"已经完成重要部分，可以让其他线程获取CPU时间片\"); Thread.yield(); &#125;&#125; 该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。也就是说，就算你执行了这个方法，该线程还是有可能继续运行下去。 6、线程组java.lang.ThreadGroup类表示线程组，可以对一组线程进行集中管理，当用户在创建线程对象时，可以通过构造器指定其所属的线程组：Thread(ThreadGroup group, String name)。 如果A线程创建B线程，如果没有设置B线程的分组，那么B线程加入到A线程的线程组，一旦线程加入某个线程组，该线程就一直存在于该线程组中直到线程死亡，不能在中途修改线程的分组。 当java程序运行时，JVM会创建名为main的线程组，在默认情况下，所以的线程都属于该线程组。 结语限于篇幅，还有ThreadLocal，线程池的知识点没写，就留到下一篇了。","tags":[{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"}]},{"title":"java基础","date":"2019-07-19T04:24:58.000Z","path":"2019/07/19/java基础/","text":"前言万事开头难，准备从零把java相关知识点捡起来，把自己所学的Java知识点归纳，下面是关于java的一些基本知识点。 java代码的运行过程 创建java源程序，扩展名为.java 使用javac命令编译源程序为字节码文件，扩展名为.class 使用java命令运行字节码文件，在不同平台执行数据类型下面用一张表概括： 数据类型 类型说明符 位数 字节 整形 int 32 4 短整型 short 16 2 长整形 long 64 8 字节型 byte 8 1 单精度浮点型 float 32 4 双精度浮点型 double 64 8 布尔类型 boolean 8 1 字符类型 char 16 2 字符串类型 String - - 自定义类型 public class … - - 其中java的数据类型又分为： 基本类型/原始类型（primitive type）：用来保存简单的单个数据，如：int、short、long、byte、float、double、boolean、char共8种。 类类型/引用类型（class type or reference types）：用来保存复杂的组合数据，如String和自定义类型。 1ps: 在java中，char类型实际是一个16位的无符号整数（&lt;=65535）,可以保存中文和转义字符(`\\b`,`\\t`,`\\n`等)。 成员变量和局部变量1234567891011public class 类名&#123; 数据类型 变量1；//成员变量 返回值类型 方法名()&#123; 数据类型 变量2；//局部变量 &#125; &#125; 1、成员变量的作用域在整个类都是可见的。2、局部变量的作用域仅在定义它们的方法中可见。3、成员变量有默认的初始值（数字为0，对象为null）。4、局部变量没有默认的初始值，需要赋初值再使用。5、成员变量和局部变量重名时，局部变量的优先级更高。 字符串1、String类型在java中String是引用类型，它的构造器如下： 除了用以上new的方法创建一个字符串，还可以用以下方式： 12String name1 = \"rain\";String name2 = \"rain\"; 那么用new和用=有什么不同的呢? new出来字符串是一个String对象，它被放在堆中，地址不一样。用=赋值的字符串是从字符串池（String Pool，保存着所有字符串字面量，这些字面量在编译时期就确定）中拿的，如果这个字符串在池中没有，就会先放进池，所以上面两个name1和name2是同一个字符串。 String中常用的方法： String的比较： 获取String的字串的方法： 12345ps: 1、在字符串的比较中`==`是用来比较地址的，String的equals方法才是用来比较两个字符串是否相等 2、字符串的拼接可以使用`+`,这个运算符的底层其实是调用了String的concat方法，返回一个新的字符串3、在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误4、在 Java 8 中，String 内部使用 char 数组存储数据，在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，这些数组在都用final修饰，所以才保证String是不可变的 2、StringBuffer和StringBuilder与String类不同的是，StringBuffer和StringBuilder的对象可以被多次修改，并且不产生新的未使用对象，而String是不可变的。StringBuilder是在JDK5中被提出来的，它和StringBuffer之间最大的不同是StringBuilder的方法都不是线程安全的，而StringBuffer的方法都是线程安全的。 StringBuffer的构造方法（StringBuilder类似）： StringBuffer的常用方法： 3、 思考：分别使用+、StringBuffer和StringBuilder来拼接字符串，各自的效率怎么样？ 包装类包装类就是将java的基本数据类型打包成对象处理，包装类都在java.lang包中，下面用一个表显示： 基本数据类型 包装类 int Interger short Short long Long char Character byte Byte float Float double Double boolean Boolean 它涉及到以下两种操作： 1、装箱(boxing)以double装箱为例：1234double num = 3.14；Double dnum1 = new Double(num);//1Double dnum2 = Double.valueOf(num);//2Double dnum3 = num;//3 注释1、2都是手动装箱，注释3是自动装箱。 2、拆箱(unboxing)同样上述double拆箱为例：12num = dnum1;//1num = dnum2.doubleValue;//2 注释1是自动拆箱，注释2是手动拆箱。 12345ps:1、包装类没有无参构造，所有包装类的实例都是不可变的，一旦创建对象后，它们的内部值就不能再改变。2、每个基本类型包装类都有常量MAX_VALUE和MIN_VALUE。3、每个包装类都会有一个默认大小的缓存池，例如Integer，缓存池默认大小是-128-1273、编译器会在自动装箱过程中会调用 valueOf() 方法，因此多个值相同，且值在缓存池范围内的包装类实例使用自动装箱来创建，那么就会引用相同的对象。 关键字1、final防止扩展和重写。 修饰成员变量：常量（可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量），不可更改（对于基本数据类型，final使数值不能改变，对于引用类型，final使引用不能改变，即不能引用其他对象，但引用本身可以更改） 修饰方法：不可被重写 修饰类：不可被继承 2、static可以通过类名直接访问它修饰的属性，静态属性和方法都是优先于类的实例存在。 修饰变量：称为静态变量（区别于实例变量）、类变量，类的所有实例都共享静态变量，静态变量在内存中只存在一份 修饰方法：称为静态方法，静态方法必须有实现，它不依赖于任何实例，静态方法中只能调用类的静态属性和静态方法，方法中不能有 this 和 super 关键字 修饰语句块：称为静态语句块，在类初始化时运行一次 修饰内部类：称为静态内部类，非静态内部类依赖于外部类的实例，而静态内部类不需要 存在继承的情况下，初始化顺序为： 父类(静态变量、静态语句块) -&gt; 子类（静态变量、静态语句块） -&gt; 父类（实例变量、普通语句块）-&gt; 父类（构造函数）-&gt; 子类（实例变量、普通语句块） -&gt; 子类（构造函数） 关于hashCode（）和equal（）方法hashCode()用来返回hash值，而equal()是用来判断两个对象是否等价，所以： 要比较两个对象是否相等，必须使用equal方法，如果相等，那么调用两个对象的 hashCode 方法必须返回相同的结果 如果两个对象根据 equals方法比较是不相等的，则 hashCode 方法不一定得返回不同的整数 对同一个对象调用多次hashcode方法必须返回相同的hash值 两个不同对象的hashcode可能相等 两个不同hashcode的对象一定不相等 1ps: 在使用hashXX集合添加对象时，集合先调用该对象的equal方法查看当前集合是否有与之相等的对象，如果有，就再调用该对象的hashCode方法返回hash值，看是否与相等的对象的hashCode方法返回的hash值相等，如果相等，就不添加这个对象，否则就添加，因此在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象hash值也相等，不然会导致集合中出现重复的元素。 异常异常就是一种对象(Exception), 表示阻止程序正常执行的错误。异常类的层次结构如下： 1、RuntimeException和Error以及它们的子类都称为免检异常 2、除了免检异常，其他异常都称为必检异常 由于免检异常可能在程序的任何一个地方出现，为了避免过多的使用try-catch块，java语言不强制要求编写代码捕获免检异常，也不要求在方法头显示声明免检异常。 1、常见的异常类型 2、java中的异常处理机制异常处理机制就是可以使程序处理非预期的情景，并继续正常执行，异常处理机制的主要组成如下： try：监控有可能产生异常的语句块 catch：以合理的方式捕获异常 finally：不管有没有异常，一定会执行的语句块（一般用来释放资源），除了遇到System.exit(0)语句 throw：手动引发异常 throws: 指定由方法引发的异常 所以一个异常捕获处理语句可以如下形式： 123456789try&#123; //监控可能产生异常的语句块&#125;catch(Exception1 e)&#123; //捕获异常，处理异常，如打印异常信息，日志纪录&#125;catch(Exception2 e)&#123; //JDK7后简化写法catch(Exception1|Exception2|Exception3|... e)&#125;finally&#123; //不管有无异常，一定会执行的语句，用来释放资源&#125; try块中的代码可能会引发多种类型的异常，当引发异常时，会按照catch的顺序进行匹配异常类型，并执行第一个匹配的catch语句 结语本文简单整理了一下java语言的基本知识点。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"如何获取Android应用和系统信息","date":"2019-07-12T14:36:32.000Z","path":"2019/07/12/如何获取Android应用与系统信息/","text":"前言本主要了解一下Android系统信息的获取，apk应用信息的获取。 本文相关源码在文末给出 Android系统信息的获取有时我们想要获取手机系统的配置信息，通常可以从以下俩方面获取： android.os.Build SystemProperty 1、android.os.Buildandroid.os.Build包含了系统编译时的大量设备，配置信息，它里面的字段含义如下： Build.BOARD; //主板 Build.BRAND; //Android系统指定商 supported_abis = null;//CPU指令集 Build.DEVICE;//设备参数 Build.DISPLAY;//显示屏参数 Build.FINGERPRINT;//唯一编号 Build.SERIAL;//硬件序列号 Build.ID;//修订版本列表 Build.MANUFACTURER;//硬件制造商 Build.MODEL;//版本 Build.HARDWARE;//硬件名 Build.PRODUCT;//手机产品名 Build.TAGS;//描述Build的标签 Build.TYPE;//Builder类型 Build.VERSION.CODENAME;//当前开发号 Build.VERSION.INCREMENTAL;//源码版本控制号 Build.VERSION.RELEASE;//版本字符串 Build.VERSION.SDK_INT;//版本号 Build.HOST;//Host值 Build.USER;//User名 Build.TIME;//编译时间2、SystemPropertySystemProperty包含许多系统，配置属性值和参数，很多与上面通过android.os.Build获取的相同,下面给出常用的信息： System.getProperty(“os.version”);//os 版本 System.getProperty(“os.name”);//os 名称 System.getProperty(“os.arch”);//os 架构 System.getProperty(“user.home”);//Home 属性 System.getProperty(“user.name”);//Name 属性 System.getProperty(“user.dir”);//Dir 属性 System.getProperty(“user.timezone”);//时区 System.getProperty(“path.separator”);//路径分隔符 System.getProperty(“line.separator”);//行分隔符 System.getProperty(“file.separator”);//文件分隔符 System.getProperty(“java.vendor.url”);//java vender URL 属性 System.getProperty(“java.class.path”);//java Class 路径 System.getProperty(“java.class.version”);//java Class 版本 System.getProperty(“java.vendor”);//java Vender 属性 System.getProperty(“java.version”);//java 版本 System.getProperty(“java_home”);//java HOME属性3、实例 通过一个简单的示例查看如何使用（更多细节查看文末源码），如下： 12345678910/* 通过android.os.Build，可以直接获得一些Build提供的系统信息 */String board = Build.BOARD;String brand = Build.BRAND;Log.d(TAG, \"android.os.Build，board：\" + board);Log.d(TAG, \"android.os.Build，brand： \" + brand);/* 通过SystemProperty，要使用System.getProperty(\"XXX\") */String os_version = System.getProperty(\"os.version\");String os_name = System.getProperty(\"os.name\");Log.d(TAG, \"SystemProperty，os_version: \" + os_version);Log.d(TAG, \"SystemProperty, os_name: \" + os_name); 可以看到，获取系统信息还是很简单的。 Apk应用信息的获取Apk应用信息的获取无非分为，apk包信息的获取与应用进程信息的获取。 1、PackageManager通过PackageManager可以获得应用的apk包信息，先看下面一张图： 最里面的框代表了整个Activity的信息，系统提供了ActivityInfo类来进行封装，以此类推。 1.1、下面列举一些常用的系统封装信息下面这些封装信息与PackageManager在同一个包内。 ActivityInfoActivityInfo 封装了在Manifest文件中\\\\和\\\\之间的所有信息，包括name，icon，label，launchmod等 。 ServiceInfo和ActivityInfo类似，它封装了\\\\之间的所有信息 。 ApplicationInfo它封装了\\\\之间的信息，特别的是，Application包含很多Flag，FLAG_SYSTEM表示为系统应用，FLAG_EXTERNAL_STORAGE表示为安装在sd卡上的应用等，通过这些FLAG可以很方便的判断应用类型 。 PackageInfo它用于封装Manifest文件相关节点的信息，包含了所有Activity、Service等信息 。 ResolveInfo这个比较特殊，它封装的是包含\\信息的上一级信息，所以它可以返回ActivityInfo，ServiceInfo等包含的信息，它经常用来帮助我们找到那些包含特定intent条件的信息，如带分享，播放功能的应用。 通过上面的对象，PackageManager 就可以通过调用各种方法来返回不同类型的Bean 1.2、PackageManager常用方法 getPackagerManager: 通过调用这个方法返回一个PackageManager对象 getApplicationInfo: 以ApplicationInfo形式返回指定包名的Application getApplicationIcon：返回指定包名的icon getInstalledApplications： 以ApplicationInfo形式返回安装的应用 getInstalledPackages：以PackageInfo的形式返回安装的应用 queryIntentActivities: 返回指定intent的ResolveInfo对象、Activity集合 queryIntentServices：返回指定intent的ResolveInfo对象、service集合 resolveActivity：返回指定intent的Activity resolveService：返回指定的intentService1.3、实例 下面通过一个例子来了解如何通过PackageManager来选出不同类型的app，判断app类型的依据，就是利用Applicationinfo中的FLAG_SYSTEM来进行判断，如下： 1app.flags &amp; Applicationinfo.FLAG_SYSTEM 如果flags &amp; Applicationinfo.FLAG_SYSTEM ！= 0，则为系统应用 如果flags &amp; Applicationinfo.FLAG_SYSTEM &lt;= 0, 则为第三方应用 如果flags &amp; Applicationinfo.FLAG_EXTERNAL_STORAGE != 0, 则为SD卡上的应用 特殊的，当系统应用经过升级后，也将成为第三方应用：flags &amp; Applicationinfo.FLAG_UPDATED_SYSTEM_APP != 0 首先封装一个Bean保存我所需要的app信息： 12345678910111213141516171819202122232425262728293031323334353637public class PMAppInfo &#123; private String appName;//app名称 private Drawable appIcon;//图标 private String pkgName;//所在包名 public PMAppInfo(String appLabel, Drawable appIcon, String pkgName) &#123; this.appName = appLabel; this.appIcon = appIcon; this.pkgName = pkgName; &#125; public String getAppLabel() &#123; return appName; &#125; public void setAppLabel(String appName) &#123; this.appName = appName; &#125; public Drawable getAppIcon() &#123; return appIcon; &#125; public void setAppIcon(Drawable appIcon) &#123; this.appIcon = appIcon; &#125; public String getPkgName() &#123; return pkgName; &#125; public void setPkgName(String pkgName) &#123; this.pkgName = pkgName; &#125;&#125; 接下来，通过上面所说的方法判断各种类型的app： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private List&lt;PMAppInfo&gt; getAppInfoList(int flag)&#123; pm = this.getPackageManager(); //获取应用信息 List&lt;ApplicationInfo&gt; applicationInfoList = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES); List&lt;PMAppInfo&gt; appInfoList = new ArrayList&lt;&gt;(); //判断应用类型 switch (flag)&#123; case ALL_APP: appInfoList.clear(); for (ApplicationInfo app : applicationInfoList) &#123; appInfoList.add(new PMAppInfo( ((String) app.loadLabel(pm)), app.loadIcon(pm), app.packageName)); &#125; break; case SYSTEM_APP: appInfoList.clear(); for (ApplicationInfo app : applicationInfoList) &#123; if ((app.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) &#123; appInfoList.add(new PMAppInfo( ((String) app.loadLabel(pm)), app.loadIcon(pm), app.packageName)); &#125; &#125; break; case THIRD_APP: appInfoList.clear(); for (ApplicationInfo app : applicationInfoList) &#123; if ((app.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= 0) &#123; appInfoList.add(new PMAppInfo( ((String) app.loadLabel(pm)), app.loadIcon(pm), app.packageName)); &#125; else if ((app.flags &amp; ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) &#123; appInfoList.add(new PMAppInfo( ((String) app.loadLabel(pm)), app.loadIcon(pm), app.packageName)); &#125; &#125; break; case SDCARD_APP: appInfoList.clear(); for (ApplicationInfo app : applicationInfoList) &#123; if ((app.flags &amp; ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) &#123; appInfoList.add(new PMAppInfo( ((String) app.loadLabel(pm)), app.loadIcon(pm), app.packageName)); &#125; &#125; break; default: return null; &#125; return appInfoList; &#125; 运行效果图： 如上图所示，通过点击不同的按钮，在下方显示出不同类型的apk信息。 2、ActivityManager前面使用了PackageManager获得了应用包的信息，PackageMessager重点在于获得应用的包信息，而ActivityManager重点在于获得在运行时的应用程序的进程信息。 2.1、同PackageManager一样， ActivityManager也封装了很多Bean对象下面的封装类都在ActivityManager的类中。 ActivityManager.MemoryInfo它封装了内存信息，MemoryInfo中有几个重要的字段：availMem - 系统可用内存，totalMen - 总内存，threshold - 低内存的阈值，即区分是否是低内存，lowMemory - 是否处于低内存。 Debug.MemoryInfoandroid中还有一个MemoryInfo，它来自Debug.MemoryInfo,前面的MemoryInfo通常用于获取全局的内存使用信息，而它用于统计进程下的内存信息。 RunningAppProcessInfo顾名思义，就是运行间进程信息，储存的字段自然进程相关的信息，processName - 进程名， pid - 进程pid, uid - 进程uid，pkgList - 该进程下所有的包 。 RunningServiceInfoRunningServiceInfo与RunningAppProcessInfo类似，用于封装运行时的服务信息，它包含了进程信息的同时还包含了其他的信息，activeSince - 第一次被激活的时间，方式，foreground - 服务是否在后台运行。 2.2、实例下面同样通过一个例子来使用ActivityManager，先封装一个Bean来保存一个我们需要的字段： 123456789101112131415161718192021222324252627282930313233343536373839404142public class AMProcessInfo &#123; private String uid; private String pid; private String memorySize; private String processName; public AMProcessInfo() &#123; &#125; public String getPid() &#123; return pid; &#125; public void setPid(String pid) &#123; this.pid = pid; &#125; public String getUid() &#123; return uid; &#125; public void setUid(String uid) &#123; this.uid = uid; &#125; public String getMemorySize() &#123; return memorySize; &#125; public void setMemorySize(String memorySize) &#123; this.memorySize = memorySize; &#125; public String getProcessName() &#123; return processName; &#125; public void setProcessName(String processName) &#123; this.processName = processName; &#125;&#125; 通过调用getRunningAppProcesses（）返回当前运行时的进程信息集合：1234567891011121314151617181920212223private List&lt;AMProcessInfo&gt; getRunningProcessesInfo() &#123; amProcessInfoList = new ArrayList&lt;&gt;(); //获取正在运行的进程集合 List&lt;ActivityManager.RunningAppProcessInfo&gt; appProcessList = am.getRunningAppProcesses(); for (int i = 0; i &lt; appProcessList.size(); i++) &#123; ActivityManager.RunningAppProcessInfo info = appProcessList.get(i); int pid = info.pid; int uid = info.uid; String processName = info.processName; //获取该进程下的内存 int[] memoryPid = new int[]&#123;pid&#125;; Debug.MemoryInfo[] memoryInfo = am.getProcessMemoryInfo(memoryPid); int memorySize = memoryInfo[0].getTotalPss(); AMProcessInfo processInfo = new AMProcessInfo(); // processInfo.setPid(\"\" + pid); processInfo.setUid(\"\" + uid); processInfo.setMemorySize(\"\" + memorySize); processInfo.setProcessName(processName); amProcessInfoList.add(processInfo); &#125; return amProcessInfoList; &#125; 运行效果图： 上图运行给出了当前运行的一个进程的pid，uid，占用内存，进程名的信息。 结语PackageManager是用来获取apk包信息的，ActivityManager是用来获取运行时进程信息的，如果想要获取手机系统信息，可以通过SystemProperty和android.os.Build，本文同样是一篇学习记录，希望大家读完后和我一样有所收获。 本文相关源码位置 参考资料： 《android群英传》","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"ActivityManager","slug":"ActivityManager","permalink":"http://yoursite.com/tags/ActivityManager/"},{"name":"PackageManager","slug":"PackageManager","permalink":"http://yoursite.com/tags/PackageManager/"}]},{"title":"SVG入门学习","date":"2019-07-12T09:39:00.000Z","path":"2019/07/12/SVG入门学习/","text":"前言SVG对于android开发者听起来是陌生的东西，因为它是属于前端的产物，其实Android中也是支持SVG的，语法也很简单易懂，本文就通过我自己学习的经历，和大家一起学习一下SVG。 什么是SVG?Google 在Android5.X中增加了对SVG矢量图形的支持，可以用来创建高效率的动画, 所以我们先来了解一下SVG的定义： 可伸缩矢量图形（Scalable Vector Graphics） 使用XML格式定义图形 图像在放大或改变尺寸的情况下图片质量不会有所损失 android中使用vector标签表示SVG 与bitmap相比，SVG最大的优点是放大不会失真，而bitmap需要为不同的分辨率准备很多套图标，而SVG则不需要，前面说了SVG要用vector表示，我们先来看看vector标签中属性的含义。 vector的各个属性是什么意义？12345678910111213141516171819202122232425262728293031323334&lt;vector xmlns:android=\"http://schemas.android.com/apk/res/android\" //命名空间 android:height=\"200dp\" //这个是图片的intrinsic高度 android:width=\"200dp\" //这个是图片的intrinsic宽度 android:viewportHeight=\"100\" //这个是为这个图片设置的纵坐标,表示将图片分为100等份,主要下面的pathData需要依赖这个坐标的划分 android:viewportWidth=\"100\" //同上,只不过这个是横坐标, heigh，width的比例和viewportHeight，viewportWidth的比例必须保持一致，不然图形就会发生形变 android:alpha=\"0.2\" //这个是整个图像的透明度,取值范围0到1 &gt; &lt;group //这个标签中可以放入若干个&lt;path/&gt;标签,并给它们设置一些共同的属性 android:name=\"group_name\" //这个name很有用,在设置objectAnimator的时候用来区分给那个部分施加动画 android:pivotY=\"50\" //这个设置这个group的中心点的X坐标,取值范围为0到100,在做rotation时有用 android:pivotX=\"50\" //这个设置这个group的中心点的Y坐标,取值范围为0到100,在做rotation时有用 android:translateX=\"20\" //将整个group在X轴方向平移多少像素 android:translateY=\"30\" //将整个group在Y轴方向平移多少像素 android:rotation=\"90\" //将整个group以中心点左边旋转的角度,360为一圈 android:scaleX=\"0.5\" //横坐标的缩放比例 , 取值1表示100% android:scaleY=\"0.3\"&gt; //纵坐标的缩放比例,取值0.5表示50%,取值1.5表示150% &lt;path //这个标签是重头戏,矢量图绘制的路径 android:name=\"path_name\" //为这个path标记的名字,在使用objectAnimator的时候用来区分给哪个部分施加动画 android:pathData=\"m 0,0 L50,0 L100,100 L0,100 z\" //这个是SVG的语法,下面讲 android:fillColor=\"@color/red\" //定义填充图形的颜色，如果没有定义则不填充路径 android:fillAlpha=\"1\" //定义填充图形的透明度，取值范围0到1 android:strokeAlpha=\"0.5\" //定义路径的透明度,取值范围0到1 android:strokeColor=\"#ff0000ff\" //定义如何绘制路径，如果没有定义则不显示路径 android:strokeWidth=\"20\" //线段的宽度 android:strokeLineCap=\"butt|round|square\" //线的末端形状,butt严格到指定的坐标就截至,round是圆角,square是方形，到指定的坐标后还会再冒出一点来 android:strokeLineJoin=\"round|bevel|miter\" //线的连接处形状,round是圆角的,bevel和miter貌似看不出来有什么区别.... android:trimPathStart=\"0.5\" //顾名思义,从path开始的地方(0%)去除path,去除到指定的百分比位置,取值范围0到1 android:trimPathEnd=\"0.5\" //顾名思义,从path结束的地方(100%的地方)去除path,去除到指定的百分比位置,取值范围0到1 android:trimPathOffset=\"0.5\" //这个属性是和上面两个属性共同使用的,单独使用没有用,这个属性的意思是,在去除path的时候设置path原点的位置,按百分比设置,取值范围0到1 /&gt; &lt;/group&gt;&lt;/vector&gt; 下面就来重点讲解path标签，path标签是用来创建SVG的，就像用指令控制一只画笔，path标签所支持的指令有以下几种。 path 标签中的绘图指令12345678910M = moveto(M X, Y): 将画笔移动到指定的位置，但未发生绘制L = lineto(L X, Y): 画直线到指定位置H = horizontal(H X): 画水平线到指定X坐标V = vertical lineto(V Y): 画垂直线到指定Y坐标C = curveto(C X1,Y1,X1,Y2,ENDX,ENDY): 画三次贝塞尔曲线S = smooth curveto(S X2,Y2,ENDX,ENDY): 画三次贝塞尔曲线Q = quadratic Belzier curve(Q X,Y,ENDX,ENDY): 二次贝塞尔曲线T = smooth quadratic Belzier curveto(T ENDX,ENDY): 映射前面路径后的终点A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y): 画弧线Z = closepath(): 关闭路径，把前面的路径连起来 在使用以上指令时，需要注意： 坐标轴以（0，0）为中心，X轴水平向右，Y轴水平向下 所有指令大小写均可。大写绝对定位，参考全局坐标系；小写相对定位，参考父容器坐标系 指令和数据间的空格可以省略，可以用逗号隔开，也可以用空格 同一指令出现多次可以只用一个 SVG的指令参数非常复杂，但是在android中，不需要太多太复杂的SVG图形，所以我们先来掌握几个常用的指令，在以后的学习中，读者将会慢慢掌握更多的SVG绘制技巧和方法。 常用指令讲解 M ：类似Android绘图中path类的moveTo方法，即将画笔移动到某一点但并没有发生绘制动作，下面配合L进行讲解 L ：画一条直线 123&lt;path ...省略一些代码 android:pathData=\"M 20 50 L 80 50\"/&gt; 如图： 上面表示把画笔放在（20,50）位置，连直线到80，50点 。 同时L后面还可以跟H或V指令来绘制水平、竖直线，后面的参数是x坐标（H指令）或y坐标（V指令）,如下： 123&lt;path ...省略一些代码 android:pathData=\"M 20 50 L 80 50 V 80 H 20\"/&gt; 如图： A ：绘制一段弧线，且弧线不允许闭合，可以把弧线想象成椭圆的某一段，A指令有以下7个参数： RX，RY 指所在椭圆的半轴大小 XROTATION 指椭圆的X轴与水平方向的顺时针方向夹角，可以想象成一个水平的椭圆绕中心点顺时针旋转XRORATION的额角度 FLAG1 只有俩个值，1表示大角度弧线，0表示小角度弧线 FLAG2 只有俩个值，1为顺时针，0反之 X，Y 为终点坐标 看代码： 12345&lt;path ...省略一些代码 android:pathData=\" M 50 50 a 30 15 0 1 0 1 0\"/&gt; 再看图： 图一 上面表示把画笔放在（50,50）位置；30, 15分别表示椭圆的x，y半轴大小；0表示x轴不旋转；1表示用大角度弧线绘制；0表示顺时针：1，0表示相对与以（50，50）为起始点的坐标轴的坐标，因为a是小写。再看一段代码： 12345&lt;path ...省略一些代码 android:pathData=\" M 25 50 a 25 25 0 1 0 50 0\" /&gt; 再看图： 图二 可以看到这里显示了一个半圆，因为这里的X，Y轴大小相等 。 再看一段代码： 1234&lt;path ...省略一些代码 android:pathData=\"M 25 50 a 25 25 0 1 0 40 0\" /&gt; 再看图： 图三 这里把终点x轴坐标改为40，图中显示了圆的大部分 。 看一段代码： 1234&lt;path ...省略一些代码 android:pathData=\"M 25 50 a 25 25 0 0 0 40 0\" /&gt; 再看图： 图四 这里把FLAG1改为0，与图三相比，发现弧度变小了，因为用小弧度画。 看一段代码： 1234&lt;path ...省略一些代码 android:pathData=\"M 25 50 a 25 25 0 0 1 40 0\" /&gt; 再看图： 图五 这里把FLAG2改为1，与图四相比，图形翻转了，因为画的方向不一样了 , 把A指令的几个图结合看一下，就能弄懂A这个指令了。 关于贝塞尔指令的，这里就不过多介绍了，放出几个链接供大家学习：贝塞尔曲线初探SVG讲解 VectorDrawable和AnimatedVectorDrawableCoogle在Android5.0X中提供了俩个API来帮助支持SVG： VectorDrawable AnimatedVectorDrawable 其中VectorDrawable用于创建XML文件的SVG图形，即前面的vector标签，并结合AnimatedVectorDrawable来完成动画效果。 1、 VectorDrawable在XML中创建一个静态的XMLSVG图形，通常会形成如下的树形结构： 树形结构 path是树形结构中最小的单位，而通过Group可以将不同的path进行组合，接下来我们使用vector标签创建SVG图形，代码如下： 12345678910111213141516171819202122232425&lt;vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:width=\"200dp\" android:height=\"200dp\" android:viewportWidth=\"100\" android:viewportHeight=\"100\"&gt; &lt;group android:name=\"line\"&gt; &lt;path android:name=\"path1\" android:strokeColor=\"@android:color/holo_green_dark\" android:strokeWidth=\"5\" android:strokeLineCap=\"round\" android:pathData=\" M 20 20 L 50 20 80 20\"/&gt; &lt;path android:name=\"path2\" android:strokeLineCap=\"round\" android:strokeWidth=\"5\" android:strokeColor=\"@android:color/holo_green_dark\" android:pathData=\" M 20 80 L 50 80 80 80\"/&gt; &lt;/group&gt;&lt;/vector&gt; 上面的代码画了俩条线，每条线由三个点控制，形成初始状态，下面立马通过AnimatedVectorDrawable来实现动画效果。 源码文末给出 2、 AnimatedVectorDrawableAnimatedVectorDrawable就是通过连接静态的VectorDrawable和动态的objectAninmator来为VectorDrawable提供动画效果，分几个步骤来使用： 1、在XML中通过animated-vector标签来声明对AnimatedVectorDrawable的使用，并指定它的drawable属性，target标签中的name属性和animation属性 代码如下： 123456789&lt;animated-vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:drawable=\"@drawable/svg_path\"&gt; &lt;target android:animation=\"@animator/anim_path1\" android:name=\"path1\"/&gt; &lt;target android:animation=\"@animator/anim_path2\" android:name=\"path2\"/&gt;&lt;/animated-vector&gt; android:drawable=”@drawable/svg_path”指定了上面创建的VectorDrawable即画的俩条线；target标签中的name指定了要作用动画的path或Group的name, 即俩者的name要保持一致，这样系统才能找到要实现动画的元素;taret标签中的animation指定了要作用的都动画。 在本例中，path1的动画代码如下: 123456789101112&lt;objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"500\" android:propertyName=\"pathData\" android:valueType=\"pathType\" android:valueFrom= \"M 20 20 L 50 20 80 20\" android:valueTo= \"M 20 20 L 50 50 80 20\" android:interpolator=\"@android:anim/bounce_interpolator\"&gt;&lt;/objectAnimator&gt; path2的动画代码如下：123456789101112&lt;objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"500\" android:propertyName=\"pathData\" android:valueType=\"pathType\" android:valueFrom= \"M 20 80 L 50 80 80 80\" android:valueTo= \"M 20 80 L 50 50 80 80\" android:interpolator=\"@android:anim/bounce_interpolator\"&gt;&lt;/objectAnimator&gt; 以上的俩个动画代码中都定义了一个pathType的属性动画，并指定了变换的初始值分别为：12345678//path1 android:valueFrom= \"M 20 20 L 50 20 80 20\"//path2 android:valueFrom= \"M 20 80 L 50 80 80 80\" 结束值为:12345678//path1 android:valueTo= \"M 20 20 L 50 50 80 20\"//path2 android:valueTo= \"M 20 80 L 50 50 80 80\" 这里要注意的是，SVG的路径变换属性动画中，变换前后的节点数必须相同，这也是为什么前面需要使用三个点来绘制一条直线，因为后面需要中点进行动画变换 。 2、把AnimatedVectorDrawable的XML文件设置给ImageView 1234&lt;ImageView android:id=\"@+id/iv_path\" android:src=\"@drawable/svg_path_anim\" .../&gt; 3、代码中启动AnimatedVectorDrawable动画 123456789101112ImageView ivPath;...ivPath = findViewById(R.id.iv_path); ivPath.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Drawable drawable = ivPath.getDrawable(); if(drawable instanceof Animatable)&#123; ((Animatable)drawable).start(); &#125; &#125; &#125;); 这样俩个path就实现了动画效果，如图： 结语了解了上面SVG知识，也就基本入门了，可以用SVG来实现简单的图标，当然现在也有一些工具来生成SVG图片，不用我们手动去写xml，但是了解它背后的实现也是很重要的，在以后的深入学习中，你会发现SVG结合动画会产生非常好看的动态效果。希望大家阅读完有所收获。 本文相关源码 参考资料： 《Android群英传》 SVG教程","tags":[{"name":"svg","slug":"svg","permalink":"http://yoursite.com/tags/svg/"}]},{"title":"Activity应用窗口的添加过程","date":"2019-07-10T07:20:32.000Z","path":"2019/07/10/Activity应用窗口的添加过程/","text":"前言 上一篇文章Window, WindowManager和WindowManagerService之间的关系 从上一篇文章中，我们了解到了Window的体系机制，也知道了window分为三种类型，分别是应用窗口(Application Window)、子窗口(Sub Window)、系统窗口(System Window），本文通过源码以Activity为例讲解一下应用窗口的添加过程，如果没看过上一篇文章建议先看，对于不同类型的窗口的添加，它们在WindowManager中的处理过程会有一点不一样，但是对于在WMS的处理过程中，基本上都是一样的。所以本文深入讲解一下Activity窗口的添加过程，知道了这个过程，对于其他类型的窗口添加也就能举一反三了。 本文基于Android8.0, 相关源码位置如下: frameworks/base/core/java/android/view/*.java（*代表Window, WindowManager, WindowManagerImpl，WindowManagerGlobal, ViewRootImpl） frameworks/base/core/java/android/app/*.java（*代表Activity，ActivityThread） frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java frameworks/base/services/core/java/com/android/server/wm/Session.java Activity的Window创建 - Activity :: attach()熟悉Activity的启动流程的都知道(不熟悉的可以查看这篇文章Activity的启动流程)的Window的创建过程是在activity的attach方法中，它在调用Activity的onCreate方法前完成一些重要数据的初始化，如下： 123456789101112131415161718192021222324252627282930313233//Activity.javafinal void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) &#123; //... //1、关注这里，创建PhoneWindow mWindow = new PhoneWindow(this, window, activityConfigCallback); //下面都是设置window的一些属性，如回调、软键盘模式 mWindow.setWindowControllerCallback(this); //这个设置Window的Callback回调 mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; //... //2、关注这里，把Window与WindowManager进行关联 mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); //把WindowManager与Activity进行关联 mWindowManager = mWindow.getWindowManager(); //...&#125; 在attach里。跟Window无关的我都省略掉了，我们看到attach方法里，在注释1中，首先new 了一个PhoneWindow赋值mWinow，mWindow是Window类型，它是一个抽象类，所以从这里可以看出Activity的Window的具体实现类是PhoneWindow，接下来，给mWindow设置回调，传入的参数是this，说明Activity实现了这些回调接口，这样当Window接收到外界的状态变化或输入事件时就会回调Activity的方法，其中我们比较熟悉的接口回调是Window的Callback接口，它里面有我们熟悉的回调方法如：dispatchTouchEvent()、onWindowFocusChanged()、onAttachedToWindow()和onDetachedFromWindow()。 接着我们来看注释2，这里通过Window的setWindowManager方法把WanagerManger与Window进行关联，然后通过Window的getWindowManager()把WanagerManger与Activity进行关联。 Window与WanagerManager的关联 - Window :: setWindowManager()我们知道Window的添加、更新和删除都是要通过WanagerManager的，接下来我们看看Window与WanagerManager是如何关联的，从上面知道该过程是在Window的setWindowManager方法中，如下： 12345678910111213141516//Window.javapublic void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; //token是Window的重要属性之一，是IBinder类型，它这里等于Activity中的mToken mAppToken = appToken; //应用名 mAppName = appName; //是否硬件加速 mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); //获得系统级服务WMS在本地进程的代理 if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; //1、关注这里，调用WindowManagerImpl的createLocalWindowManager方法，创建WindowManager mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); &#125; 在setWindowManager方法中，是有关window的一些属性的赋值，其中mAppToken是Activity中的token，它在Activity启动的过程中从AMS中传递过来的，这里你只要记住Activity应用窗口的token值是Activity中的token值，接下来如果wm为空就获取WMS并转成WindowManager赋值给wm，wm是WindowManager，它是一个接口，它的具体实现类是WindowManagerImpl，所以接下来的注释1中wm转成WindowManagerImpl，并调用WindowManagerImpl的createLocalWindowManager方法，我们来看看WindowManagerImpl的createLocalWindowManager方法，如下： 123456789//WindowManagerImpl.javapublic WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123; return new WindowManagerImpl(mContext, parentWindow);&#125; private WindowManagerImpl(Context context, Window parentWindow) &#123; mContext = context; mParentWindow = parentWindow;&#125; 这个方法很简单，只是简单的返回一个WindowManagerImpl对象，注意它传入了一个parentWindow参数，它是Window类型，说明此时构建的WindowManagerImpl是与具体的Window关联的，至此，在java层上Window就已经与WindowManager建立起联系。 Activity的Window的视图创建 - Window :: setContentView()从上一篇文章我们知道，View是依附在Window上的，在Activity的启动过程中的attach方法里已经完成了Activity的Window的创建和与WindowManager的关联，那么Activity的视图即View是在哪里创建的呢？答案是在我们熟悉的setContentView方法中，我们先来看一张图： 如图所示每一个Activity都有一个顶级View叫做DecorView，一般情况下它会包含一个竖直方向的LinearLayout，在这个LinearLayout中包含两部分(具体情况与Android的版本与主题有关)，上面是标题栏，下面是内容布局，内容布局其实是一个FrameLayout，我们平时setContentView指定的布局其实是set到了这个FrameLayout中，所以这个方法叫setContentView也是也是很贴和实际的，因为FrameLayout的id就是android.R.id.content，理解了这些知识后，我们来看Activity中的setContentView方法，如下： 1234567//Activity.javapublic void setContentView(@LayoutRes int layoutResID) &#123; //1、关注这里，其实调用的是PhoneWindow的setContentView，setContentView里面会加载内容布局并添加进DecorView中 getWindow().setContentView(layoutResID); //如果Activity主题是带ActionBar的话，这里面就会创建ActionBar并添加进DecorView中 initWindowDecorActionBar();&#125; 我们看注释1，前面已经讲过Activity的Window的创建，所以这里的getWindow其实返回的是Window，而Window的实现类是PhoneWindow，所以这里调用的是PhoneWindow的setContentView，并传入了我们的内容布局id，PhoneWindow的setContentView方法的相应源码如下： 12345678910111213141516171819202122232425262728//PhoneWindow.java@Overridepublic void setContentView(int layoutResID) &#123; //1，根据mContentParent是否为空做出不同动作，mContentParent就是上面所讲的id为android.R.id.content的布局，用来set我们id为layoutResID的内容布局 if (mContentParent == null) &#123; //1.1、mContentParent为空，创建DecorView，并加载mContentParent installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; //1.2、mContentParent不为空，并且没有转场动画，就把mContentParent中的View视图清空，下面会重新加载 mContentParent.removeAllViews(); &#125; //2、根据是否有转场动画，做出不同的动作 if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; //2.1、有转场动画，创建Scene完成转场动画 final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID， getContext()); transitionTo(newScene); &#125; else &#123; //2.2、没有转场动画，直接把我们的layoutResID的布局加载进mContentParent mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; //触发Activity的onContentChanged方法, 因为Activity实现了这些回调接口 cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 从注释中可以看出这个方法如果忽略转场动画的处理的话，可以分为两部分，第一部分是注释1.1的DecorView的创建和加载mContentParent，第二部分是注释2.2的把我们的layoutResID的布局加载进mContentParent，其中重点是第一部分，下面我们来分析PhoneWindow的setContentView方法的第一部分。 1、PhoneWindow :: installDecor()我们来看PhoneWindow的installDecor方法，如下： 123456789101112131415161718//PhoneWindow.javaprivate void installDecor() &#123; //... //1、根据mDecor是否为空，做出不同动作，mDecor就是DecorView，它是继承自FrameLayout if (mDecor == null) &#123; //1.1、mDecor为空，就创建mDecor mDecor = generateDecor(-1); //... &#125; else &#123; //1.2、、mDecor不为空，不用重复创建，把Window设置给DecorView mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; //2、如果mContentParent为空，就加载mContentParent mContentParent = generateLayout(mDecor); //... &#125;&#125; installDecor()有一百多行代码，但是重点就是上面几句，因为这里我们是第一次创建mDecor，所以mDecor就为空，那么上面就分为两部分，第一部分是注释1.1的创建mDecor，第二部分是注释2的加载加载mContentParent，我们先看installDecor方法的第一部分。 1.1 PhoneWindow :: generateDecor()PhoneWindow的generateDecor()方法如下： 123456789101112//PhoneWindow.javaprotected DecorView generateDecor(int featureId) &#123; Context context; if (mUseDecorContext) &#123; Context applicationContext = getContext().getApplicationContext(); //... &#125; else &#123; context = getContext(); &#125; //1、关注这里，new了一个DecorView return new DecorView(context, featureId, this, getAttributes());&#125; 可以看到generateDecor就是简单的创建了一个DecorView并返回，其中this是Window实例，DecorView的构造方法中会把Window设置给DecorView中的mWindow。我们看一下DecorView是什么，如下： 1234//DecorView.javapublic class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123; //...&#125; 可以看到DecorView就是一个FrameLayout。 我们回到installDecor方法中，接下来我们来看installDecor方法的第二部分。 1.2 PhoneWindow :: generateLayout(mDecor)PhoneWindow的generateLayout()方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//PhoneWindow.javaprotected ViewGroup generateLayout(DecorView decor) &#123; //这里获取到当前的Activity的主题theme的属性，下面忽略的，都是根据theme的属性设置Activity的Window TypedArray a = getWindowStyle(); //... //这个layoutResource是一个布局id int layoutResource; //获得theme的features int features = getLocalFeatures(); //下面根据features获得不同的layoutResource if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; setCloseOnSwipeEnabled(true); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_title_icons; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; layoutResource = R.layout.screen_progress; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_custom_title; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123; layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); &#125; else &#123; layoutResource = R.layout.screen_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123; layoutResource = R.layout.screen_simple_overlay_action_mode; &#125; else &#123; //1、我们选取这个 R.layout.screen_simple 布局作为例子看一下 layoutResource = R.layout.screen_simple; &#125; mDecor.startChanging(); //2、将上面获取到的layoutResource对应的布局加载进DecorView中 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); // //3、因为layoutResource对应的布局已经加载进DecorView中了，所以这里可以通过findViewById获取android.R.id.content的布局 ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); //... mDecor.finishChanging(); //返回id为android.R.id.content的布局，赋值给mContentParent return contentParent;&#125; generateLayout()这个方法非常长，但是它里面的逻辑很简单，这个方法的主要作用是根据当前的Activity的theme的属性设置Activity的Window，并把根据features获取到的布局加载进传进来的DecorView，并从DecorView中获取android.R.id.content的布局返回给mContentParent，我们只要看懂注释1~3就清楚了。 首先我们看注释1，因为if…else…的语句非常多，所以我就选了最后一个else语句的layoutResource对应的布局文件讲解，它的位置在：/frameworks/base/core/res/res/layout/screen_simple.xml，如下： 12345678910111213141516171819202122&lt;!-- 还记得上面那张图吗，DecorView一般情况下它会包含一个竖直方向的LinearLayout --&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" android:orientation=\"vertical\"&gt; &lt;!-- ViewStub是一个按需加载的View，它在用到时才会加载，而且只能加载一次，这里它的layout指向的是一个ActionBar的布局文件，所以这里把ViewStub看作一个ActionBar就行 --&gt; &lt;ViewStub android:id=\"@+id/action_mode_bar_stub\" android:inflatedId=\"@+id/action_mode_bar\" android:layout=\"@layout/action_mode_bar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"?attr/actionBarTheme\" /&gt; &lt;!-- 这个就是id为android.R.id.content得布局，用来放置我们平时setContentView时set得内存布局 --&gt; &lt;FrameLayout android:id=\"@android:id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:foregroundInsidePadding=\"false\" android:foregroundGravity=\"fill_horizontal|top\" android:foreground=\"?android:attr/windowContentOverlay\" /&gt;&lt;/LinearLayout&gt; screen_simple.xml文件就是一个布局文件，大家把这个布局对应一下上面得那张图，就会有一种恍然大悟得感觉了，所以我们紧接着来看注释2，它就是把上面这个screen_simple.xml布局文件加载进DecorView中。 我们再看注释3，ID_ANDROID_CONTENT就是android.R.id.content的常量，看一下findViewById方法的源码，如下： 123456//PhoneWindow.java @Nullable public &lt;T extends View&gt; T findViewById(@IdRes int id) &#123; //getDecorView()就是获得到Window中的DecorView return getDecorView().findViewById(id); &#125; 可以看到findViewById方法中获取到DecorView，然后调用DecorView的findViewById方法，因为在注释2中我们已经把layoutResource对应的布局加载进DecorView中了，所以这时就获取到android.R.id.content的布局。在generateLayout方法的最后，把android.R.id.content的布局返回给mContentParent。 我们再回到installDecor方法中，至此我们已经创建好DecorView，也通过DecorView获取到mContentParent, 即android.R.id.content的布局。 我们来分析PhoneWindow的setContentView方法的第二部分。 2、mLayoutInflater.inflate(layoutResID, mContentParent)layoutResID就是我们setContentView传进来的内容布局id，所以这里就把内容布局加载进mContentParent中了。至此Window的setContentView分析完毕。 这个过程如下图： 我们回到Activity的setContentView方法，其实到这里Activity的视图，也可以是说Activity的Window的视图DecorView就创建好了，接下来就是把这个DecorView显示到屏幕上。 Activity的Window的视图添加 - WindowManager :: addView()熟悉Activity的启动流程的都知道，Activity会在handleResumeActivity方法中把DecorView显示出来，而添加一个Winow是通过WindowManager的addView方法实现的，但是Window只是View的载体，并不是真实存在的，所以addView其实就是添加一个View，这个View是依附在Window上，并且这个View是 View Hierarchy 最顶端的根 View，而Activity的的顶级View是DecorView, 所以添加Activity的Window就是添加DecorView。我们来看一下handleResumeActivity方法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//ActivityThread.javafinal void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; //ActivityClientRecord里面保存了Activity的信息 ActivityClientRecord r = mActivities.get(token); //... //这个方法里面最终会回调Activity的onResume方法 r = performResumeActivity(token, clearHide, reason); //所以下面都是在执行onResume方法后的行为 if (r != null) &#123; //得到Activity final Activity a = r.activity; //... //面if（r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible）&#123;&#125;分支里面的逻辑主要是把Activity的Window的DecorView添加到WMS中 if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //获取前面Activit创建的Window r.window = r.activity.getWindow(); //获取前面Window创建的DecorView View decor = r.window.getDecorView(); //先把DecorView设为不可见 decor.setVisibility(View.INVISIBLE); //Activity关联的WindowManager ViewManager wm = a.getWindowManager(); //下面设置Window的布局参数 WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; //窗口的类型是TYPE_BASE_APPLICATION，应用类型窗口 l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; //... if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; //1、关注这里，调用WindowManager的addView方法 wm.addView(decor, l); &#125; else &#123; //... &#125; &#125; &#125;else if (!willBeVisible) &#123; //... &#125; //... //面if（r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible）&#123;&#125;分支里面的逻辑主要是把DecorView显示出来 if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; //... if (r.activity.mVisibleFromClient) &#123; //2、关注这里，上面已经把Window添加到WMS中了，所以里面会把DecorView显示出来, 见下面Activity.java r.activity.makeVisible(); &#125; &#125; //... &#125; //...&#125;//Activity.javavoid makeVisible() &#123; //... //把DecorView设为可见 mDecor.setVisibility(View.VISIBLE);&#125; 上面的注释已经写的很清楚了，重点就是一句话：获取Activity的Window中的DecorView并调用WindowManager的addView方法添加DecorView，然后把DecorView设置为可见。到这里视图的添加已经转移到WindowManager中，阅读过上一篇文章的知道，WindowManager的实现类是WindowManagerImp，WindowManagerImp会把大部分操作转发给WindowManagerGlobal。 1、WindowManagerGlobal :: addView()所以我们直接看方法WindowManagerGlobal的addView()就行，如下： 123456789101112131415161718192021222324252627282930313233343536//WindowManagerGlobal.javapublic void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; //... //获取Window的LayoutParams final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; //这里的parentWindow不为空，因为从上面的Window与WanagerManager的关联可知，会调用createLocalWindowManager(this)来创建一个WanagerManagerImpl，这个this代表的PhoneWindow实例会传进WanagerManagerImpl构造中赋值给mParentWindow //1、调整窗口布局参数 if (parentWindow != null) &#123; //如果有设置父窗口，会通过adjustLayoutParamsForSubWindow()来调整params parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; //... &#125; ViewRootImpl root; synchronized (mLock) &#123; //... //2、构建ViewRootimpl root = new ViewRootImpl(view.getContext(), display); //3、把View、ViewRootimpl、LayoutParams保存 //把上面调整好的params设置给待添加的View view.setLayoutParams(wparams); //把待添加的View添加到View列表中 mViews.add(view); //把ViewRootimpl对象root添加到ViewRootimpl列表中 mRoots.add(root); //把params添加到params列表中 mParams.add(wparams); try &#123; //4、调用ViewRootImpl的setView将View显示到手机窗口上 root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; //... &#125; &#125;&#125; 上述方法主要分为4个部分，我们先来看WindowManagerGlobal的addView传进来的4个参数，其中view、params和display三者是必不可少的，view就代表待添加的View，这里是DecorView，params就代表窗口布局参数，diaplay代表的是表示要输出的显示设备，而parentWindow表示父窗口，这里的父窗口并不一定是真正意义上的父窗口，有可能就是描述一个窗口的对象本身。在上述分析Activity的 WindowManager创建时就提到parentWindow就是PhoneWindow本身。 1.1、adjustLayoutParamsForSubWindow(wparams)接下来我们来看这个方法，这个方法被分为4部分，其中第一部分是注释1，重点是Window的adjustLayoutParamsForSubWindow方法，用来调整params，该方法主要源码如下： 12345678910111213141516171819202122//Window.javavoid adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp) &#123; //... if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;//如果它是子窗口 if (wp.token == null) &#123; View decor = peekDecorView(); if (decor != null) &#123; //可以看到子窗口的token为顶级View的WindowToken wp.token = decor.getWindowToken(); &#125; &#125; //... &#125; else if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW &amp;&amp; wp.type &lt;= WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123;//如果它是系统窗口 //系统窗口没有为token赋值，因为系统窗口的生命周期不依赖于app，当app退出了，系统窗口不会受到影响，它还是能显示和接收外界的输入事件 //... &#125; else &#123;//如果它是应用窗口 if (wp.token == null) &#123; //可以看到应用窗口的token为Activity的mAppToken wp.token = mContainer == null ? mAppToken : mContainer.mAppToken; &#125; //...&#125; 这个方法主要是为Window的token赋值，如果是应用窗口且wp.token==null，就会给它赋值mAppToken，而这个mAppToken就是我们上面在Activity的attach()方法中传入的mToken，而系统窗口的token为null，原因注释中说了，我们再分析子窗口的token，接上面的decor.getWindowToken()，该方法如下: 1234//View.javapublic IBinder getWindowToken() &#123; return mAttachInfo != null ? mAttachInfo.mWindowToken : null;&#125; 可以看到子窗口的token就是View中mAttachInfo的mWindowToken，那么mAttachInfo是什么？它在哪里被赋值？我们先留一个疑问。 1.2、创建ViewRootImpl我们回到addView()方法继续看注释2，注释2构建了一个ViewRootimpl，WindowManagerGlobal会为每一个待添加的View创建一个ViewRootImpl，我们看ViewRootImpl的构造方法，如下： 1234567891011121314151617181920212223242526//ViewRootImpl.javapublic ViewRootImpl(Context context, Display display) &#123; mContext = context; //1、记住这个mWindowSession，待会用到 mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; //... //2、创建了一个W对象，继承自IWindow.Stub，是一个IBinder类型，用来接收WMS的通知 mWindow = new W(this); //... //3、创建了一个mAttachInfo，这个mAttachInfo就是上面View中mAttachInfo，它在这里被创建，见下面View.AttachInfo的构造方法 mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this, context); //...&#125;//View.java AttachInfo(IWindowSession session, IWindow window, Display display, ViewRootImpl viewRootImpl, Handler handler, Callbacks effectPlayer) &#123; mSession = session; mWindow = window; //mWindowToken本质就是ViewRootImpl中的W类，只是调用asBinder转化了一下 mWindowToken = window.asBinder(); mDisplay = display; mViewRootImpl = viewRootImpl; //... &#125; ViewRootImpl的构造方法中，关键的就是上面三个注释，注释1下面会解释，注释2创建了一个W类对象，它是一个IBinder类型，它在后面会通过Binder IPC传送到WMS中，WMS就是通过这个W类对象和Activity所在进程交互，注释3创建了一个AttachInfo类对象，ViewRootImpl为每一个待添加的View创建一个AttachInfo类对象mAttachInfo，当这个待添加的View与ViewRootImpl建立联系(mView被赋值)后，ViewRootImpl就会调用performTraversal()方法遍历这颗View Hierarchy 把其mAttachInfo赋值给这颗View Hierarchy 中的每一个View的mAttachInfo，所以上面的decor.getWindowToken()中的mAttachInfo就不为空，这样子窗口的token就是mAttachInfo中的mWindowToken，从AttachInfo构造可以看出，传入的W类通过asBinder转化了一下赋值给mWindowToken，所以现在可以得出结论：子窗口的token就是ViewRootImpl中的W类。 1.3、 把View、ViewRootimpl、LayoutParams保存到列表我们回到addView()方法继续看注释3，第三部分就是把待添加的View、新创建ViewRootimpl、待添加的View的LayoutParams分别保存到3个列表，这三个列表在WindowManagerGlobal中，这三个列表的含义如下： 1234567//WindowManagerGlobal.javapublic final class WindowManagerGlobal &#123; private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();//mViews存储的是所有Window所对应的顶级View（即View Hierarchy最顶端的View） private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();//mRoots存储着所有Window所对应的ViewRootImpl private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;();//mParams存储着所有Window所对应的布局参数 //...&#125; 1.4、通过ViewRootImpl 的setView()方法把DecorView显示到窗口上我们回到addView()方法继续看注释4，注释4就是调用ViewRootImpl的setView方法，它里面会请求View Hierarchy的绘制，并请求WMS显示待添加的View，我们看一下该方法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; //ViewRootImpl与待添加的View建立联系 mView = view; //... //接收WMS添加后的返回结果 int res； //1、请求绘制View Hierarchy requestLayout(); //... try &#123; //... //2、向通过mWindowSession向WMS发起显示当前Window的请求 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; catch (RemoteException e) &#123; //... &#125; //下面这些异常都是由于添加Window错误而抛出 if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123; //... switch (res) &#123; case WindowManagerGlobal.ADD_BAD_APP_TOKEN: case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN: throw new WindowManager.BadTokenException( \"Unable to add window -- token \" + attrs.token + \" is not valid; is your activity running?\"); case WindowManagerGlobal.ADD_NOT_APP_TOKEN: throw new WindowManager.BadTokenException( \"Unable to add window -- token \" + attrs.token + \" is not for an application\"); //... &#125; //... &#125; &#125;&#125; 在setView方法中，我们先看注释1，在向WMS发起将View显示到手机窗口上前，先调用requestLayout绘制整颗View Hierarchy，这个方法里面会通过Choreographer的postCallback方法注册对应的绘制回调(CALLBACK_TRAVERSAL)，等待vsync信号，然后会触发整个View树的绘制操作，也就是performTraversal()方法的执行。我们来看注释2，到这里Activity的Window的添加就交给了mWindowSession，它是一个IWindowSession类型，IWindowSession是一个AIDL接口文件，需要编译后才生成IWindowSession.java接口，mWindowSession是在上面的ViewRootImpl的构造中被赋值的：mWindowSession = WindowManagerGlobal.getWindowSession();，关于这部分的已经在上一篇文章讲解过了，所以注释2其实最终调用的Session的addToDisplay()方法，在addToDisplay()中返回了WMS的addWindow()的返回结果,所以从这里开始添加Window的过程转移到WMS进程中去。 2、WMS :: addWindow()我们就简单的过一遍WMS的addWindow()方法，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; int[] appOp = new int[1]; //如果窗口时系统窗口，还要进行权限检查 int res = mPolicy.checkAddPermission(attrs, appOp); if (res != WindowManagerGlobal.ADD_OKAY) &#123; return res; &#125; //... final int type = attrs.type; synchronized(mWindowMap) &#123; //省略的是检查Display显示信息, //... //如果是子窗口 if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123; //通过windowForClientLocked()方法还要检查其父窗口是否存在 parentWindow = windowForClientLocked(null, attrs.token, false); //如果父窗口不存在，返回错误 if (parentWindow == null) &#123; //... return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN; &#125; //如果父窗口还是子窗口，返回错误 if (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123; //... return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN; &#125; &#125; //... //检查token AppWindowToken atoken = null; ////是否有父窗口 final boolean hasParent = parentWindow != null; //如果它有父窗口，就使用父窗口的token，如果没有，就是使用自己的token WindowToken token = displayContent.getWindowToken( hasParent ? parentWindow.mAttrs.token : attrs.token); //如果它有父窗口，就使用父窗口的type，如果没有，就是使用自己的type final int rootType = hasParent ? parentWindow.mAttrs.type : type; if (token == null) &#123; if (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;//如果是应用窗口，但是它的token为空，返回错误 //... return WindowManagerGlobal.ADD_BAD_APP_TOKEN; &#125; //... &#125; else if (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;//如果是应用窗口，但是它的token不是mAppToken（mApptoken是从AMS传过来的），返回错误 atoken = token.asAppWindowToken(); if (atoken == null) &#123; //... return WindowManagerGlobal.ADD_NOT_APP_TOKEN; &#125; else if (atoken.removed) &#123; //... return WindowManagerGlobal.ADD_APP_EXITING; &#125; &#125; //这里省略的是，一些系统窗口的token 不能为空，并且通过token检索到的WindowToken的类型不能是其本身对应的类型 //... else if (token.asAppWindowToken() != null) &#123; //某些系统窗口的token应该为空，但是却不为空，所以这里把token清空 attrs.token = null; token = new WindowToken(this, client.asBinder(), type, false, displayContent, session.mCanAddInternalSystemWindow); &#125; //... //经过一系列的检查后，会创建一个WindowState final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], seq, attrs, viewVisibility, session.mUid, session.mCanAddInternalSystemWindow); //... //走到这里证明没有任何错误发生，res = ADD_OKAY res = WindowManagerGlobal.ADD_OKAY; //... //WindowState的attach方法创建了一个SurfaceSession对象用于与SurfaceFlinger服务通信 win.attach(); //client就是Activity进程那边传过来的ViewRootImpl中的W类，这里用asBinder转化了一下，所以这里以W类为Key，WindowState为Value建立映射存放进mWindowMap中，它是一个WindowHashMap类型 mWindowMap.put(client.asBinder(), win); &#125;&#125; 这个方法很长，但是里面的逻辑还是很有规律，建议对照着注释跟源码看一遍，这里总结一下这个方法的过程： 1、首先如果是系统窗口要进行权限检查，mPolicy是一个PolicyWindowManager类型，如果想知道哪些系统窗口是需要权限的可以查看这个PolicyWindowManager的checkAddPermission()方法，这个方法检查如果不是系统类型的窗口就会返回一个ADD_OKAY表示检查通过，否则表示检查不通过，代表着这个系统窗口没有在Manifest.xml文件中声明权限。 2、如果是子窗口类型，就通过windowForClientLocked()方法还要检查其父窗口是否存在，子窗口一定要有父窗口。 3、根据类型type检查token是否有效，应用窗口和子窗口的token是一定要赋值的，否则创建窗口会抛异常，且应用窗口中的token必须是某个有效的 Activity 的 mToken。而子窗口中的token必须是父窗口的 ViewRootImpl 中的 W 对象。对于部分系统窗口其token也要赋值，有些系统窗口的token不需要赋值。这个token赋值规则可以对照上面的adjustLayoutParamsForSubWindow(wparams)的方法解说。 4、通过WindowState的attach方法，WMS把渲染Window视图的任务交给了SurfaceFlinger。 5、一系列的检查后，WMS会为每一个Window会创建一个WindowState，并以传过来的W类为Key，新创建的WindowState为Value建立映射存放进WindowHashMap中，这个WindowState维护着窗口的状态以及根据适当的机制来调整窗口的状态。 这个添加过程如下图： 总结以上就是Activity的Window的添加过程，我们发现添加一个Window最重要的是View、type和token，至于其他类型窗口的添加相似的，一图总结本文，如下： 从图中可以看到，添加一个Window，会涉及到两个进程的交互，一个是Activity所在的应用进程，一个是WMS所在的系统服务进程，所以绿色的那部分就代表着IPC，ViewRootImpl通过WindonManagerGlobal的静态变量sWindowSession负责与WMS通信，它是Session类型，在ViewRootImpl构造中被赋值，WMS中的每个Window的WindowState的mClient负责与Activity所在的应用进程通信，它是W类型，在创建WindowState构造中被赋值，在Activity所在的应用进程的WindonManagerGlobal中会为每一个添加的Window中的View创建一个ViewRootImpl，所以多个Window就对应多个ViewRootImpl，而在WMS中，Window对应着一个View，它会为每一个Window创建一个WindowState以维护Window的状态，所以多个Window就多个WindowState。 从应用窗口的添加过程中，对Window的机制也有了一些了解，以后如果遇到有关于Window的添加的异常也懂得去哪里找原因。 参考资料： Android Window 机制探索 浅析 Android 的窗口","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"window","slug":"window","permalink":"http://yoursite.com/tags/window/"},{"name":"windowManager","slug":"windowManager","permalink":"http://yoursite.com/tags/windowManager/"},{"name":"WMS","slug":"WMS","permalink":"http://yoursite.com/tags/WMS/"},{"name":"activity","slug":"activity","permalink":"http://yoursite.com/tags/activity/"}]},{"title":"Activity的启动流程（2）","date":"2019-05-19T08:12:34.000Z","path":"2019/05/19/Activity的启动流程（2）/","text":"前言 上一篇文章Activity的启动流程（1） 上一篇文章讲了应用进程请求AMS启动Activity过程和Activity在AMS中的启动过程，然后Activity启动的代码逻辑就从AMS所在进程，又重新回到了应用进程所在的ApplicationThread中。我们还留下了一个问题，Activity的生命周期方法是如何被回调的？，下面我们就带着这个疑问，去走一遍源码，看一下在应用进程中ApplicationThread启动Activity的过程。 本文基于android8.0，本文相关源码文件位置如下： frameworks/base/core/java/android/app/Activity.java frameworks/base/core/java/android/app/ActivityThread.java frameworks/base/core/java/android/app/Instrumentation.java ApplicationThread::scheduleLaunchActivity()上文结尾讲到在ActivityStackSupervisor的realStartActivityLocked()中调用了ApplicationThread中的scheduleLaunchActivity方法，这里是Activity启动的开始。ApplicationThread是ActivityThread的内部类，实现了IApplicationThread.stub接口。ActivityThread代表应用程序进程的主线程，它管理着当前应用程序进程的线程。 我们来看一下scheduleLaunchActivity的相关源码： 123456789101112131415161718192021222324252627282930313233//ActivityThread::ApplicationThreadpublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 上述方法中只是简单的把从AMS传过来的有关启动Activity的参数，封装成ActivityClientRecord，然后调用sendMessage向H发送LAUNCH_ACTIVITY的消息，并且将ActivityClientRecord作为参数传了过去，H是ActivityThread中的内部类，是Handler类型，有关Activity的启动消息都交给这个Handler处理，为什么这里要进行切换到主线程处理消息呢？因为此时这里还运行在Binder的线程池中，不能进行Activity的启动，所以要切换到主线程中才能进行Activity的生命周期的方法回调。 下面我们来看看sendMessage方法。 1、ApplicationThread::sendMessage()该方法如下： 1234567891011121314151617//ActivityThread::ApplicationThreadprivate void sendMessage(int what, Object obj) &#123; sendMessage(what, obj, 0, 0, false);&#125; private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; //... Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg); &#125; 可以看到，sendMessage方法中将H.LAUNCH_ACTIVITY与ActivityClientRecord封装成一个Message，然后调用mH的sendMessage方法，mH就是H的实例，如下： 1final H mH = new H(); 熟悉android消息机制的都知道(不了解的，可以看这一篇文章Android消息机制java层)，Handler发送消息后，都会统一到handlerMessage方法中处理。 我们来看一下Handler H对消息的处理。 2、H::handleMessage（）如下： 123456789101112131415161718192021//ActivityThread.javaprivate class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int RESUME_ACTIVITY = 107; public static final int DESTROY_ACTIVITY = 109; public static final int BIND_APPLICATION = 110; //... public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); &#125; break; //... &#125; &#125;&#125; H中有很多关于四大组件的消息处理的字段，如Activity的启动，这里我们只关心前面发送过来的LAUNCH_ACTIVITY字段的消息处理，可以看到这里首先把msg中的obj字段转换为ActivityClientRecord，然后为ActivityClientRecord的packageInfo赋值，packageInfo是LoadedApk类型，它表示已加载的APK文件，接下来调用了外部类ActivityThread的handleLaunchActivity方法。 接下来我们来看一下ActivityThread的handleLaunchActivity方法。 ActivityThread::handleLaunchActivity（）该方法源码如下： 1234567891011121314151617181920212223242526//ActivityThread.javaprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; //... //最终回调Activity的onConfigurationChanged方法 handleConfigurationChanged(null, null); //这里面获取WindowManager系统服务的本地代理 WindowManagerGlobal.initialize(); //1、关注这里，启动Activity，调用了ActivityThread的performLaunchActivity方法，会最终回调Activity的onCreate，onStart方法 Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; //... //2、关注这里，调用了ActivityThread的handleResumeActivity方法，会最终回调Activity的onResume方法 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); //... &#125;else &#123; //如果出错了，这里会告诉AMS停止启动Activity try &#123; ActivityManager.getService() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125;&#125; 本文的重点是Activity的生命周期如何被回调，所以上面我们只需要关注注释1、2。注释1中调用了ActivityThread的performLaunchActivity方法，该方法最终完成了Activity对象的创建和启动过程，如果启动出错就会通知AMS停止启动Activity，并且在注释2中ActivityThread通过handleResumeActivity将被启动的Activity置为Resume状态。 我们首先看注释1的performLaunchActivity方法。 1、ActivityThread::performLaunchActivity()该方法相关源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//ActivityThread.javaprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //从ActivityClientRecord中获取ActivityInfo。 ActivityInfo aInfo = r.activityInfo; //获取packageInfo，packageInfo是前面讲到的LoadedApk类型 if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; //获取ComponentName ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //创建要启动Activity的上下文环境 ContextImpl appContext = createBaseContextForActivity(r); //构造Activity对象，并设置参数 Activity activity = null; try &#123; //获取类加载器 java.lang.ClassLoader cl = appContext.getClassLoader(); //通过Instrumentation，用类加载创建该Activity实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); //设置相关参数准备初始化Activity r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; //初始化Activity失败 //.... &#125; try &#123; //创建Application Application app = r.packageInfo.makeApplication(false, mInstrumentation); //... if (activity != null) &#123; //构造Configuration对象 Configuration config = new Configuration(mCompatConfiguration); //... //把该Activity和ContextImpl关联 appContext.setOuterContext(activity); //通过attach方法将上述创建的信息保持到Activity内部，用来完成对Activity的初始化，如ContextImpl，Application，Configuration activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); //... //获取Activity的主题并设置 int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //1、根据是否需要持久化，调用Instrumentation的callActivityOnCreate方法通知Activity已经被创建，里面最终会调用Activity的onCreate方法 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; //关注这里，走这个分支 mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; //... //无法调用Activity的onCreate方法，抛出异常 &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; //2、里面最终会调用Activity的onStart方法 activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; //根据是否需要持久化，调用Instrumentation的callActivityOnRestoreInstanceState方法通知Activity已经被创建，里面最终会调用Activity的onRestoreInstanceState方法 if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; //... &#125; r.paused = true; //把ActivityClientRecord缓存起来，以便在以后使用。mActivities的定义：ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new ArrayMap&lt;&gt;(); mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; //... &#125; catch (Exception e) &#123; //... //抛异常，无法启动Activity &#125; return activity;&#125; 该方法的主要代码都贴出来了，并做了注释，它主要做了以下事情： 1、从ActivityClientRecord中获取待启动的Activity的组件信息，如ActivityInfo，ComponentName。 ActivityInfo类用于存储代码中AndroidManifes设置的activity节点信息，ComponentName类中保存了该Activity的包名和类名 2、通过createBaseContextForActivity方法创建要启动Activity的上下文环境ContextImp，并在下面作为参数传进attach方法中。 ContextImp是Context的具体实现，Context中的大部分逻辑都是交给ContextImpl来完成，Context中定义了许多与四大组件启动、系统级服务获取、类加载、资源获取等有密切关系的方法，而Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，ContextWrapper继承自Context，ContextWrapper内部有一个Context类型的mBase引用，而在Activity的attach方法中会调用attachBaseContext方法把该ContextImp赋值给mBase，所以Activity是ContextImpl的包装类，Activity扩展了Context中的方法。（这里就是一个装饰者模式） 3、通过LoadedApk的makeApplication方法创建Application。 makeApplication方法里面最终是通过Instrumentation的newApplication方法用类加载器创建Application，如果Application已经被创建过了，那么就不会重复创建，如果创建成功，会紧接着通过Instrumentation的callApplicationOnCreate来调用Application的onCreate方法。 4、通过Instrumentation的newActivity方法用类加载器创建Activity对象。 Instrumentation是一个用来监控应用程序与系统交互的类，通过它可以创建Activity、Applicationd实例，还与Activity生命周期的回调有关，所以在下文看到mInstrumentation.callActivityOnXX, 一般都是要回调某个Activity的生命周期方法。 5、通过Activity的attach方法来完成一些重要数据的初始化，如ContextImpl，Application，Configuration等。 在attach方法中会创建Window对象（PhoneWindow）并与Activity自身进行关联，这样当Window接收到外部的输入事件后就可以将事件传递给Activity。第2点讲过，还会把ContextImpl与Activity关联。 6、调用Instrumentation的callActivityOnCreate方法，里面最终会调用Activity的onCreate方法。 这里就是重点关注的注释1，注释还写到这里会根据是否需要持久化来调用不同参数的mInstrumentation的callActivityOnCreate方法，这个持久化是什么？其实这是在API 21后，Activity新增的一个”persistableMode“属性，在AndroidManifest.xml的activity节点将他它设为android:persistableMode=”persistAcrossReboots，Activity就有了持久化的能力，这时候我们可以数据保存在outPersistentState（Bundle类型），那么即使是关机，仍然可以恢复这些数据。关于PersistableMode更多信息可以看这篇文章PersistableMode使Activity数据持久化保存，这不是本文的重点。 所以一般情况下我们没有使用这个属性，就会走到else分支，调用 mInstrumentation.callActivityOnCreate(activity, r.state)方法。 1.1、Instrumentation::callActivityOnCreate()该方法源码如下： 1234567 //Instrumentation.javapublic void callActivityOnCreate(Activity activity, Bundle icicle) &#123; prePerformCreate(activity); //1、关注这里，调用了Activity的performCreate方法 activity.performCreate(icicle); postPerformCreate(activity); &#125; 我们看注释1，调用了activity的performCreate方法，见名知意。 1.1.1、Activity::performCreate()该方法源码如下： 12345678//Activity.java final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; restoreHasCurrentPermissionRequest(icicle); //1、看到我们的主角吧！onCreate方法 onCreate(icicle, persistentState); mActivityTransitionState.readState(icicle); performCreateCommon(); &#125; 看注释1，调用了我们熟悉的onCreate方法，我们平时一般在这里面进行Activity的控件、资源等初始化操作。 下面继续回到ActivityThread的performLaunchActivity方法，接着上面的第6点。 7、调用Activity的performStart方法，里面最终会调用Activity的onStart方法。 这里也就是重点关注的注释2，下面看一下performStart方法。 1.2、Activity::performStart()我们继续点进去看一下： 123456789101112//Activity.javafinal void performStart() &#123; //... mCalled = false; //1、关注这里，调用了Instrumentation的callActivityOnStart方法 mInstrumentation.callActivityOnStart(this); if (!mCalled) &#123; //... //无法调用Activity的onStart方法，抛出异常 &#125; //...&#125; 看注释1，该方法还是一样的套路，调用 mInstrumentation.callActivityOnStart方法，我们看一下 Instrumentation的callActivityOnStart方法： 1.2.1、Instrumentation::callActivityOnStart()该方法如下： 12345//Instrumentation.javapublic void callActivityOnStart(Activity activity) &#123; //看到我们的主角吧！onStart方法 activity.onStart(); &#125; 很简单的一句代码，调用了我们熟悉的onStart方法。 继续回到我们的ActivityThread的performLaunchActivity方法，还有一点没分析完，接下来到了根据需要调用Instrumentation的callActivityOnRestoreInstanceState方法，里面最终会调用Activity的onRestoreInstanceState方法，关于这个方法的作用已经不是本文的重点，但我们可以得出一个结论，onRestoreInstanceState方法的调用时机是在onStart方法之后。最后ActivityThread把ActivityClientRecord缓存起来。 分析完这个长长的方法，其实跟本文有关也就第6、7点。我们跳出ActivityThread::performLaunchActivity方法，回到ActivityThread的handleLaunchActivity方法。现在我们的Activity已经回调了onCreate和onStart方法，接下来应该是onResume方法。 下面我们我们接着来看handleLaunchActivity方法中注释2的handleResumeActivity方法。 2、ActivityThread::handleResumeActivity()该方法源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//ActivityThread.javafinal void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; //从缓存中拿出ActivityClientRecord ActivityClientRecord r = mActivities.get(token); //... //1、主要关注这里，调用了performResumeActivity方法，这里最终会调用Activity的onResume方法 r = performResumeActivity(token, clearHide, reason); //2、下面if（r ！= null）&#123;&#125;分支里面的逻辑都是把Activity显示出来 if (r != null) &#123; //拿到Activity final Activity a = r.activity; //... boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityManager.getService().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //得到Activity关联的Window r.window = r.activity.getWindow(); //得到Activity的DecorView，即Activity的顶级View View decor = r.window.getDecorView(); //先把DecorView设为不可见 decor.setVisibility(View.INVISIBLE); //得到ViewManager，用于添加DecorView ViewManager wm = a.getWindowManager(); //得到布局参加 WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; //下面设置布局参数 l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; //... if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; //用ViewManager添加DecorView wm.addView(decor, l); &#125; //... &#125; &#125; //... //此时用于承载DecorView的Window已经被WM添加了，但是还处于INVISIBLE状态,所以下面就把它值为VISIBLE if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; //... if (r.activity.mVisibleFromClient) &#123; //把Activity显示出来 r.activity.makeVisible(); &#125; &#125; &#125;else &#123; //... //Activity不能够Resume，通知AMS结束掉该Activity &#125;&#125; handleResumeActivity方法里面的代码也有点长，这个方法主要是把Activity置为Resume状态，并把Activity显示出来，所以我们只关注注释1，注释2是把Activity值为VISIBLE状态，大家要明白的是Activity其实也可以说是一个View，它的顶级View叫做DecorView，但系统回调完Activity的onResume函数时，只是说明Activity1已经完成所有的资源准备工作，Activity已经做好显示给用户的准备，所以还要通过类似于setVisible的方式把它显示出来，这个过程涉及到WindowManage的相关知识，为什么要这样做？大家可以看这篇文章Window,WindowManager和WindowManagerService之间的关系了解一下，所以注释2不是本文重点就不讲了。 下面我们来看注释1的performResumeActivity方法。 2.1 ActivityThread::performResumeActivity()该方法主要源码如下： 123456789101112131415161718192021222324252627//ActivityThread.javapublic final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide, String reason) &#123; //从缓存中拿到ActivityClientRecord ActivityClientRecord r = mActivities.get(token); if (r != null &amp;&amp; !r.activity.mFinished) &#123; if (clearHide) &#123; r.hideForNow = false; r.activity.mStartedActivity = false; &#125; //... try &#123; //... //1、主要关注这里，调用了Activity的performResume方法 r.activity.performResume(); //... r.paused = false; r.stopped = false; r.state = null; r.persistentState = null; &#125;catch(Exception e) &#123; //... //抛异常，无法resume Activity &#125; &#125; return r;&#125; 主要关注注释1，调用了Activity的performResume，和上面的performCreate，performStart很相似。 下面我们来看Activity的performResume方法。 2.1.1 Activity::performResume()该方法主要源码如下： 12345678910111213//Activity.javafinal void performResume() &#123; //这里处理Activity生命周期中的Restart流程 performRestart(); //... mCalled = false; //1、关注这里，调用Instrumentation的callActivityOnResume方法 mInstrumentation.callActivityOnResume(this); if (!mCalled) &#123; //... //抛异常，无法调用Activity的onResume方法 &#125;&#125; 在这个方法中我们看到了 performRestart()方法，这个是根据情况处理Restart流程，里面会执行onReStart() -&gt; onStart() ，到这里就执行onResume()， 所以我们看到注释1会Instrumentation的callActivityOnResume方法，这个和上面的callActivityOnCreate()、callActivityOnStart（）类似。 本着执着的态度，我们还是看一下Instrumentation的callActivityOnResume方法。 2.1.2、Instrumentation::callActivityOnResume()1234567 //Instrumentation.javapublic void callActivityOnResume(Activity activity) &#123; activity.mResumed = true; //又看到了我们的主角之一，onResume方法 activity.onResume(); //...&#125; 该方法先把Activity的mResumed 赋值为true，然后回调了我们熟悉的onResume方法。 我们跳出ActivityThread的handleResumeActivity方法，回到handleLaunchActivity方法，至此handleLaunchActivity方法分析完，Activity已经显示到用户面前。 总结到目前为止我们已经回调了Activity的三个生命周期方法：onCreate -&gt; onStart -&gt; onResume，onRestart也介绍了一下，可以说开头那个问题已经解解决了一半，我先来看一下本文的时序图： 所以现在我们知道了在应用进程中ApplicationThread启动Activity的过程。 那么还有三个方法：onPause -&gt; onStop -&gt; onDestory 什么时候被回调呢？大家都知道Activity有7个生命周期方法，除去onRestart，其他3个都是一 一对应的，结合前面那篇文章Activity的启动流程（1）我们知道： 1、在AMS中含有ApplicatiThread的本地代理，所以AMS所在进程可以通过这个代理与ActivityThread的主线程通信，也就能调用ApplicatiThread的一些方法。 2、在应用进程中也含有系统服务AMS的本地代理对象，所以应用进程可以通过这个代理与AMS通信，可以请求AMS启动一个Activity。 3、双方都含有双方的代理，通过Binder，也就建立起双方的通信通道。 每个应用都有自己专属Activity任务栈，Activity任务栈的管理是在AMS那边，在本文的情况下，一个Activity已经被启动了，该Activity被加入到栈顶中去，如果此时我按back键返回上一个Activity，那么该Activity就会调用相应的回调onPause -&gt; onStop -&gt; onDestory方法，这个过程在AMS那边对应一个出栈动作，此时AMS也就像启动Activity调用scheduleLaunchActivity方法那样调用ApplicationThread中schedulePauseActivity、scheduleStopActivity、scheduleDestroyActivity方法来结束掉这个Activity，这个调用过程是IPC，所以大家通过本文举一反三也就明白了Activity的其他生命周期是如何被回调的，这个过程离不开与AMS的交互。 至此我们已经走完startActivity后发生的流程。在这整个过程中也发现了自己平常很多遗落的知识点，让我更进一步的认识了Activity。希望大家也有所收获。 参考资料： Activity生命周期回调是如何被回调的 Android8.0 根Activity启动过程（后篇） 《Android源码分析与实战》","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"activity","slug":"activity","permalink":"http://yoursite.com/tags/activity/"}]},{"title":"Activity的启动流程（1）","date":"2019-05-19T08:11:17.000Z","path":"2019/05/19/Activity的启动流程（1）/","text":"前言Activity的启动流程有俩种过程，一种是根Activity的启动过程，即在Launch界面点击一个应用图标启动应用程序，根Activity指的是应用程序启动的第一个Activity；另一种是普通Activity的启动流程，即我们平时调用startActivity方法来启动一个Activity。本文讨论第二种，startActivity方法大家都知道是用来启动一个Activity的，那么大家有没有想过它在底层是怎么启动的呢？Activity的生命周期方法是如何被回调的？它启动过程中涉及到多少个进程？接下来我们通过撸一篇源码来了解Activity的大概启动流程，然后解答这几个问题。 本文源码基于Android8.0，本文涉及的源码文件位置如下： frameworks/base/core/java/android/app/Activity.java frameworks/base/services/core/java/com/android/server/am/*.java(*代表ActivityManagerService，ActivityStack，ActivityStarter，ActivityStackSupervisor，ActivityStack) Activity::startActivity()startActivity有好几种重载方法，如下： 1234567891011121314151617181920@Override public void startActivity(Intent intent) &#123; this.startActivity(intent, null); &#125;@Override public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; //我们一般没有传options参数给startActivity，所以options为空，就会走到这个分支 //第二参数requestCode为-1，表示不需要知道Activity启动的结果 startActivityForResult(intent, -1); &#125; &#125; //发现两个参数的startActivityForResult方法最终还是调用三个参数的startActivityForResult方法，options参数传入null public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) &#123; startActivityForResult(intent, requestCode, null); &#125; 可以发现startActivity最终都会调用到startActivityForResult方法。 1、Activity::startActivityForResult()这里我们来到了具有三个参数的startActivityForResult方法，如下： 12345678910111213141516171819//Activity.javapublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; //mParent一直为空 if (mParent == null) &#123; //... //1、关注这里，调用Instrumentation的execStartActivity方法 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); //... //此时requestCode为-1 if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; //... &#125; else &#123; //... &#125; 在上面的的代码中，会进入mParent==null的这个分支里，mParent是Activity类型，它只会在LocalActivityManger构造中被赋值，在我们startActivity过程中一直为空（关于为甚么mParent一直为空，可以查看这篇文章StartActivity路上的mParent）。这里我们只关注注释1，调用Instrumentation的execStartActivity方法，Instrumentation是一个用来监控应用程序与系统交互的类，我们还要注意传入execStartActivity方法的两个参数： 1、mMainThread.getApplicationThread()：ApplicationThread类型，mMainThread是ActivityThread类型，它是应用程序的入口类，而mMainThread.getApplicationThread()就是获得一个ApplicationThread，它是ActivityThread的内部类，它实现了IApplicationThread.Stub，如下： 1234//ActivityThread.java::ApplicationThreadprivate class ApplicationThread extends IApplicationThread.Stub &#123; //...&#125; IApplicationThread.java类是在编译时由IApplicationThread.aidl通过AIDL工具自动生成的，IApplicationThread的内部会自动生成一个 IApplicationThread.Stub类，它继承自Binder类，而Binder实现了IBinder接口，并且 IApplicationThread.Stub实现了IActivityManager接口。要想进行进程间通信，ApplicationThread只需要继承IApplicationThread.Stub类并实现相应的方法就可以，这样主线程ActivityThread就可以通过ApplicationThread就能对外提供远程服务。要记住这个ApplicationThread，他在Activity的启动过程中发挥重要作用。 2、mToken： 它的类型为IBinder，代表着当前Activity的token，它保存自己所处Activity的ActivityRecord信息 2、Instrumentation::execStartActivity()我们继续看Instrumentation的execStartActivity方法，如下： 1234567891011121314151617181920//Instrumentation.javapublic ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; //还记得上面提到的ApplicationThread吗，这里把它转成了IApplicationThread，并在下面作为startActivity方法的参数 IApplicationThread whoThread = (IApplicationThread) contextThread; //... try &#123; //... //1、关注这里，这里实际调用的是ActivityManagerService的startActivity方法 int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //检查启动Activity的结果，无法正确启动一个Activiy时，这个方法抛出异常 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; 我们看注释1，ActivityManager.getService()返回的是ActivityManagerService（下面简称AMS）在应用进程的本地代理，该方法在ActivityManager中，如下： 12345678910111213141516171819//ActivityManager.javapublic static IActivityManager getService() &#123; //IActivityManagerSingleton是Singleton类型，Singleton是一个单例的封装类 //第一次调用它的get方法时它会通过create方法来初始化AMS这个Binder对象，在后续调用中返回之前创建的对象 return IActivityManagerSingleton.get();&#125; private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; //ServiceManager是服务大管家，这里通过getService获取到了IBinder类型的AMS引用 final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); //这通过asInterface方法把IBinder类型的AMS引用转换成AMS在应用进程的本地代理 final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 上面出现的IActivityManager.java类的意义类似于前面提到的ApplicationThread.java。要想进行进程间通信，AMS只需要继承IActivityManager.Stub类并实现相应的方法就可以，这样AMS就能对外提供远程服务，如下： 1234//ActivityManagerService.javapublic class ActivityManagerService extends IActivityManager.Stub&#123; //...&#125; 所以继续回到Instrumentation的execStartActivity方法中，ActivityManager.getService()返回的是AMS的本地代理，注意AMS是在系统进程SystemServer中，所以注释1这里通过Binder的IPC，调用的其实是AMS的startActivity方法。 在这里开始，Activity的启动过程从应用进程转移到AMS中去。 AMS::startActivity()AMS的startActivity方法如下： 123456//AMS.java public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId()); &#125; 简单的return了startActivityAsUser方法，该方法在最后多了个 UserHandle.getCallingUserId()参数，AMS根据这个确定调用者权限。我们再来看看其他参数： caller：IApplicationThread类型，还记得上面提到的ApplicationThread吗？到这里它已经被转成了ApplicationThread的本地代理，这个转换的过程发生在上面讲到的Binder的IPC中，就像上面提到的AMS本地代理转换一样。 callingPackage：前面一直传过来的，代表调用者Activity所在的包名 intent：前面startActivity时传递过来的intent resolvedType：从上面传过来，intent.resolveTypeIfNeeded() resultTo：IBinder类型，还记得上面提到的mToken吗？就是从上面一直传过来的，保存着的调用者Activity的ActivityRecord信息 resultWho：String类型，调用者Activity的mEmbeddedID，前面一直传过来的 requestCode：从上面一直传过来的，一直为-1 startFlags：从上面传过来，为0 profilerInfo：ProfilerInfo类型，从上面传过来，等于null bOptions：Bundle类型，从上面传过来，等于null 下面继续看AMS的startActivityAsUser方法。 1、AMS::startActivityAsUser()startActivityAsUser方法如下： 12345678//AMS.java public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; //... return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null, \"startActivityAsUser\"); &#125; 省略了两个判断，1、判断调用者进程是否被隔离，2、判断调用者是否有权限，这些都不是重点。下面继续简单的return了mActivityStarter.startActivityMayWait方法，mActivityStarter是ActivityStarter类型，它是AMS中加载Activity的控制类，会收集所有的逻辑来决定如何将Intent和Flags转换为Activity，并将Activity和Task以及Stack相关联。传入startActivityMayWait方法的参数又多了几个，看一下几个： callingUid：第二个参数，等于-1 inTask：倒数第二个参数，TaskRecord类型，代表要启动的Activity所在的栈，这里为null，表示还没创建 reason：倒数第一个参数，值为”startActivityAsUser”，代表启动的理由 其他的参数有一些传入null，有一些是从上面传过来的 下面看ActivityStarter中的startActivityMayWait方法。 2、ActivityStarter::startActivityMayWait()来看看这个方法的源码，如下： 12345678910111213141516171819//ActivityStarter.javafinal int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask, String reason) &#123; //... //把上面传进来的intent再构造一个新的Intent对象，这样即便intent被修改也不受影响 intent = new Intent(intent); //... ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId); if(rInfo == null)&#123; //... &#125; //解析这个intent，收集intent指向的Activity信息 ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); //... final ActivityRecord[] outRecord = new ActivityRecord[1]; //1、主要关注这里，调用了本身的startActivityLocked方法 int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask, reason); //... return res;&#125; ActivityInfo里面收集了要启动的Activity信息（关于ResolveInfo与ActivityInfo可以看这篇如何获取Android应用与系统信息），主要还是关注注释1，这里又调用了ActivityStarter中的startActivityLocked方法。传入startActivityLocked方法的参数又多了几个（callingPid等）。关于pid于与uid的介绍可以看这篇文章Android手机中UID、PID作用及区别。 下面来看一下startActivityLocked方法。 2.1、ActivityStarter::startActivityLocked()该方法的相关源码如下： 123456789101112131415161718192021//ActivityStarter.javaint startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask, String reason) &#123; //这里对上面传进来值为\"startActivityAsUser\"理由参数判空 if (TextUtils.isEmpty(reason)) &#123; throw new IllegalArgumentException(\"Need to specify a reason.\"); &#125; mLastStartReason = reason; mLastStartActivityTimeMs = System.currentTimeMillis(); mLastStartActivityRecord[0] = null; //1、主要关注这里，调用了本身的startActivity方法 mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord, container, inTask); if (outActivity != null) &#123; outActivity[0] = mLastStartActivityRecord[0]; &#125; return mLastStartActivityResult; &#125; 这里主要关注注释1，调用了ActivityStarter中的startActivity方法，该方法多了一个参数，最后一个mLastStartActivityRecord，mLastStartActivityRecord是一个ActivityRecord数组类型，ActivityRecord是用来保存一个Activity的所有信息的类。 下面来看ActivityStarter中的startActivity方法。 2.2、ActivityStarter::startActivity()123456789101112131415161718192021222324252627282930313233343536373839 //ActivityStarter.javaprivate int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; //... //获取调用者所在进程记录的对象，caller就是上面一直强调的代表调用者进程的ApplicationThread对象 ProcessRecord callerApp = null; if (caller != null) &#123; //这里调用AMS的getRecordForAppLocked方法获得代表调用者进程的callerApp callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) &#123; //获取调用者进程的pid与uid并赋值 callingPid = callerApp.pid; callingUid = callerApp.info.uid; &#125; else &#123; err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; //下面startActivity方法的参数之一，代表调用者Activity的信息 ActivityRecord sourceRecord = null; if (resultTo != null) &#123; sourceRecord = mSupervisor.isInAnyStackLocked(resultTo); //... &#125; //... //创建即将要启动的Activity的信息描述类ActivityRecord ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid, callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, container, options, sourceRecord); //outActivity是ActivityRecord[]类型，从上面传进来，这里把ActivityRecord赋值给了它，下面会作为参数传进startActivity方法中 if (outActivity != null) &#123; outActivity[0] = r; &#125; //... //1、关注这里，调用了本身的另一个startActivity方法 return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask, outActivity); &#125; 上面的startActivity代码非常长，省略了很多，上面讲的调用者进程，在这里等价于应用程序进程，ProcessRecord是用来描述一个应用进程的信息，ActivityRecord上面也讲过了，就是用来记录一个要启动的Activity的所有信息，在注释1处的调用了ActivityStarter的startActivity方法，这个方法参数少了很多，大多数有关要启动的Activity的信息都被封装进了ActivityRecord类中，作为参数r传了进去。 下面来看ActivityStarter的startActivity方法。 2.3、ActivityStarter::startActivity()该方法代码如下： 12345678910111213141516 //ActivityStarter.javaprivate int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; int result = START_CANCELED; try &#123; mService.mWindowManager.deferSurfaceLayout(); //1、主要关注这里，调用本身的startActivityUnchecked方法 result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); &#125; finally &#123; //... mService.mWindowManager.continueSurfaceLayout(); &#125; //... return result; &#125; 这里主要调用了ActivityStarter的startActivityUnchecked方法。 2.4、ActivityStarter::startActivityUnchecked()该方法代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//ActivityStarter.javaprivate int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; //把上面传进来的参数除了outActivity都传进去了，主要是把这些参数赋值给ActivityStarter的成员变量，如mDoResume = doResume, mStartActivity = r //mStartActivity就是即将要启动的Activity的信息 setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor); //计算出启动Activity的模式，并赋值给mLaunchFlags computeLaunchingTaskFlags(); //... //设置启动模式 mIntent.setFlags(mLaunchFlags); //... boolean newTask = false; //1、下面会进行判断，到底需不需要创建一个新的Activity任务栈 int result = START_SUCCESS; if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; //1.1走这里就会在setTaskFromReuseOrCreateNewTask方法内部创建一个新的Activity任务栈 newTask = true; result = setTaskFromReuseOrCreateNewTask( taskToAffiliate, preferredLaunchStackId, topStack); &#125; else if (mSourceRecord != null) &#123; //1.2走这里就会在setTaskFromSourceRecord方法内部获得调用者Activity的的任务栈赋值给mTargetStack result = setTaskFromSourceRecord(); &#125; else if (mInTask != null) &#123; //1.3走这里就会在setTaskFromInTask方法内部直接把mInTask赋值给mTargetStack，前面已经说过mInTask等于null result = setTaskFromInTask(); &#125; else &#123; //1.4、就是前面的条件都不满足了，但是这种情况很少发生 setTaskToCurrentTopOrCreateNewTask(); &#125; if (result != START_SUCCESS) &#123; return result; &#125; //... //mDoResume等于上面传进来的doResume，为true if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; //走这里不会显示Activity，因为Activity还没有获取焦点或者Activity的栈溢出 //... &#125; else &#123; //正常的话会走到这里 if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront(\"startActivityUnchecked\"); &#125; //2、主要关注这里调用mSupervisor的resumeFocusedStackTopActivityLocked方法 mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); &#125; &#125; else &#123; //... &#125; return START_SUCCESS;&#125; 上面的startActivityUnchecked方法也是很长，这个方法主要处理Activity栈管理相关的逻辑，如果对于这方面信息不熟悉的话可以查看这两篇文章Android任务和返回栈完全解析、ActivityTask和Activity栈管理。一个或多个ActivityRecord会组成一个TaskRecord，TaskRecord用来记录Activity的栈，而ActivityStack包含了一个或多个TaskRecord。上面代码的mTargetStack就是ActivityStack类型，我们先来看注释1，注释1会根据mLaunchFlags等条件到底需不需要创建一个新的Activity任务栈，而本文所讨论的条件限定在从一个应用程序调用Activity的startActivity去启动另外一个Activity的情景，而且默认Activity的启动模式是standard，并不会创建一个新的任务栈，所以就会走到1.2的条件分支，然后我们再来看注释2，这里会调用mSupervisor.resumeFocusedStackTopActivityLocked方法，mSupervisor是ActivityStackSupervisor类型，ActivityStackSupervisor主要用来管理ActivityStack。启动Activity的过程从ActivityStack来到了ActivityStackSupervisor。 下面我们来看ActivityStackSupervisor的resumeFocusedStackTopActivityLocked方法。 3、ActivityStackSupervisor::resumeFocusedStackTopActivityLocked()该方法源码如下： 123456789101112131415//ActivityStackSupervisor.javaboolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; //... //获取要启动的Activity所在栈的栈顶的ActivityRecord final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); //1、r是否null或是否为RESUMED状态 if (r == null || r.state != RESUMED) &#123; //2、关注这里，调用ActivityStack的resumeTopActivityUncheckedLocked方法 mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; else if (r.state == RESUMED) &#123; mFocusedStack.executeAppTransition(targetOptions); &#125; return false; &#125; 首先这里会获取要启动的Activity所在栈的栈顶的ActivityRecord赋值给r，因为要启动的Activity的还没有启动，所以此时栈顶就是调用者Activity，调用者Activity启动Activity，肯定会从RESUME状态转到其他状态如STPO，所以注释1满足r.state != RESUMED的条件，此时就是走带注释2，注释2调用了mFocusedStack的resumeTopActivityUncheckedLocked方法，mFocusedStack就是ActivityStack类型。启动Activity的过程从ActivityStackSupervisor又回到到了ActivityStack。 下面我们来看ActivityStack的resumeTopActivityUncheckedLocked方法。 3.1、ActivityStack:: resumeTopActivityUncheckedLocked()该方法的源码如下： 12345678910111213//ActivityStack.javaboolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; //... boolean result = false; try &#123; //1、关注这里，这里调用了本身的resumeTopActivityInnerLocked方法 result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; //... &#125; //... return result; &#125; 我们来看注释1，简单的调用了resumeTopActivityInnerLocked方法。 3.1.1、 ActivityStack:: resumeTopActivityInnerLocked()该方法源码如下： 12345678910111213141516//ActivityStack.javaprivate boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; //... //获得将要启动的Activity的信息 final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */) //... if (next.app != null &amp;&amp; next.app.thread != null) &#123; //... &#125;else&#123; //... //1、关注这里，调用了ActivityStackSupervisor的startSpecificActivityLocked方法 mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return true;&#125; topRunningActivityLocked方法获得将要启动的Activity的信息next，因为此时要启动的Activity还不属于任何进程，故它的ProcessRecord为空成立，就会走到else分支，所以注释1这里调用了ActivityStackSupervisor的startSpecificActivityLocked方法，又回到了ActivityStackSupervisor中。 下面来看ActivityStackSupervisor的startSpecificActivityLocked方法。 3.2、ActivityStackSupervisor::startSpecificActivityLocked()该方法源码如下： 123456789101112131415161718//ActivityStackSupervisor.javavoid startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; //获取要启动的Activity的所在应用程序进程 ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.getStack().setLaunchTime(r); //要启动的Activity的所在应用程序进程存在 if (app != null &amp;&amp; app.thread != null) &#123; try &#123; //... //1、关注这里，调用了本身的realStartActivityLocked方法 realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; //... &#125; &#125; //... &#125; 这里首先会获取要启动的Activity所在的应用进程app，当app进程已经运行时，就会调用注释1处的realStartActivityLocked方法，注意这里多了一个参数，把代表应用进程的app传了进去。 下面来看ActivityStackSupervisor的realStartActivityLocked方法。 3.3、ActivityStackSupervisor::realStartActivityLocked()123456789101112131415161718192021222324final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; //... //1、把应用所在进程信息赋值给要启动的Activity的ActivityRecord r.app = app; //... try&#123; //... //2、关注这里，app是ProcessRecord类型，app.thread是IApplicationThread类型 //app.thread是应用进程的ApplicationThread在AMS的本地代理，前面已经讲过 //所以这里实际调用的是ApplicationThread的scheduleLaunchActivity方法 app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); //... &#125;catch (RemoteException e) &#123; //... &#125; //... return true;&#125; 正如这方法名所示，realStartActivity，兜兜转转，这里就是真正启动Activity的地方，注释1处app指的是传入的要启动的Activity的所在的应用程序进程，是从前面传过来的，这里把它赋值给了要启动的Activity的ActivityRecord的app字段去，这样就可以说要启动的Activity属于应用进程，我们再来看注释2这里，app.thread就是我们上面一直强调的ApplicationThread，所以这里通过Binder的IPC其实调用的是ApplicationThread中的scheduleLaunchActivity方法。 当前的代码逻辑执行在AMS所在进程，从这里开始Activity的启动流程最终又回到了应用进程所在的ApplicationThread中。 总结本来一篇文章写完Activity的启动，写到这里才发现，篇幅太长，所以Activity在应用进程中的启动过程就放到下一篇文章。本文简单的介绍了应用进程请求AMS启动Activity过程和Activity在AMS中的启动过程，现在让我们来回答一下开头给出的几个问题： 1、Activity的启动流程是怎样的？ 从应用调用一个startActivity方法开始，应用进程开始请求AMS启动Activity，然后在AMS中Activity完成它的一系列准备，最后再回到应用进程中开始回调Activity的生命周期，本文回答了一半这个问题，即本文讲解了应用进程开始请求AMS启动Activity，然后在AMS中完成它的一系列准备的过程，这个过程用时序图表示如下： 2、Activity的生命周期方法是如何被回调的？ 本文并没有解答这个问题，这个问题要到下一篇文章才能有答案。 3、它启动过程中涉及到多少个进程？ 答案是2个，前言已经讲过本文讨论的是普通Activity的启动流程，即我们平时调用startActivity方法来启动一个Activity，所以本文这个过程涉及的进程可以可以用下面这个图表示： 图中AppProcess代表应用所在进程，systemServer代表AMS所在进程，两个进程之间通过Binder进行通信，实现了XX.Stub的类就可以进行Binder通信，如本文的ApplicationThread和AMS都实现了各自的Stub类，所以应用进程startActivity时请求AMS启动Activity，AMS准备好后，再发送scheduleLaunchActivity请求告诉应用可以开始启动Activity了。 那么如果是前言所讲的第一种启动Activity的过程，即在Launch界面点击一个应用图标启动应用程序，那么会涉及多少个进程？答案是4个，如图： 可以看到会涉及Launcher进程、SystemServer进程、App进程、Zygote进程。关于这些进程的简单信息可以看这篇从进程的角度看Android的系统架构 阅读源码真的是一个漫长的过程，又时候看别人写的那么简单，但是当自己去写，才发现要考虑的东西很多，所以这是一个日积月累的过程，所以阅读源码的时候，最好跟着前人的文章阅读，这样理解的更快。 参考文章： 《Android开发艺术探索》 startActivity启动过程分析 Android8.0 根Activity启动过程","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"activity","slug":"activity","permalink":"http://yoursite.com/tags/activity/"}]},{"title":"Window,WindowManager和WindowManagerService之间的关系","date":"2019-03-22T14:36:32.000Z","path":"2019/03/22/Window, WindowManager和WindowManagerService之间的关系/","text":"前言上面3个名词在开发中经常听到，在Android开发中，Window是所有视图的载体，如Activity，Dialog和Toast的视图，我们想要对Window进行添加和删除就要通过WindowManager来操作，而WindowManager就是通过Binder与WindowManagerService进行跨进程通信，把具体的实现工作交给WindowManagerService（下面简称WMS）。下面分别介绍它们，理清它们的基本脉络。 本文基于Android8.0, 相关源码位置如下: frameworks/base/core/java/android/view/*.java（*代表Window, WindowManager, ViewManager, WindowManagerImpl，WindowManagerGlobal, ViewRootImpl） frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java frameworks/base/services/core/java/com/android/server/wm/Session.java Window1、Window是什么Window在Android开发中是一个窗口的概念，它是一个抽象类，我们打开Window，如下: 12345678910111213public abstract class Window &#123; public static final int FEATURE_NO_TITLE = 1; public static final int FEATURE_CONTENT_TRANSITIONS = 12; //... public abstract View getDecorView(); public abstract void setContentView(@LayoutRes int layoutResID); public abstract void setContentView(View view); public abstract void setContentView(View view, ViewGroup.LayoutParams params); public &lt;T extends View&gt; T findViewById(@IdRes int id) &#123; return getDecorView().findViewById(id); &#125; //...&#125; 可以看到里面有我们熟悉的一些字段和方法，以Activity对应的Window为例，具体的实现类是PhoneWindow，在PhoneWindow中有一个顶级View—DecorView，继承自FrameLayout，我们可以通过getDecorView()获得它，当我们调用Activity的setContentView时，其实最终会调用Window的setContentView，当我们调用Activity的findViewById时，其实最终调用的是Window的findViewById，这也间接的说明了Window是View的直接管理者。但是Window并不是真实存在的，它更多的表示一种抽象的功能集合，View才是Android中的视图呈现形式，绘制到屏幕上的是View不是Window，但是View不能单独存在，它必需依附在Window这个抽象的概念上面，Android中需要依赖Window提供视图的有Activity，Dialog，Toast，PopupWindow，StatusBarWindow（系统状态栏），输入法窗口等，因此Activity，Dialog等视图都对应着一个Window。 2、Window的类型（应用窗口，子窗口，系统窗口)与层级Window的类型type被定义在WindowManager中的静态内部类LayoutParams中，如下： 123456789101112131415161718192021222324252627282930public interface WindowManager extends ViewManager &#123; //... public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123; //应用程序窗口type值 public static final int FIRST_APPLICATION_WINDOW = 1;//代表应用程序窗口的起始值 public static final int TYPE_BASE_APPLICATION = 1;//窗口的基础值，其他窗口的type值要大于这个值 public static final int TYPE_APPLICATION = 2;//普通应用程序窗口，token必须设置为Activity的token来指定窗口属于谁 public static final int TYPE_APPLICATION_STARTING = 3; public static final int TYPE_DRAWN_APPLICATION = 4; public static final int LAST_APPLICATION_WINDOW = 99;//代表应用程序窗口的结束值 //子窗口type值 public static final int FIRST_SUB_WINDOW = 1000;//代表子窗口的起始值 public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW; public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1; public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2; public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3; public static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW + 4; public static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5; public static final int LAST_SUB_WINDOW = 1999;//代表子窗口的结束值 //系统窗口的type值 public static final int FIRST_SYSTEM_WINDOW = 2000;//代表系统窗口的起始值 public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW;//系统状态栏 public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1;//搜索条窗口 public static final int TYPE_PHONE = FIRST_SYSTEM_WINDOW+2;//通话窗口 //... public static final int LAST_SYSTEM_WINDOW = 2999;//代表系统窗口结束值 &#125;&#125; LayoutParams中以TYPE开头的值有很多，但总体可以分为3类： 应用程序窗口：type值范围是1~99，Activity就是一个典型的应用程序窗口，type值是TYPE_BASE_APPLICATION，WindowManager的LayoutParams默认type值是TYPE_APPLICATION。 子窗口：type值范围是1000~1999，PupupWindow就是一个典型的子窗口，type值是TYPE_APPLICATION_PANEL，子窗口不能独立存在，必须依附于父窗口 系统窗口：type值范围是2000~2999,系统窗口的类型很多，上面并没有全部列举出来，系统状态栏就是一个典型的系统窗口，type值是TYPE_STATUS_BAR，与应用程序窗口不同的是，系统窗口的创建是需要声明权限的。 type值决定了决定了Window显示的层级（z-ordered），即在屏幕Z轴方向的显示次序，一般情况下type值越大，则窗口显示的越靠前，在Window的3种类型中，应用程序窗口的层级范围是1~99，子窗口的层级范围是1000~1999，系统窗口的层级范围是2000~2999，层级范围对应着type值，如果想要Window位于所有的Window上，采用较大的层级即可，例如系统层级。 3、Window的属性Window的类型flag同样被定义在WindowManager中的静态内部类LayoutParams中，如下： 12345678910111213public interface WindowManager extends ViewManager &#123; //... public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123; public static final int FLAG_ALLOW_LOCK_WHILE_SCREEN_ON = 0x00000001; public static final int FLAG_DIM_BEHIND = 0x00000002; public static final int FLAG_BLUR_BEHIND = 0x00000004; public static final int FLAG_NOT_FOCUSABLE = 0x00000008; public static final int FLAG_NOT_TOUCHABLE = 0x00000010; public static final int FLAG_NOT_TOUCH_MODAL = 0x00000020; public static final int FLAG_KEEP_SCREEN_ON = 0x00000080; //... &#125;&#125; LayoutParams中定义的flag属性同样很多，这里挑几个常见的讲解： FLAG_ALLOW_LOCK_WHILE_SCREEN_ON：只要窗口对用户可见，就允许在屏幕开启状态下锁屏。 FLAG_KEEP_SCREEN_ON： 只要窗口对用户可见，屏幕就一直亮着。 FLAG_SHOW_WHEN_LOCKED：窗口可以在锁屏的界面上显示。 FLAG_NOT_FOCUSABLE：窗口不能获取焦点，也不能接受任何输入事件，此标志同时会启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层的具有焦点的窗口。 FLAG_NOT_TOUCH_MODAL：当前窗口区域以外的触摸事件会传递给底层的窗口，当前窗口区域内的触摸事件则自己处理，一般来说都要开启此标记，否则其他Window将无法收到单机事件。 FLAG_NOT_TOUCHABLE：窗口不接收任何触摸事件 可以看到LayoutParams中的type和flag非常重要，可以控制Window的显示特性。知道了Window的相关信息，就能更好的了解WindowManager。 WindowManagerWindowManager是一个接口，里面常用的方法有：添加View，更新View和删除View，WindowManager继承自ViewManager，这三个方法定义在ViewManager中，如下： 123456public interface ViewManager&#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 可以看到这些方法传入的参数是View，不是Window，说明WindowManager管理的是Window中的View，我们通过WindowManager操作Window就是在操作Window中的View。WindowManager的具体实现类是WindowManagerImp，我们看一下相应方法的实现，如下： 12345678910111213141516171819202122232425262728public final class WindowManagerImpl implements WindowManager &#123; private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Context mContext; private final Window mParentWindow; //... private WindowManagerImpl(Context context, Window parentWindow) &#123; mContext = context; mParentWindow = parentWindow; &#125; @Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; //... mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; @Override public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; //... mGlobal.updateViewLayout(view, params); &#125; @Override public void removeView(View view) &#123; mGlobal.removeView(view, false); &#125;&#125; 可以看到WindowManagerImp也没有做什么，它把3个方法的操作都委托给了WindowManagerGlobal这个单例类，我们还看到了mParentWindow这个字段，它是Window类型，是从构造中被传入，所以WindowManager会持有Window的引用，这样WindowManager就可以对Window做操作了。比如mGlobal.addView，我们可以理解为往window中添加View，在WindowManagerGlobal中，如下： 1234567public void addView(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow)&#123; //... ViewRootImpl root; root = new ViewRootImpl(view.getContext(), display);//注释1 //... root.setView(view, wparams, panelParentView);&#125; 最终会走到ViewRootlmp的setView中, 如下： 123456789101112public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; //... //这里会进行View的绘制流程 requestLayout(); //... //通过session与WMS建立通信 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); //...&#125; 在ViewRootlmp的setView中，首先通过requestLayout()发起View绘制流程，然后在mWindowSession的addToDisplay中通过Binder与WMS进行跨进程通信，请求显示窗口上的视图，至此View就会显示到屏幕上。这个mWindowSession是一个IWindowSession.AIDL接口类型，用来实现跨进程通信，在WMS内部会为每一个应用的请求保留一个单独的Session，同样实现了IWindowSession接口，应用与WMS之间的通信就通过这个Session。那么这个mWindowSession什么时候被赋值的呢？就在上面的注释1中，我们打开ViewRootlmp的构造函数，如下： 1234public ViewRootImpl(Context context, Display display) &#123; mWindowSession = WindowManagerGlobal.getWindowSession(); //...&#125; 可以看到mWindowSession是通过WindowManagerGlobal的单例类的getWindowSession()获得的，我们打开WindowManagerGlobal的getWindowSession()，如下： 1234567891011121314151617181920212223public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; InputMethodManager imm = InputMethodManager.getInstance(); //1、首先获取WMS的本地代理 IWindowManager windowManager = getWindowManagerService(); //2、通过WMS的本地代理的openSession来获取Session sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125; &#125; 我们首先看1，getWindowManagerService()源码如下： 1234567891011121314public static IWindowManager getWindowManagerService() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowManagerService == null) &#123; //获取WMS的本地代理对象 sWindowManagerService = IWindowManager.Stub.asInterface( ServiceManager.getService(\"window\")); //... &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowManagerService; &#125; &#125; 可以看到， ServiceManager.getService(“window”)就是获得WMS，然后通过IWindowManager.Stub.asInterface()转换成WMS在应用进程的本地代理，getWindowManagerService()就是返回WMS在本地应用进程的代理。（这里涉及到Binder知识） 然后看2，通过WMS的本地代理的openSession来获取Session，我们可以在WMS中找到这个函数实现，如下： 12345678@Override public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client, IInputContext inputContext) &#123; //... //为每个窗口请求创建一个Session并返回 Session session = new Session(this, callback, client, inputContext); return session; &#125; 至此建立起与WMS的通信的桥梁。然后WindowManager就间接的通过Session向WMS发起显示窗口视图的请求，WMS会向应用返回和窗口交互的信息。至于mGlobal.updateViewLayout和mClobal.removeView也是类似的过程，可自行研究。 WindowManagerServiceWindowManagerService是一个系统级服务，由SystemService启动，实现了IWindowManager.AIDL接口，它的主要功能分为以下俩方面: 1、窗口管理它负责窗口的启动，添加和删除，它还负责窗口的层级显示（z-orderes）和维护窗口的状态。我们继续上面的mGlobal.addView，上面讲到这个方法是向WMS发起一个显示窗口视图的请求，最终会走到mWindowSession.addToDisplay()方法，我们可以在Session中找到这个函数实现，如下： 12345678@Override public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; //返回WMS中addWindow所返回的结果 return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel); &#125; 可以看到addToDisplay方法中最终返回了WMS中addWindow所返回的结果，Window的添加请求就交给WMS去处理，addWindow的实现在WMS中，里面代码很长，这里就不再深究了（留在下一篇文章从一个例子分析），addWindow主要做的事情是先进行窗口的权限检查，因为系统窗口需要声明权限，然后根据相关的Display信息以及窗口信息对窗口进行校对，再然后获取对应的WindowToken，再根据不同的窗口类型检查窗口的有效性，如果上面一系列步骤都通过了，就会为该窗口创建一个WindowState对象，以维护窗口的状态和根据适当的时机调整窗口状态，最后就会通过WindowState的attach方法与SurfaceFlinger通信。因此SurfaceFlinger能使用这些Window信息来合成surfaces,并渲染输出到显示设备。 2、输入事件的中转站当我们的触摸屏幕时就会产生输入事件，在Android中负责管理事件的输入是InputManagerService，在启动IMS的时候会在native层创建NativeInputManager，在NativeInputManager的构造中会创建InputManager和Eventhub（监听/dev/input/设备节点中所有事件的输入），在InputManager构造中会依此创建InputDispatcher、InputReader、InputReaderThread、InputDispatcherThread。 InputReader运行在InputReaderThread中，它会不断循环从EventHub中读取原始输入事件，InputReader将这些原始输入事件加工后就交给运行在InputDispatcherThread中的InputDispatcher，而InputDispatcher它会寻找一个最合适的窗口来处理输入事件，WMS是窗口的管理者，WMS会把所有窗口的信息更新到InputDispatcher中，这样InputDispatcher就可以将输入事件派发给合适的Window，Window就会把这个输入事件传给顶级View，然后就会涉及我们熟悉的事件分发机制。 我们来再来看在ViewRootImp的setView中调用mWindowSession.addToDisplay方法时传入的参数： 1234567891011121314151617public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; //... mInputChannel = new InputChannel(); //... //通过session与WMS建立通信,同时通过InputChannel接收输入事件回调 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); //... if (mInputChannel != null) &#123; //... //处理输入事件回调 mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125;&#125; 注意这个传入的mInputChannel参数，它实现了Parcelable接口，用于接受WMS返回来的输入事件。 它们之间的类图关系如下： 总结通过上面简单的介绍，我们知道Window是View的载体，我们想要对Window进行删除，添加，更新View就得通过WindowManager，WindowManager与WMS通过Session进行通信，具体的实现就交给了WMS处理，WMS会为每一个Window创建一个WindowState并管理它们，具体的渲染工作WMS就交给SurfaceFinger处理。本文所讨论的WMS系统相关结构如下： 参考资料： 《Anddroid开发艺术探索》 《Android源码设计模式》 Android解析WindowManager","tags":[{"name":"window","slug":"window","permalink":"http://yoursite.com/tags/window/"},{"name":"windowManager","slug":"windowManager","permalink":"http://yoursite.com/tags/windowManager/"},{"name":"WMS","slug":"WMS","permalink":"http://yoursite.com/tags/WMS/"}]},{"title":"RecyclerView之观察者模式","date":"2019-03-09T09:39:00.000Z","path":"2019/03/09/RecyclerView之观察者模式/","text":"前言RecyclerView是Android开发中的一个重要的模式，通常我们往RecyclerView添加数据时，都会调用Adapter的notifiyXX函数，这是为什么呢，今天我们就从源码来探究一下，对观察者模式不熟悉的读者，可以看一下这一篇博客观察者模式, RecyclerView在更新数据时也算是对观察者模式的一种应用。 本文源码基于Android8.0, 相关源码位置如下 frameworks/support/v7/recyclerview/src/android/support/v7/widget/RecyclerView.java frameworks/base/core/java/android/database/Observable.java Adapter.notifyDataSetChange()我们来看一下我们平常可能使用到的notifyXX方法：可以看到，RecyclerView可ListView相比多了很多notifyItemXX方法，说明RecyclerView支持定向刷新，如果只有部分itemView数据发生变化，在使用ListView时我们没得选择只能使用notifyDataSetChange()方法来对整体itemView更新数据，但是在RecyclerView中，我们可以只对发生数据变化的itemView更新，当样也可以整体更新，而且相信大家现在在使用RecyclerView更新itemView时使用最多的方法还是Adapter.notifyDataSetChange()吧。那我们就以这个方法为例，该方法的源码如下:123public final void notifyDataSetChanged() &#123; mObservable.notifyChanged();&#125; 这个mObservable是声明在Adapter中的AdapterDataObservable对象，如下:1234public abstract static class Adapter&lt;VH extends ViewHolder&gt; &#123; private final AdapterDataObservable mObservable = new AdapterDataObservable(); //...&#125; 而AdapterDataObservable定义在RecyclerView中，Adapter.notifyDataSetChange()调用了AdapterDataObservable.notifyChanged()方法，该方法源码如下:12345678static class AdapterDataObservable extends Observable&lt;AdapterDataObserver&gt; &#123; public void notifyChanged() &#123; for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125; &#125;//...&#125; 可以看到该方法做的事情是遍历mObservers集合，然后逐个调用onChanged()方法，那么mObservers是什么东西？mObservers其实就是一个观察者列表，而mObservable就是一个被观察者，每个Adapter中只有一个被观察者，被观察者中有一个观察者列表，当有数据更新时，被观察者就会调用遍历调用注册到观察者列表中观察者的onChanged方法，来通知观察者更新数据。mObservers其实是一个ArrayList，它定义在AdapterDataObservable的父类Observable中，Observable的定义如下:12345678910111213141516171819202122public abstract class Observable&lt;T&gt; &#123; protected final ArrayList&lt;T&gt; mObservers = new ArrayList&lt;T&gt;();//观察者集合列表 //注册一个观察者 public void registerObserver(T observer) &#123; //... mObservers.add(observer); &#125; //取消该观察者的注册 public void unregisterObserver(T observer) &#123; //... mObservers.remove(index); &#125; //取消所有观察者的注册 public void unregisterAll() &#123; synchronized(mObservers) &#123; mObservers.clear(); &#125; &#125;&#125; Observable中只有几个简单的方法，所以我们要向观察者列表中注册一个观察者，才能接受到更新通知，那么RecyclerView是怎么注册一个观察者的吗？其实是通过RecyclerView.setAdapter()方法实现的。 RecyclerView.setAdapter()我们每次使用RecyclerView都要调用setAdapter()设置一个Adapter，不然数据就无法展示，该方法的源码如下:1234public void setAdapter(@Nullable Adapter adapter) &#123; //... setAdapterInternal(adapter, false, true);&#125; 在setAdapter又调用了setAdapterInternal(), 该方法相关源码如下:1234567891011121314151617181920private void setAdapterInternal(@Nullable Adapter adapter, boolean compatibleWithPrevious, boolean removeAndRecycleViews) &#123; //1、移除旧的Adapter，并注销观察者 if (mAdapter != null) &#123; mAdapter.unregisterAdapterDataObserver(mObserver); &#125; //2、compatibleWithPrevious为false，表示不使用旧的Adapter中ViewHolder，所以调用removeAndRecycleViews方法把ViewHolder旧的Adapter中的ViewHolder回收复用 if (!compatibleWithPrevious || removeAndRecycleViews) &#123; removeAndRecycleViews(); &#125; //3、更新Adapter并注册一个观察者 final Adapter oldAdapter = mAdapter; mAdapter = adapter; if (adapter != null) &#123; //注册一个观察者 adapter.registerAdapterDataObserver(mObserver); &#125; //...&#125; setAdapterInternal()方法中就主要做了上面3件事，而且上面Adapter中调用的registerXX或unregisterXX最终调用mObservable的方法, 如下:123456789101112public abstract static class Adapter&lt;VH extends ViewHolder&gt; &#123; public void registerAdapterDataObserver(@NonNull AdapterDataObserver observer) &#123; mObservable.registerObserver(observer); &#125; public void unregisterAdapterDataObserver(@NonNull AdapterDataObserver observer) &#123; mObservable.unregisterObserver(observer); &#125; //...&#125; 这些方法的含义已经在上面讲解Observable时解释过了。那么在setAdapterInternal()中注册的观察者mObserver是什么呢？它其实就是一个RecyclerViewDataObserver类型，定义在RecyclerView中，如下:1234public class RecyclerView extends ViewGroup implements ScrollingView, NestedScrollingChild2 &#123; private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver(); //...&#125; 而RecyclerViewDataObserver是AdapterDataObserver的子类，它定义在RecyclerView中，如下：12345678910111213private class RecyclerViewDataObserver extends AdapterDataObserver &#123; @Override public void onChanged() &#123; //... if (!mAdapterHelper.hasPendingUpdates()) &#123; //请求重新布局 requestLayout(); &#125; &#125; //...&#125; 可以看到我们熟悉的onChange方法，RecyclerViewDataObserver重写了它，当满足一定条件时就会重新布局从而从可以从Adapter中获取更新数据并绑定数据到itemView,达到更新itemView的目的。所以RecyclerView在设置Adapter是时，会注册一个观察者mObserver到Adapter的被观察者mObservable中。 总结最后我们来整理一下这个过程，RecyclerView中有一个观察者mObserver，是RecyclerViewDataObserver类型，在RecyclerView设置Adapter时会把它注册到Adapter中，而Adapter中包含一个被观察者mObservable，是AdapterDataObservable类型，注册到Adapter中的观察最终会注册到mObservable的mObservers列表中，当我们手动调用Adapter的notifyXX函数时，notifyXX函数实际上会调用AdapterDataObservable的notifyXX函数，该函数会遍历所有观察者的onChange函数，在RecyclerViewDataObserver的onChange函数中会要求RecyclerView调用requestLayout()重新布局,更新用户界面。如图：","tags":[{"name":"recyclerView","slug":"recyclerView","permalink":"http://yoursite.com/tags/recyclerView/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"RecyclerView之缓存设计","date":"2019-03-08T06:56:50.000Z","path":"2019/03/08/RecyclerView之缓存设计/","text":"前言 上一篇文章RecyclerView之布局设计 RecyclerView，见名之义，这个View代表了可循环使用的视图集合控件，封装了View的缓存逻辑判断，RecyclerView的基本单元是ViewHolder，里面有一个itemView代表了视图上的子View，所以RecyclerView的缓存基本单元也是ViewHolder。本文将从源码的角度来讲解RecyclerView的缓存设计。 本文相关源码基于Android8.0，相关源码位置如下: frameworks/support/v7/recyclerview/src/android/support/v7/widget/RecyclerView.java frameworks/support/v7/recyclerview/src/android/support/v7/widget/LinearLayoutManager.java Recycler这里首先介绍一下Recycler，它定义在RecyclerView中，如下：12345678910public final class Recycler &#123; final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;();//缓存着在屏幕中显示的ViewHolder final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();//缓存着已经滚动出屏幕的ViewHolder,即屏幕外的ViewHolder RecycledViewPool mRecyclerPool;//ViewHolder的缓存池，屏幕外缓存的mCachedViews已满时，会将ViewHolder缓存到RecycledViewPool中。 private ViewCacheExtension mViewCacheExtension;//自定义缓存，自己实现ViewCacheExtension类来实现缓存。 ArrayList&lt;ViewHolder&gt; mChangedScrap = null;//屏幕内缓存，缓存着数据已经改变的ViewHolder int mViewCacheMax = DEFAULT_CACHE_SIZE;//mCachedViews默认缓存数量 static final int DEFAULT_CACHE_SIZE = 2;//默认缓存数量为2 private int mRequestedCacheMax = DEFAULT_CACHE_SIZE; //可以设置mCachedViews的最大缓存数量，默认为2。&#125; Recycler是RecyclerView的核心类，是RecyclerView的缓存实现类，它有着四级缓存： 1、mAttachedScrap当我们调用notifiXX函数重新布局时，在布局之前，LayoutManager会调用detachAndScrapAttachedViews(recycler)把在RecyclerView中显示的ViewHolder一个个的剥离下来,然后缓存在mAttachedScrap中，等布局时会先从mAttachedScrap查找，再把ViewHolder一个个的放回RecyclerView中去，而mAttachedScrap中的ViewHolder并不会参与回收复用，只是单纯的为了从RecyclerView中剥离下来，再重新放回RecyclerView，如果还有剩余的ViewHolder没有参加新布局，会从mAttachedScrap移到mCachedViews中。 2、mCachedViews在RecyclerView滚动时，对于那些不在RecyclerView中显示的ViewHolder，LayoutManager会调用removeAndRecycleAllViews(recycler)把这些已经移除的ViewHolder缓存在mCacheViews中，它的默认大小是2，当它满了的时候，就会利用先进先出原则，把老的ViewHolder移到mRecyclerPool中。mCachedViews也不参与回收复用，它只是缓存最新被移除的ViewHolder。 3、mViewCacheExtension自定义缓存实现，一般而言，我们不会自定义缓存实现，使用Recycler提供的3级缓存足够。 4、mRecyclerPool其实真正参与回收复用的是mRecyclerPool，通过前面1、2可以知道，真正废弃的ViewHolder最终移到mRecyclerPool，当我们向RecyclerView申请一个HolderView来使用的时，如果在mAttachedScrap、mCachedViews匹配不到，即使他们中有ViewHolder也不会返回给我们使用，而是会到mRecyclerPool中去拿一个废弃的ViewHolder返回。mRecyclerPool内部维护了一个SparseArray，在mRecyclerPool中会根据每个ViewType把ViewHolder分别存储在不同的列表中，每个ViewType默认缓存5个ViewHolder。RecyclerViewPool大概结构如下：12345678910 public static class RecycledViewPool &#123; private static final int DEFAULT_MAX_SCRAP = 5; static class ScrapData &#123; final ArrayList&lt;ViewHolder&gt; mScrapHeap = new ArrayList&lt;&gt;(); int mMaxScrap = DEFAULT_MAX_SCRAP; //... &#125; SparseArray&lt;ScrapData&gt; mScrap = new SparseArray&lt;&gt;(); //...&#125; 而且RecyclerViewPool也可以是多个RecyclerView之间的ViewHolder的缓存池，只要通过RecyclerView.setRecycledViewPool(RecycledViewPool)设置同一个RecycledViewPool，设置时，不需要自己去new 一个 RecyclerViewPool，每个RecyclerView默认都有一个RecyclerViewPool，只需要通过mRecyclerView.getRecycledViewPool()获取。 所以我们从Recycler中获取一个ViewHolder时，是这样的顺序：mAttachedScrap -&gt; mCachedViews -&gt; mViewCacheExtension -&gt; mRecyclerPool,当上述步骤都找不到了，就会调用Adapter的creat函数创建一个ViewHolder。那这里为什么省略mChangedScrap不讲呢？因为mChangedScrap是跟RecyclerView的预布局有关，缓存着RecyclerView中数据改变过的ViewHolder，而预布局默认为false，一般是RecyclerView执行动画时才会为true，我们上一篇文章也没有讨论执行动画的时候的布局过程，所以这里就不分析mChangedScrap。 Recycler.getViewForPosition()在上篇文章中，提到在layoutChunk函数中，首先会调用LayoutState对象的next函数获取到一个itemView，然后布局这个itemView，我们来看LayoutState的next函数相关实现:123456789View next(RecyclerView.Recycler recycler) &#123; //省略了一个mScrapList，属于LayoutManager，跟执行动画时的缓存有关，这里不分析 //... //这里才是核心，调用Recycler中的getViewForPosition获取itemView final View view = recycler.getViewForPosition(mCurrentPosition); //把itemView索引移到下一个位置 mCurrentPosition += mItemDirection; return view;&#125; 上述代码实际是调用RecyclerView.Recycler对象的getViewForPosition方法获取itemView，而该函数最终会获取一个ViewHolder，从而返回ViewHolder中的itemView，我们来看该函数相关调用和实现：12345678910111213public View getViewForPosition(int position) &#123; return getViewForPosition(position, false);&#125;View getViewForPosition(int position, boolean dryRun) &#123; //可以看到最终返回的是ViewHolder中的itemView return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;&#125;//获取一个ViewHolderViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; //...&#125; Recycler的getViewForPosition方法最终会调用到tryGetViewHolderForPositionByDeadline方法，tryGetViewHolderForPositionByDeadline方法的意图是通过给定的position从Recycler的scrap, cache，RecycledViewPool获取一个ViewHolder或者通过Adapter直接创建一个ViewHolder。我们来看tryGetViewHolderForPositionByDeadline方法相关源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//参数解释：//position：要获得哪个位置的ViewHolder//dryRun: 代表position的ViewHolder是否已经从scrap或cache列表中移除，这里为false，表示没有，因为布局函数layoutChildren中一定会调用detachAndScrapAttachedViews(recycler)函数，表示把ViewHolder放入scrap列表中ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; //省略了跟预布局有关的mChangedScrap获取ViewHolder，mChangedScrap不属于常规缓存 //... ViewHolder holder = null; if (holder == null) &#123; //1、第一次查找，通过position从scrap或hidden或cache中找ViewHolder holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun); //如果找到ViewHolder，检查ViewHolder的合法性 if (holder != null) &#123; //检查ViewHolder的是否被移除，position是否越界等，如果检查通过返回true，失败返回false if (!validateViewHolderForOffsetPosition(holder)) &#123; //检查不通过 //上述讲过dryRun为false if (!dryRun) &#123; //设置这个ViewHolder为无效标志 holder.addFlags(ViewHolder.FLAG_INVALID); //把这个ViewHolder从scrap列表中移除 if (holder.isScrap()) &#123; removeDetachedView(holder.itemView, false); holder.unScrap(); &#125; //... //把这个ViewHolder放入cache列表中或mRecyclerPool中 recycleViewHolderInternal(holder); &#125; //置空不匹配的ViewHolder，进入下一步查找 holder = null; &#125; else &#123; //检查通过了 fromScrapOrHiddenOrCache = true; &#125; &#125; &#125; if (holder == null) &#123; //... final int offsetPosition = mAdapterHelper.findPositionOffset(position); //这里可以看到我们熟悉的Adapter中的getItemViewType方法，重写此方法可以让RecyclerView显示多种type的itemView final int type = mAdapter.getItemViewType(offsetPosition); //如果mAdapter.hasStableIds()为true，就进入第2次查找，默认返回false if (mAdapter.hasStableIds()) &#123; //2、第2次查找，根据ViewHolder的type和id从scrap或cached列表查找 holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); if (holder != null) &#123; //找到了 //更新ViewHolder的位置 holder.mPosition = offsetPosition; fromScrapOrHiddenOrCache = true; &#125; &#125; if (holder == null &amp;&amp; mViewCacheExtension != null) &#123; //3、第3次查找，从自定义缓存中查找，一般我们不会重写ViewCacheExtension final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type); //... &#125; if (holder == null) &#123; //4、第4次查找，从RecycledViewPool中查找，可以看到这里会根据type返回一个使用过的ViewHolder给你 holder = getRecycledViewPool().getRecycledView(type); if (holder != null) &#123;//找到了 //重置ViewHolder中的信息 holder.resetInternal(); //... &#125; &#125; //前面的4次还找不到合适的ViewHolder，就重新创建一个 if (holder == null) &#123; //... //5、这里会调用Adapter中的OnCreateViewHolder方法 holder = mAdapter.createViewHolder(RecyclerView.this, type); &#125; &#125; //... boolean bound = false; //这里会根据情况调用Adapter中的OnBindViewHolder方法 if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); //这里最终调用Adapter中的OnBindViewHolder方法 bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs); &#125; &#125; 看起来函数很长但是步骤还是很清晰的，我们一步步来看： 注释1：getScrapOrHiddenOrCachedHolderForPosition()注释1中通过position从scrap或hidden或cache中找ViewHolder，我们来看getScrapOrHiddenOrCachedHolderForPosition方法的关键源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546 ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) &#123; //1.1、第一次尝试，从mAttachedScrap找到一个精确，没有失效的ViewHolder并返回 final int scrapCount = mAttachedScrap.size(); for (int i = 0; i &lt; scrapCount; i++) &#123; final ViewHolder holder = mAttachedScrap.get(i); if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved()))&#123; //标志这个ViewHolder是从mAttachedScrap取出并返回的 holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP); return holder; &#125; &#125; //1.2、第二次尝试，dryRun为false，从RecyclerView中隐藏的itemView中找，如果找到合适的View，就让它显示并把它从RecyclerView中剥离，然后根据这个View的LayoutParam获取ViewHolder，最后把这个ViewHolder放入mAttachedScrap并返回 if (!dryRun) &#123; View view = mChildHelper.findHiddenNonRemovedView(position); if (view != null) &#123; //获取ViewHolder final ViewHolder vh = getChildViewHolderInt(view); //显示这个View mChildHelper.unhide(view); //从RecyclerView剥离这个View mChildHelper.detachViewFromParent(layoutIndex); //把这个ViewHolder放入mAttachedScrap scrapView(view); vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); //返回 return vh; &#125; &#125; //1.3、第三次尝试，从mCachedViews找到没有失效的ViewHolder并返回 final int cacheSize = mCachedViews.size(); for (int i = 0; i &lt; cacheSize; i++) &#123; final ViewHolder holder = mCachedViews.get(i); if (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position) &#123; if (!dryRun) &#123; mCachedViews.remove(i); &#125; return holder; &#125; &#125; return null;&#125; 可以看到注释1的第一次查找，里面分为3步： 1.1、从mAttachedScrap找。 1.2、如果上一步没有得到合适的缓存，从HiddenViews找。 1.3、如果上一步没有得到合适的缓存，从mCachedViews找。 从上面3个步骤之一找到，就返回ViewHolder，然后检查ViewHolder的有效性，如果无效，则从mAttachedScrap中移除，并加入到mCacheViews或者mRecyclerPool中，并且将ViewHolder置为null，走到下一步。 注释2：getScrapOrCachedViewForId()下一步就是注释2，如果我们通过Adapter.setHasStableIds(boolean)设置为true，就会进入,里面根据ViewHolder的type和id从scrap或cached列表查找ViewHolder，我们来看一下相关源码该方法的相关源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546ViewHolder getScrapOrCachedViewForId(long id, int type, boolean dryRun) &#123;//2.1、第一次尝试，从mAttachedScrap找到一个id相同并且没有从mAttachedScrap取出并返回过的ViewHolder，还要type相同的ViewHolder返回 final int count = mAttachedScrap.size(); for (int i = count - 1; i &gt;= 0; i--) &#123; final ViewHolder holder = mAttachedScrap.get(i); if (holder.getItemId() == id &amp;&amp; !holder.wasReturnedFromScrap()) &#123; //id相同type相同 if (type == holder.getItemViewType()) &#123; holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP); //... &#125; return holder; &#125; else if (!dryRun) &#123; //id相同但type不同 //从mAttachedScrap移除这个ViewHolder mAttachedScrap.remove(i); removeDetachedView(holder.itemView, false); //把这个ViewHolder放入caches或RecyclerViewPool quickRecycleScrapView(holder.itemView); &#125; &#125; &#125; //2.2、第2次尝试，从mCachedViews中找到一个id相同并且type相同的ViewHolder返回 final int cacheSize = mCachedViews.size(); for (int i = cacheSize - 1; i &gt;= 0; i--) &#123; final ViewHolder holder = mCachedViews.get(i); if (holder.getItemId() == id) &#123; //id相同并且type相同 if (type == holder.getItemViewType()) &#123; if (!dryRun) &#123; //从cache中移除 mCachedViews.remove(i); &#125; return holder; &#125; else if (!dryRun) &#123; //id相同type不相同 //把这个ViewHolder从cache中移除并放入RecyclerViewPool中 recycleCachedViewAt(i); return null; &#125; &#125; &#125; return null;&#125; 可以看到注释2的第二次查找，里面分为2步： 2.1、从mAttachedScrap找。 2.2、如果上一步没有得到合适的缓存，从mCachedViews找。 第二次查找跟第一次不同的是，它是通过Adapter.getItemId(position)获得该位置ViewHolder的id，来查找ViewHolder，我们可以重写Adapter.getItemId(position)返回每个position的ViewHolder的id，默认返回RecyclerView.NO_ID。从上面2个步骤之一找到，就返回ViewHolder，如果找不到就进入下一步。 注释3：mViewCacheExtension注释3的第三次查找是从自定义缓存中查找，这个没什么好说，可以直接到下一步。 注释4：下一步就是第4次查找，从RecyclerdViewPool中查找，可以看到这里先使用getRecyclerViewPool获得Recycler中的RecyclerViewPool，然后调用RecyclerViewPool的getRecycledView(type)根据type获取一个ViewHolder，我们来看该方法的源码：1234567891011 public ViewHolder getRecycledView(int viewType) &#123; //根据type取出ScrapData final ScrapData scrapData = mScrap.get(viewType); if (scrapData != null &amp;&amp; !scrapData.mScrapHeap.isEmpty()) &#123; //取出ScrapData中的ViewHolder列表 final ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap; //返回一个ViewHolder并从pool中删除 return scrapHeap.remove(scrapHeap.size() - 1); &#125; return null;&#125; mScrap是SparseArray类型，它会根据type把ViewHolder存放在不同ScrapData中，ScrapData中有一个mScrapHeap，是ArrayList类型，它会存放RecyclerViewPool中放进来的ViewHolder。所以上面这个方法首先会根据type取出ScrapData，然后取出mScrapHeap，如果mScrapHeap有元素，就返回并删除，然后重置这个ViewHolder让它复用，如果没有就进入下一步。 注释5：Adapter.createViewHolder()既然缓存中没有就创建一个，该方法的相关源码如下：1234 public final VH createViewHolder(@NonNull ViewGroup parent, int viewType) &#123; //... final VH holder = onCreateViewHolder(parent, viewType);&#125; 可以看到，调用了我们熟悉的onCreateViewHolder方法，该方法就是用来创建ViewHolder。 ps：从上面知道当缓存中不能提供ViewHolder就会调用adapter的onCreateViewHolder创建一个，那么我们同样熟悉的OnBindViewHolder方法是什么时候执行的呢？bind方法是用来绑定数据，对于从mAttachedScrap和mCachedViews中拿出来的ViewHolder是不用重新bind的，而对于从mRecyclerPool拿出和通过Create方法创建的ViewHolder是需要重新bind的，所以前面说RecyclerViewPool才是真正用来回收复用ViewHolder的。 总结本文中源码角度简单的分析RecyclerView布局一个itemView时是怎样通过Recycler来获取一个ViewHolder，从而获取itemView，如图：准确的来说，Recycler是RecyclerView的itemView的提供者和管理者，它在内部封装了RecyclerView的缓存设计实现，在RecyclerView中有着四级缓存：AttachedScrap,mCacheViews,ViewCacheExtension,RecycledViewPool，正因为这样RecyclerView在使用的时候效率更好。 参考文章: RecyclerView和ListView原理","tags":[{"name":"recyclerView","slug":"recyclerView","permalink":"http://yoursite.com/tags/recyclerView/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"RecyclerView之布局设计","date":"2019-03-01T07:10:00.000Z","path":"2019/03/01/RecyclerView之布局设计/","text":"前言RecyclerView功能强大，自推出以来受到了无数人的喜爱，它可以通过一个LayoutManager将一个RecyclerView显示为不同的样式，例如ListView、GridView样式、瀑布流样式，所以加深对于RecyclerView的学习对于开发有很重要的意义。关于RecyclerView如何使用网上有很多文章，本篇文章从源码讲解RecyclerView如何通过layoutManager来进行布局。 本文相关源码基于Android8.0，相关源码位置如下: frameworks/support/v7/recyclerview/src/android/support/v7/widget/RecyclerView.java frameworks/support/v7/recyclerview/src/android/support/v7/widget/LinearLayoutManager.java RecyclerView.onLayout()Android中每一个控件从它被定义到xml布局文件到呈现在屏幕上都要经过onMeasure -&gt; onLayout -&gt; onDraw 三个阶段，RecyclerView同样不例外，它的布局在OnLayout函数中进行，该方法相关源码如下:1234protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; dispatchLayout(); mFirstLayoutComplete = true;&#125; 可以看到该方法只是简单的调用了dispatchLayout方法,并记录了是第一次布局，dispatchLayout()相关源码如下：12345678910111213141516171819202122232425262728 void dispatchLayout() &#123; //1、检查是否设置了Adapter和LayoutManager if (mAdapter == null) &#123; return; &#125; if (mLayout == null) &#123; return; &#125; //... //2、RecyclerView的布局分3步，即dispatchLayoutStep1()，dispatchLayoutStep2()，dispatchLayoutStep3()，下面分情况进行dispatchLayoutStep1()，dispatchLayoutStep2() //2.1、没有执行过布局流程，执行 dispatchLayoutStep1()， dispatchLayoutStep2() if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); //2.2、已经执行过布局流程，但是因为数据变化或布局大小发生改变，重新执行 dispatchLayoutStep2() &#125;else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); //2.3、已经执行过布局流程并且数据和布局大小也确定了 &#125; else &#123; //设置RecyclerView的宽高为精确模式（即MeasureSpecMode == MeasureSpec.EXACTLY） mLayout.setExactMeasureSpecsFrom(this); &#125; //3、RecyclerView的布局第3步 dispatchLayoutStep3() dispatchLayoutStep3();&#125; 上面源码我分3部分解释，首先注释1，没有设置RecyclerView的Adapter和LayoutManager直接return，这也解释了为什么我们平时忘记设置它们时RecyclerView会显示不出数据。然后注释2、3，这两部分一起讲，因为RecyclerView的布局过程分为3步：dispatchLayoutStep1，dispatchLayoutStep2和dispatchLayoutStep3。在讲解之前先讲解mState.mLayoutStep，mState是State类型用于保存RecyclerView的状态，mLayouStep定义在State中，有三种取值分别代表了布局过程的3个步骤，如下：1234567//RecyclerView.Statepublic static class State &#123; static final int STEP_START = 1; //还未执行dispatchLayoutStep1()，初始步骤 static final int STEP_LAYOUT = 1 &lt;&lt; 1; //已经执行了dispatchLayoutStep1()或dispatchLayoutStep2()，布局步骤 static final int STEP_ANIMATIONS = 1 &lt;&lt; 2; //已经执行dispatchLayoutStep2()，动画步骤 //... int mLayoutStep = STEP_START; 可以看到mLayoutStep默认是STEP_START取值，下面我们简单分析RecyclerView的布局过程3步分别做了什么，首先dispatchLayoutStep1()的相关源码如下：123456789101112131415161718private void dispatchLayoutStep1() &#123; //确保dispatchLayoutStep1()还未被执行过 mState.assertLayoutStep(State.STEP_START); //... //1、处理Adapter数据更新的问题，计算需要运行的动画类型 processAdapterUpdatesAndSetAnimationFlags(); //2、存储关于View的一些状态和信息 //... //3、 如果有必要，会进行预言性的布局，并且保存相关信息。 if (mState.mRunSimpleAnimations) &#123; //... &#125; if(mState.mRunPredictiveAnimations)&#123; //... &#125; //更新mLayoutStep的值，进入布局步骤 mState.mLayoutStep = State.STEP_LAYOUT;&#125; 省略了很多东西，dispatchLayoutStep1()主要是来存储当前子View的状态并确定是否要执行动画、如果过有必要，会进行预言性的布局，并且保存相关信息，本文重点不在此，然后来看看dispatchLayoutStep2()，相关源码如下：1234567891011121314151617181920private void dispatchLayoutStep2() &#123; //方法执行期间不能要求RequestLayout() startInterceptRequestLayout(); //确保已经执行了dispatchLayoutStep1()或dispatchLayoutStep2(), 从这里可以看出dispatchLayoutStep2()可能会被多次执行 mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); //1、设置好初始状态 mAdapterHelper.consumeUpdatesInOnePass(); mState.mItemCount = mAdapter.getItemCount(); mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; mState.mInPreLayout = false; //2、调用布局管理器去布局（布局核心方法） mLayout.onLayoutChildren(mRecycler, mState)； // 动画相关状态 mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null; //更新mLayoutStep值，进入动画步骤 mState.mLayoutStep = State.STEP_ANIMATIONS; stopInterceptRequestLayout(false);&#125; dispatchLayoutStep2()大部分源码都在此，它才是本文的重点，它在里面调用 mLayout.onLayoutChildren(）将布局的具体策略交给了LayoutManager，下面我们会重点分析这个函数，最后我们再来看看dispatchLayoutStep3()，相关源码如下：12345678910111213141516private void dispatchLayoutStep3() &#123; //确保已经执行dispatchLayoutStep2() mState.assertLayoutStep(State.STEP_ANIMATIONS); //... //重置mLayoutStep的值 mState.mLayoutStep = State.STEP_START; //1、触发动画 if(mState.mRunSimpleAnimations)&#123; //... &#125; //2、保存View的一些信息 //... //3、清除状态和清除无用的信息 mViewInfoStore.clear() //...&#125; 省略了大量代码，dispatchLayoutStep3()同样跟动画相关，它主要保存关于Views的所有信息、触发动画、做必要的清理操作，它也不是本文的重点。可以看到mLayoutStep与dispatchLayoutStep()对应关系如下：123STEP_START --&gt; dispatchLayoutStep1()STEP_LAYOUT --&gt; dispatchLayoutStep2()STEP_ANIMATIONS --&gt; dispatchLayoutStep2(), dispatchLayoutStep3() 讲完3个步骤我们在回到RecyclerView.dispatchLayout()，RecyclerView的布局入口OnLayout()会执行dispatchLayout()，dispatchLayout（）会根据RecyclerView的布局步骤执行dispatchLayoutStep1、2、3。那么为什么dispatchLayout（）中会分2.1, 2.2, 2.3条件执行dispatchLayoutStep1、2，而不直接按顺序dispatchLayoutStep1、2、3执行布局流程？这是因为在RecyclerView的onMeasure中，dispatchLayoutStep1、2就已经有可能因为RecyclerView自动测量模式中由于测量出来的宽高不精确而被调用，相应代码如下：123456789101112131415161718192021222324252627282930protected void onMeasure(int widthSpec, int heightSpec) &#123; //... //设置了layoutaManager后，layoutaManager默认开启自动测量模式 if (mLayout.isAutoMeasureEnabled()) &#123; final int widthMode = MeasureSpec.getMode(widthSpec); final int heightMode = MeasureSpec.getMode(heightSpec); //首先执行LayoutManager的onMeasure方法,里面会调用RecyclerView的onMeasure方法测量自身width和height mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); //Measure过后检查RecyclerView的width和height是否是精确值 final boolean measureSpecModeIsExactly = widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY; //如果RecyclerView的width和height是精确值，就跳过下面步骤 if (measureSpecModeIsExactly || mAdapter == null) &#123; return; &#125; //如果RecyclerView的width和height不是精确值，则会进行下面步骤 //1、dispatchLayoutStep1()还未被执行过，执行 dispatchLayoutStep1() if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); &#125; mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; //2、执行dispatchLayoutStep2()进行布局 dispatchLayoutStep2(); //3、布局过程结束，该方法里面会根据childView中的边界信息计算并设置RecyclerView长宽的测量值 mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); //下面省略一些代码，下面还会再次检查，如果RecyclerView的宽高还不是精确值或至少有一个childView的宽高还不是精确值，还会再次执行执行dispatchLayoutStep2()进行布局 //... &#125; //...&#125; RecyclerView是一个ViewGroup，如果自身的宽高设置了warp_content必须先调用dispatchLayoutStep2()布局childView后才能测量出准确宽高。所以我们再看回dispatchLayout()中的3个判断: dispatchLayout()中2.1条件：如果mLayoutStep == State.STEP_START，证明OnMeasure中还没有进行过布局，如果mLayoutStep ！= State.STEP_START，证明OnMeasure中进行过布局了，直接跳到2.3条件，不用重复布局，直接使用直接使用之前数据设置RecyclerView的宽高为精确模式。 dispatchLayout()中2.2条件：2.1条件不成立时为什么直接跳到2.3条件不到2.2条件，因为上述条件基于RecyclerView正常的测量布局绘制到呈现在屏幕的过程，如果在这之后你对RecyclerView调用了notifXX函数，就会造成数据变化从而要求重新布局（requestLayout()函数调用），此时2.2条件就会成立，RecyclerView会调用dispatchLayoutStep2()重新布局。 dispatchLayout()中2.3条件：2.1条件中分析过了。 3个判断后，最终一定会调用dispatchLayoutStep3()。至此分析完RecyclerView的onLayout()。 RecyclerView.dispatchLayoutStep2() -&gt; LayoutManager.onLayoutChildren（）RecyclerView真正布局的进行就是在LayoutManager.onLayoutChildren（）中进行，LayoutManager的onLayoutChildren()的实现在LayoutManager的三个子类中：LinearLayoutManager、GridLayoutManager、StaggeredGridLayoutMnager，分别对应3种不同的布局样式。这里以LinearLayoutManager中的实现为例，下面是该函数在LinearLayoutManager实现中的相关源码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//源码很长，这里先抛出它的主要步骤：//1、通过检查childView和其他变量，找出锚点的坐标（coordinate）和位置（position），并把锚点信息设置到AnchorInfo//2、根据锚点向俩边填充//这里还讲一下下面出现End和Start的方法或字段的意思：//如果LinearLayoutManager的Orientation是VERTICAL方向，End指屏幕的最下面（即Bottom），Start指屏幕的最上面(即Top)//如果LinearLayoutManager的Orientation是HORIZONTAL方向，End指屏幕的最左边（即Left），Start指屏幕的最右边(即Right)public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; //... //解析布局方向，设置mShouldReverseLayout的值，它是一个Boolean类型，false表示LinearLayoutManager的Orientation是VERTICAL方向或者LinearLayoutManager的Orientation是HORIZONTAL方向并且你在manifest中没有设置RTL布局，true表示LinearLayoutManager的Orientation是HORIZONTAL方向并且你在manifest中设置了RTL布局 resolveShouldLayoutReverse(); //... //根据mStackFromEnd（表示从End开始填充itemView，默认是false）和mShouldReverseLayout决定mLayoutFromEnd的值，mLayoutFromEnd表示itemView从End开始布局还是从Start开始布局，从Start开始布局为false 从End开始布局是为true，这里一般都为false，即从Start到End开始布局 mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd; //1、计算AnchorInfo的信息，即找出锚点的position和coordinate updateAnchorInfoForLayout(recycler, state, mAnchorInfo); //... //从End到Start开始布局，这里省略不讲，原理和从Start到End开始布局一样 if (mAnchorInfo.mLayoutFromEnd) &#123; //... //这里我们只讨论从Start到End开始布局 &#125;else&#123; //更新LayoutState，确定从锚点到RecyclerView底部有多少可用空间 updateLayoutStateToFillEnd(mAnchorInfo); mLayoutState.mExtra = extraForEnd; //2.1、第一次填充itemView，从锚点向底部填充 fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; final int lastElement = mLayoutState.mCurrentPosition; if (mLayoutState.mAvailable &gt; 0) &#123; extraForStart += mLayoutState.mAvailable; &#125; //更新LayoutState，确定从锚点到RecyclerView顶部有多少可用空间 updateLayoutStateToFillStart(mAnchorInfo); mLayoutState.mExtra = extraForStart; mLayoutState.mCurrentPosition += mLayoutState.mItemDirection; //2.2、第二次填充itemView，从锚点向顶部填充 fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; //如果屏幕上还有剩余的空间 if (mLayoutState.mAvailable &gt; 0) &#123; extraForEnd = mLayoutState.mAvailable; updateLayoutStateToFillEnd(lastElement, endOffset); mLayoutState.mExtra = extraForEnd; fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; &#125; &#125; //...&#125; onLayoutChildren方法有接近200行代码，但怎么也逃不出注释的2步，首先确定锚点（大部分情况下锚点就是RecyclerView上的itemView），并设置锚点的信息AnchorInfo。它定义在LinearLayoutManager中，有几个关键的属性：1234567 static class AnchorInfo &#123; OrientationHelper mOrientationHelper;//根据LinearLayoutManager的布局方向来测量itemView位置信息的帮助类，当你调用LinearLayoutManager的setOrientation(int orientation)方法时，LinearLayoutManager会根据不同orientation创建不同的OrientationHelper实现并设置给mOrientation属性 int mPosition;//锚点在Adapter中的索引位置 int mCoordinate;//锚点相对于LinearLayoutManager的布局方向在屏幕上的坐标，如果是VERTICAL方向，代表y轴偏移量，如果是HORIZONTAL方向，代表x轴偏移量 boolean mLayoutFromEnd;//上面解释过了 //...&#125; 那么它是怎么确定锚点信息的？我们来看注释1 updateAnchorInfoForLayout方法的源码：1234567891011121314private void updateAnchorInfoForLayout(RecyclerView.Recycler recycler, RecyclerView.State state, AnchorInfo anchorInfo) &#123; //1、如果屏幕上有itemView并且RecyclerView要滚动到某个itemView，则以这个itemView为锚点 if (updateAnchorFromPendingData(state, anchorInfo)) &#123; return; &#125; //2、如果屏幕上有itemView,则根据anchorInfo.mLayoutFromEnd找出最接近End或Start位置的itemView为锚点 if (updateAnchorFromChildren(recycler, state, anchorInfo)) &#123; return; &#125; //3、如果屏幕上没有itemView，则根据anchorInfo.mLayoutFromEnd和RecyclerView的padding来决定锚点coordinate和mStackFormEnd决定锚点的position anchorInfo.assignCoordinateFromPadding(); anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - 1 : 0;&#125; 对于里面的俩个updataAnchorFormXX函数就不展开了，对于情况1一般是我们滚动了RecyclerView的itemView或调用了RecyclerView的scrolltoXX函数，对于情况2一般是我们itemView已经加载到屏幕上了并且此时我们调用notifiXX函数来刷新或增删itemView，而情况3就是我们现在讨论的情况，RecyclerView加载到屏幕上，此时还没有布局itemView。我们点进AnchorInfo的assignCoordinateFromPadding()看看干了什么，相关源码如下：1234567891011 void assignCoordinateFromPadding() &#123; mCoordinate = mLayoutFromEnd ? mOrientationHelper.getEndAfterPadding() : mOrientationHelper.getStartAfterPadding();&#125; //下面只给出LinearLayoutManager的Orientation为VERTICAL方向的实现public int getEndAfterPadding() &#123; return mLayoutManager.getHeight() - mLayoutManager.getPaddingBottom();&#125; public int getStartAfterPadding() &#123; return mLayoutManager.getPaddingLeft();&#125; 可以看到如果此时RecyclerView中没有itemView并且LinearLayoutManager的布局方向为VERTICAL和mLayoutFromEnd值为false：anchorInfo的mCoordinate就是RecyclerView的paddingLeft，anchorInfo的position就是0（锚点为RecyclerView左上角的位置）。 我们回到onlayoutChildern方法，确定了锚点后，然后就要根据AnchorInfo开始填充itemView，在开始填充之前，LinearLayoutManager会用LayoutState暂时保存一些布局信息，它定义在LinearLayoutManager中，有几个关键属性：123456789static class LayoutState &#123; int mAvailable;//表示当前的布局方向中，RecyclerView中要用于填充itemView的可用空间大小 int mOffset;//表示当前的布局方向中，在RecyclerView中距离锚点的位置偏移量 int mExtra = 0;//表示自己设置的额外布局的范围，一般不会设置 int mLayoutDirection;//表示布局往哪个方向填充，俩个取值：LAYOUT_START为向RecyclerView顶部，LAYOUT_END为向底部 int mCurrentPosition;//表示当前锚点在Adapter中的索引，可用它获得下一个itemView的索引 int mItemDirection;//决定由mCurrentPosition获得下一个itemView的索引时是+1还是-1，俩个取值：ITEM_DIRECTION_HEAD表示索引-1，ITEM_DIRECTION_TAIL表示索引+1 //...&#125; updateLayoutStateToFillEnd函数会在向下填充前更新layoutState的值，相关源码如下：123456789101112131415161718private void updateLayoutStateToFillEnd(AnchorInfo anchorInfo) &#123; updateLayoutStateToFillEnd(anchorInfo.mPosition, anchorInfo.mCoordinate);&#125;private void updateLayoutStateToFillEnd(int itemPosition, int offset) &#123; //下面基于在当前讨论的情景中： //这里可用布局空间mLayoutState.mAvailable就是RecyclerView的高度 mLayoutState.mAvailable = mOrientationHelper.getEndAfterPadding() - offset; //这里为LayoutState.ITEM_DIRECTION_TAIL，索引+1 mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL; //当前锚点索引 mLayoutState.mCurrentPosition = itemPosition; //这里为向RecyclerView底部填充 mLayoutState.mLayoutDirection = LayoutState.LAYOUT_END; //这里offet为0 mLayoutState.mOffset = offset;&#125; 准备好layoutState后，就调用fill方法进行填充itemView，核心源码如下:12345678910111213141516171819202122232425262728293031int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) &#123; //前面讲过，表示可用布局空间大小 final int start = layoutState.mAvailable; //... // 1、计算剩余可用的填充空间，可用布局空间加上额外布局空间 int remainingSpace = layoutState.mAvailable + layoutState.mExtra; //用于记录每一次while循环的填充一个itemView后的结果 LayoutChunkResult layoutChunkResult = mLayoutChunkResult; //2、while判断条件，屏幕还有剩余可用空间并且还有数据就继续执行 while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; //重置LayoutChunkResult layoutChunkResult.resetInternal(); //3、循环调用layoutChunk方法一个一个的填充itemView，里面会根据LinearLayoutmanager的orientation方向布局itemView（布局子View的核心方法） layoutChunk(recycler, state, layoutState, layoutChunkResult); if (layoutChunkResult.mFinished) &#123; break; &#125; //计算填充一次itemView消耗了多少空间，或者说计算距离锚点的偏移量 layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection; //4、如果layoutChunkResult没有要求忽略这次消耗或这次布局的不是ScrapView或我们不是在做预布局，就更新可填充空间的大小 if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null || !state.isPreLayout()) &#123; layoutState.mAvailable -= layoutChunkResult.mConsumed; remainingSpace -= layoutChunkResult.mConsumed; &#125; //下面省略的是，如果是因滚动引起的布局，会通过判断滑动后view是否滑出边界决定是否回收View //... &#125; //填充完成，修改起始位置，即填充到哪个位置 return start - layoutState.mAvailable;&#125; 上面的注释很详细，大概流程就是在while循环中根据剩余可用空间不断的调用layoutChunk（）函数进行布局itemView，layoutChunk方法会在里面根据RecyclerView的缓存机制获取一个View从而把它填充到RecyclerView中去，下面继续来看layoutChunk方法相关源码：1234567891011121314151617181920212223242526272829303132333435363738394041void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; //1、获取一个View View view = layoutState.next(recycler); if (view == null) &#123; result.mFinished = true; return; &#125; RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) view.getLayoutParams(); //... //2、测量itemView measureChildWithMargins(view, 0, 0); //3、计算该itemView消耗的高度或宽度 result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view); int left, top, right, bottom; //4、按竖直方向布局，计算itemView的上下左右布局 if (mOrientation == VERTICAL) &#123; if (isLayoutRTL()) &#123; right = getWidth() - getPaddingRight(); left = right - mOrientationHelper.getDecoratedMeasurementInOther(view); &#125; else &#123; left = getPaddingLeft(); right = left + mOrientationHelper.getDecoratedMeasurementInOther(view); &#125; if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123; bottom = layoutState.mOffset; top = layoutState.mOffset - result.mConsumed; &#125; else &#123; top = layoutState.mOffset; bottom = layoutState.mOffset + result.mConsumed; &#125; //水平布局的计算方式 &#125; else &#123; //... &#125; //5、布局itemView layoutDecoratedWithMargins(view, left, top, right, bottom); //消耗可用布局空间如果itemView没有被移除或没有改变 if (params.isItemRemoved() || params.isItemChanged()) &#123; result.mIgnoreConsumed = true; &#125;&#125; 在layoutChunk方法中首先从layoutState中根据mCurrentPosition获取itemView，然后获取itemView的布局参数，并且根据布局方式(横向或纵向)计算出itemView的上下左右布局，最后调用layoutDecoratedWithMargins方法实现布局itemView，layoutDecoratedWithMargins方法定义在LayoutManger中，具体代码如下：1234567 public void layoutDecoratedWithMargins(@NonNull View child, int left, int top, int right, int bottom) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Rect insets = lp.mDecorInsets; child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,right - insets.right - lp.rightMargin, bottom - insets.bottom - lp.bottomMargin); &#125; 可以看到，只是调用了itemView的layout函数将itemView布局到具体的位置。 我们再回到onlayoutChildern方法，按照上面图一，我们已经填充了下面，但是上面是不用填充的，因为没有可用空间，所以注释2.2基本下是不会走的了。而fill towaards Start步骤和fill towards End差不多。那么为什么RecyclerView进行两次填充呢？因为RecyclerView理想的锚点如下图： 上面是RecyclerView的方向为VERTICAL的情况，当为HORIZONTAL方向的时候填充算法是不变的。但我们一般是图一的情况，从上往下填充。 总结一图胜千言，下图是LayoutManager循环布局所有的itemView。可以看到RecyclerView将布局的职责分离到LayoutManager中，使得RecyclerView更加灵活，我们也可以自定义自己的LayoutManger，实现自己想要的布局。可以看到RecyclerView具有很强大的扩展性，所以深入学习这个控件是很有必要的。能看到这里的都是有毅力的人，本文只是RecyclerView学习的第一篇，以后会继续分析RecyclerView的缓存设计。 参考资料： 《Android源码设计与分析》 RecyclerView和ListView原理 RecyclerView源码分析(三)–布局流程","tags":[{"name":"recyclerView","slug":"recyclerView","permalink":"http://yoursite.com/tags/recyclerView/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"ThreadLocal解析","date":"2019-02-21T05:55:50.000Z","path":"2019/02/21/ThreadLocal解析/","text":"前言最近在研究Android的消息机制时遇到了一个疑问:在不同线程中调用 Looper.myLooper() 为什么可以返回各自线程的 Looper 对象呢？明明我们没有传入任何线程信息，内部是如何找到当前线程对应的 Looper 对象呢？，查看源码得知是ThreadLocal的作用，通过它可以在线程的内部存储数据，本着好奇的心态，就通过源码深入的了解一下ThreadLocal的工作原理。 本文的源码是基于Android8.0 ThreadLocal概述ThreadLocal，线程本地存储区（Thread Local Storage，简称为TLS），通过它可以在指定的线程中存储数据，数据存储之后，只能在指定的线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。来看一个简单的例子：123456789101112131415161718192021222324252627282930public class Main &#123; private static ThreadLocal&lt;Integer&gt; mThreadLocal = new ThreadLocal&lt;&gt;(); private static ThreadLocal&lt;Integer&gt; mThreadLocal2 = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; //主线程 mThreadLocal.set(0); System.out.println(Thread.currentThread().getName() + \" - \" + mThreadLocal.get()); mThreadLocal2.set(1); System.out.println(Thread.currentThread().getName() + \" - \" + mThreadLocal2.get()); //子线程1 new Thread(() -&gt; &#123; mThreadLocal.set(2); System.out.println(Thread.currentThread().getName() + \" - \" + mThreadLocal.get()); &#125;).start(); //子线程2 new Thread(() -&gt; System.out.println(Thread.currentThread().getName() + \" - \" + mThreadLocal.get())).start(); &#125;&#125;/* 输出结果：*/main - 0main - 1Thread-0 - 2Thread-1 - null 上面代码中，有三个线程。对于同一个mThreadLocal，不同线程，在主线程设置mThreadLocal的值为0，在子线程1设置mThreadLocal的值2，在子线程2没有设置mThreadLocal的值，从输出结果可以看出虽然在不同线程访问的是同一个ThreadLocal对象，但通过ThreadLocal获取的值却不一样。对于不同的mThreadLocal和mThreadLocal2，同一线程，在主线程分别设置mThreadLocal的值为0，mThreadLocal2的值为1，从输出结果可以看出在同一线程中，通过不同的ThreadLocal存值，则通过相应的ThreadLocal取出的值也不一样。 这里可以提出关于ThreadLocal的俩个问题：1、ThreadLocal 是如何做到同一个对象，却维护着不同线程的数据副本呢？2、ThreadLocal是如何做到同一线程中不同 ThreadLocal 虽然共用同一个线程中的容器，但却可以相互独立运作？ 源码分析掌握了ThreadLocal的get和set方法的原理，也就掌握了ThreadLocal的工作原理。 1、ThreadLocal#get()获取当前线程TLS区域的数据，该方法的源码如下：1234567891011121314151617public T get() &#123; //1、获取当前线程 Thread t = Thread.currentThread(); //2、 以当前线程为参数，获取一个 ThreadLocalMap 对象 ThreadLocalMap map = getMap(t)； if (map != null) &#123; //3、map不为空，则以当前 ThreadLocal 对象实例作为key值，去map中取值，有找到直接返回 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; //4. map 为空或者在map中取不到值，那么走这里，返回默认初始值 return setInitialValue(); &#125; 首先获取当前线程，接着以当前线程为参数调用getMap函数，该方法源码如下:123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; getMap方法返回传进来的线程中的threadlocals字段，threadlocals是一个ThreadLocalMap对象，它就是我们上面提到的每个线程中保存数据的容器，定义如下:123456789101112131415//ThreadLocal$ThreadLocalMapstatic class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; Object value; &#125; private Entry[] table; private void set(ThreadLocal key, Object value) &#123; ... &#125; private Entry getEntry(ThreadLocal key) &#123; ... &#125;&#125; ThreadLocalMap 就是一个用于存储数据的容器类, 里面table数组就是真正的存储每个线程的数据，数组的每个元素类型就是一个具有（key-value）键值对的Entry，key对应ThreadLocal实例，value对应要存储的数据，数组的index值是以ThreadLocal实例为key根据hash算法算出来的，里面的set和getEntry方法就是存取table数组的具体算法实现，这里我们不深究，有兴趣可以自行查找资料。我们继续ThreadLocal#get方法, 调用getMap之后就的到了当前线程的数据存储容器即map： 当map不为空时，就以当前ThreadLocal实例为参数调用map.getEntry方法，该方法返回一个ThreadLocalMap.Entry对象, ThreadLocalMap在前面已经介绍过了，它里面有一个元素类型为Entry的table数组，getEntry方法就是以ThreadLocal实例作为key值，然后用key值转成table数组中的index值，返回table中的index位置的元素，而Entry又是一个具有（key-value）键值对的Entry，key对应ThreadLocal实例，value对应要存储的数据，所以e.value就返回了结果即要获取的数据。 当map为空时或者在map中找不到数据即map.getEntry返回了null，就调用setInitialValue方法返回默认初始值。该方法源码如下：1234567891011121314private T setInitialValue() &#123; //1. 获取初始值，默认返回Null，允许重写 T value = initialValue(); //2、获取当前线程并以当前线程为参数，获取一个ThreadLocalMap 对象 Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //3、当map不为空，设置初始值给map if (map != null) map.set(this, value); else//当map为空， 创建当前线程的数据存储容器map createMap(t, value); //4、返回初始值 return value; &#125; setInitialValue方法返回初始值，第一步调用initialValue()，方法源码如下:123protected T initialValue() &#123; return null; &#125; 可以看到默认返回null，但是该方法可以继承自ThreadLocal并重写它返回你想要的初始值。第二步获取当前线程并以当前线程为参数，获取一个ThreadLocalMap 对象，与上面分析get方法时的1、2步骤一样，就不再复述。第三步同样判断map是否为空: 当map不为空时，以当前ThreadLocal实例为key，initialvalue方法获取到的初始值为value，将（key - value）值保存到map中。 当map为空时，就调用createMap方法， ThreadLocal 中的 createMap() 方法就是对当前Thread 中的 threadLocals成员变量赋值，该方法源码如下:1234//以当前ThreadLocal实例对象为key，存值void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; Thread 中的 threadLocal 成员变量初始值为 null，并且在 Thread 类中没有任何赋值的地方，只有在 ThreadLocal 中的 createMap() 方法中对其赋值，而调用 createMap() 的地方就两个：set() 和 setInitialValue()，而调用 setInitialValue() 方法的地方只有 get()。可以看到这里的赋值就是new一个ThreadLocalMap对象,以当前ThreadLocal实例对象为key，存值。 到此，get方法就已经讲完了，我们现在可以回答上面俩个问题： 问题1: ThreadLocal 是如何做到同一个对象，却维护着不同线程的数据副本呢？原来，这些数据本来就是存储在各自线程中了，ThreadLocal 的 get() 方法内部其实会先去获取当前的线程对象，然后直接将线程存储数据的容器(ThreadLocalMap)取出来，如果为空就会先创建并将初始值和当前 ThreadLocal 对象绑定存储进去，这样不同线程即使调用了同一 ThreadLocal 对象的get方法，取的数据也是各自线程的数据副本，这样自然就可以达到维护不同线程各自相互独立的数据副本，且以线程为作用域的效果了。 问题2:ThreadLocal是如何做到同一线程中不同 ThreadLocal 虽然共用同一个线程中的容器，但却可以相互独立运作？ 原来，ThreadLocal 的 get() 方法内部根据线程取出map后，当map不为空时，会根据ThreadLocal实例去map中查找value，换句话说，在将数据存储到线程的容器map中是以当前 ThreadLocal 对象实例为 key 存储，这样，即使在同一线程中调用了不同的 ThreadLocal 对象的 get() 方法，所获取到的数据也是不同的，达到同一线程中不同 ThreadLocal 虽然共用一个容器，但却可以相互独立运作的效果。 2、ThreadLocal#set(T value)将value存储到当前线程的TLS区域。在上面的get方法中，ThreadLocal会根据线程取出线程的容器，然后再根据key（ThreadLocal实例）去容器中取值，如果取不到值，就会返回初始值，初始值默认是null，那是因为ThreadLocal要调用set方法后，容器中才有我们想要的值，ThreadLocal#set方法的源码如下:123456789101112public void set(T value) &#123; //1. 取当前线程对象 Thread t = Thread.currentThread(); //2. 取当前线程的数据存储容器 ThreadLocalMap map = getMap(t); if (map != null) //3. 如果map不为空，以当前ThreadLocal实例对象为key，存值 map.set(this, value); else //4. 如果map为空，新建一个当前线程的数据存储容器 createMap(t, value); &#125; set方法中的步骤在get方法中已经分析过了，所以读者在看到set方法时是不是感觉似曾相识，get和set两个方法内部会自动根据当前线程选择相对应的容器存取。 ThreadLocal应用场景一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal。 总结从get和set方法中都可以看出，它们所操作的对象都是当前线程中的容器ThreadLocalMap，所以在不同线程中访问同一个ThreadLocal的get和set方法，它们对ThreadLocal所做的读写操作仅限与线程内部。一句话总结ThreadLocal原理:不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程取出一个容器ThreadLocalMap，然后再从容器中根据当前ThreadLocal的实例去查找对应的value值，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不干扰，在同一线程中不同 ThreadLocal 虽然共用同一个线程中的容器，但却可以相互独立运作。 参考资料: 《Android开发艺术探索》","tags":[{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://yoursite.com/tags/ThreadLocal/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"Android消息机制native层","date":"2019-02-21T05:51:51.000Z","path":"2019/02/21/Android消息机制native层/","text":"前言在Android消息机制（java层）中讲到MessaeQueue是Android消息机制的Java层和native层的连接纽带，Android的java层和native层通过JNI调用打通，MessageQueue中有多个native方法，java层和native各有一套消息机制，实现不一样，本文讲解native层的Android消息机制。 本文基于Android8.0，相关源码文件如下: frameworks/base/core/jni/android_os_MessageQueue.cpp frameworks/base/core/jni/android_os_MessageQueue.h system/core/libutils/Looper.cpp system/core/libutils/Looper.h native层消息机制架构图 MessageQueue — 里面有一个Looper。 NativeMessageQueue — MessageQueue的继承类，见名知意，native层的消息队列，只是一个代理类，其大部分方法操作都转交给Looper的方法。 Looper — native层的Looper，其功能相当于java层的Handler，它可以取出消息，发送消息，处理消息。 MessageHandler — 消息处理类，Looper把处理消息逻辑转交给此类。 WeakMessageHanlder — MessageHandler的继承类，也是处理消息类，但最终还会把消息处理逻辑转交给MessageHandler。 java层的MessageQueue要讲解native层的消息机制，我们可以从java层消息机制调用到的MessageQueue的native方法讲起，MessageQueue中所有的native方法如下:123456789public final class MessageQueue &#123; private native static long nativeInit(); private native static void nativeDestroy(long ptr); private native void nativePollOnce(long ptr, int timeoutMillis); private native static void nativeWake(long ptr); private native static boolean nativeIsPolling(long ptr); private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events); //...&#125; 我们主要讲解三个：nativeInit()， nativePollOnce(long ptr, int timeoutMillis)， nativeWake(long ptr)。 1、MessageQueue#nativeInit()在java层中，MessageQueue是在Looper中创建的，在MessageQueue的构造中:12345//MessageQueue.java MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit(); &#125; 在java层中，mPtr保存了nativeInit()返回的值，nativeInit方法的实现在android_os_MessageQueue.cpp文件中的android_os_MessageQueue_nativeInit方法中，该方法源码如下:123456789static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; //创建native消息队列NativeMessageQueue NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); //... //增加引用计数 nativeMessageQueue-&gt;incStrong(env); //使用C++强制类型转换符reinterpret_cast把NativeMessageQueue指针强转成long类型并返回到java层 return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 可以看到在android_os_MessageQueue_nativeInit方法中会创建一个NativeMessageQueue对象，并增加其引用计数，并将NativeMessageQueue指针mPtr保存在Java层的MessageQueue中。现在我们来看NativeMessageQueue的构造函数, 如下:1234567891011NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; //获取TLS中的Looper(Looper::getForThread相当于java层的Looper.mLooper中的ThreadLocal.get) mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; //创建native层的Looper mLooper = new Looper(false); //保存Looper到TLS中(Looper::setForThread相当于java层的ThreadLocal.set) Looper::setForThread(mLooper); &#125;&#125; （关于TLS更多信息可以查看ThreadLocal原理解析），在NativeMessageQueue的构造中会先调用Looper的getForThread方法从当前线程获取Looper对象，如果为空，就会创建一个Looper并调用Looper的setForThread方法设置给当前线程。也就是说Looper和MessageQueue在java层和native层都有，但它们的功能并不是一一对应，此处native层的Looper与Java层的Looper没有任何的关系，只是在native层重实现了一套类似功能的逻辑。我们来看看native层在创建Looper时做了什么，Looper的构造函数如下:12345678910Looper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false), mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false), mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123; //构造唤醒事件的fd（文件描述符） mWakeEventFd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC); //... //重建epoll事件 rebuildEpollLocked();&#125; 这里我们忽略一大堆字段赋值，只关注一个函数: rebuildEpollLocked(), 该函数核心源码如下:1234567891011121314151617181920void Looper::rebuildEpollLocked() &#123; //1、关闭旧的管道 if (mEpollFd &gt;= 0) &#123; close(mEpollFd); &#125; //2、创建新的epoll实例（文件描述符），并注册wake管道 mEpollFd = epoll_create(EPOLL_SIZE_HINT); struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); //置空eventItem //3、设置事件类型和文件描述符 eventItem.events = EPOLLIN;//可读事件 eventItem.data.fd = mWakeEventFd;//唤醒事件的fd（文件描述符） //4、将唤醒事件(mWakeEventFd)添加到epoll实例(mEpollFd)，并监听事件 int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem); //... &#125;&#125; Looper的构造函数中涉及到Linux的epoll机制，关于更多资料可以自行查找资料(有Linux基础的可以阅读源码解读epoll内核机制 )，这里简单介绍一下: epoll机制是Linux最高效的I/O复用机制, 使用一个文件描述符管理多个描述符。 epoll操作过程有3个方法，分别是: 1、int epoll_create(int size)； 用于创建一个epoll的文件描述符，size是指监听的描述符个数。 2、int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； 用于对需要监听的文件描述符(fd)执行op操作，比如将fd加入到epoll文件描述符, 参数: epfd：是epoll_create()的返回值 op：表示op操作，用三个宏来表示，分别代表添加(EPOLL_CTL_ADD)、删除(EPOLL_CTL_DEL)和修改( EPOLL_CTL_MOD)对fd的监听事件 fd：需要监听的文件描述符 epoll_event：需要监听的事件 3、int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)； 等待事件的上报, 该函数返回需要处理的事件数目，如返回0表示已超时,参数： epfd：等待epfd上的io事件，最多返回maxevents个事件； events：用来从内核得到事件的集合； maxevents：events数量，该maxevents值不能大于创建epoll_create()时的size； timeout：超时时间（毫秒，0会立即返回）。 要使用epoll机制，首先通过 epoll_create创建一个epoll专用文件描述符，并创建了一个管道，最后通过epoll_ctl函数来设置监听的事件类型为EPOLLIN（可读事件），在这里Looper对象中的mWakeEventFd(唤醒事件的文件描述符)添加到epoll监控范围内。至此，native层的MessageQueue和Looper就构建完毕，底层通过管道与epoll机制也建立了一套消息机制。 我们跟着MessageQueue#nativeInit()一路走下来，这里小结一下： 1、首先java层的Looper对象会在构造函数中创建java层的MessageQueue对象。 2、 java层的MessageQueue对象又会调用nativeInit函数初始化native层的NativeMessageQueue，NativeMessageQueue的构造函数又会创建native层的Looper，并且在Looper中通过管道与epoll机制建立一套消息机制。 3、native层构建完毕，将NativeMessageQueue对象转换为一个long类型存储到java层的MessageQueue的mPtr中。 在此之后就会在java层中启动消息循环，Looper.loop -&gt; Looper.next -&gt; MessageQueue.next -&gt;MessageQueue.nativePollOnce，下面我们来看MessageQueue#nativePollOnce()。 2、MessageQueue#nativePollOnce()在java层中每次循环去读消息时，都会调用这个函数，如下:123456789//MessageQueue.java Message next() &#123; //... for(;;)&#123; nativePollOnce(ptr, nextPollTimeoutMillis); //... &#125; //... &#125; nativePollOnce函数的实现在android_os_MessageQueue.cpp文件中的android_os_MessageQueue_nativePollOnce方法中，该方法的源码如下:123456static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; //把ptr强转为NativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; ptr是从java层传过来的mPtr的值，mPtr在初始化时保存了NativeMessageQueue的指针，此时首先把传递进来的ptr转换为NativeMessageQueue，然后调用NativeMessageQueue的pollOnce函数，该函数核心源码如下:123456void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123; //... //核心是调用了native层的Looper的pollOnce方法 mLooper-&gt;pollOnce(timeoutMillis); //...&#125; 这段代码主要就是调用了native层的Looper的pollOnce(timeoutMillis)方法，该方法会调用Looper的 pollOnce(timeoutMillis, NULL, NULL, NULL)，相关源码如下:12345678int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; for (;;) &#123; //... //处理内部轮询 result = pollInner(timeoutMillis); &#125;&#125; 该方法核心在于调用了pollInner函数，该函数相关源码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344int Looper::pollInner(int timeoutMillis) &#123; //... //事件集合，EPOLL_MAX_EVENTS为最大事件数量 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; //1、等待事件发生或者超时，从管道中读取事件 int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); //获取锁 mLock.lock(); //... Done:; //处理Native的Message，调用相应回调方法 mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); //2、判断消息的执行时间 if (messageEnvelope.uptime &lt;= now) &#123; &#123; //3、获取native层的Handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; //4、获取native层的消息 Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; //释放锁 mLock.unlock(); //5、处理消息事件 handler-&gt;handleMessage(message); &#125; //请求锁 mLock.lock(); mSendingMessage = false; // 发生回调 result = POLL_CALLBACK; &#125; else &#123; //消息还没到执行时间 mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; //释放锁 mLock.unlock(); //...&#125; pollInner函数很长，省略了一大堆代码，这里讲解一些核心的点，在此之前先讲解一下MessageEnvelope，正如其名字，信封，其结构体定义在Looper类中，如下:1234567891011121314class Looper : public RefBase &#123; struct MessageEnvelope &#123; MessageEnvelope() : uptime(0) &#123; &#125; MessageEnvelope(nsecs_t u, const sp&lt;MessageHandler&gt; h, const Message&amp; m) : uptime(u), handler(h), message(m) &#123; &#125; nsecs_t uptime; sp&lt;MessageHandler&gt; handler; Message message; &#125;; //...&#125; MessageEnvelope里面记录着收信人（handler，MessageHandler类型，是一个消息处理类），发信时间(uptime)，信件内容(message，Message类型)。Message结构体，消息处理类，Looper类都定义在Looper.h/ Looper.cpp文件中。pollInner函数的流程如下： 1、先调用epoll_wait()，这是阻塞方法，从管道取到事件或等待超时都会返回。 2、进入Done标记位的代码段, 处理Native的Message，调用Native 的Handler来处理该Message。 pollInner实际上就是从管道中读取事件，并且处理这些事件。在native中事件存储在管道中，而在java层中事件存储在消息链表中，但这俩个层次的事件都通过java层的Looper消息循环进行不断的获取，处理等操作。 我们更着MessageQueue#nativePollOnce()一路走下来，小结一下： 1、当在java层通过Looper启动消息循环后，就会走到MessageQueue的nativePollOnce方法，在该方法native实现中，会把保存在java层的mPtr再转换为NativeMessageQueue。 2、然后调用NativeMessageQueue的pollOnce方法，该方法中最终会调用native层的Looper的pollInner方法，Looper的pollInner方法是阻塞方法，等从管道取到事件或超时就会返回，并通过native层的Handler处理native层的Message消息。 3、处理完native层消息后，又会返回到java层处理java层的消息。 可以看到，native层的NativeMessageQueue实际上并没有做什么实际工作，只是把操作转发给native层的Looper，而native层的Looper则扮演了java层的Handle角色，它可以取出，发送，处理消息。 3、MessageQueue#nativeWake()nativeWake()用于唤醒功能，我们在Java层通过Hanlder发送消息时，实际是把消息添加到消息队列，会调用到MessageQueue的enqueueMessage方法, 该方法中会调用到nativeWake方法，如下：12345678910//MessageQueue.java boolean enqueueMessage(Message msg, long when) &#123; //... synchronized (this) &#123; //... if (needWake) &#123; nativeWake(mPtr); &#125; &#125; &#125; 或者把消息从消息队列中全部移除，调用MessageQueue的quit方法，在有需要时都会调用nativeWake方法。MessageQueue的nativeWake方法的实现在android_os_MessageQueue.cpp文件中的android_os_MessageQueue_nativeWake方法中，该方法的源码如下: 1234 static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;wake();&#125; 可以看到，步骤和上面讲的差不多，首先把传递进来的ptr转换为NativeMessageQueue，然后调用NativeMessageQueue的wake函数，该函数源码如下: 123 void NativeMessageQueue::wake() &#123; mLooper-&gt;wake();&#125; 前面说过在native层中NativeMessageQueue只是一个代理Looper的角色，该方法把操作转发给native层的Looper，Looper的wake方法核心源码如下:12345void Looper::wake() &#123; uint64_t inc = 1; //通过write函数向管道mWakeEventFd写入字符inc ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t))); //... 其中TEMP_FAILURE_RETRY 是一个宏定义， 当执行write失败后，会不断重复执行，直到执行成功为止。Looper的wake方法就是向管道mWakeEventfd写入字符。 我们跟着MessageQueue#nativeWake一路走下来，小结一下： 1、在java层插入消息到消息队列后，就会根据需要判断是否要调用nativeWake方法，如果调用，就转到2。 2、在nativeWake方法native实现中，会把保存在java层的mPtr再转换为NativeMessageQueue，然后调用NativeMessageQueue的wake方法，最终调用Looper的wake方法。 3、前面讲到Looper::pollInner方法是一个阻塞操作，当管道中没有事件时当前线程就会进入等待，当管道有事件就会立即返回，从管道中读取事件并处理。而Looper::wake方法就是一个唤醒操作，它就是通过前面创建的唤醒事件文件描述符mWakeEventFd来往管道中写入内容，这时另外等待管道事件的线程就会被唤醒。 总结Java层和Native层的MessageQueue通过JNI建立关联，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理native层消息。Handler/Looper/Message这三大类Java层与Native层并没有任何的真正关联，只是分别在Java层和Native层的handler消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑。另外，消息处理流程是先处理Native Message，最后处理Java Message。 参考资料： 《Android源码设计与分析》 Android消息机制2-Handler(Native层)","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"handler","slug":"handler","permalink":"http://yoursite.com/tags/handler/"}]},{"title":"Android消息机制java层","date":"2019-02-21T05:33:11.000Z","path":"2019/02/21/Android消息机制java层/","text":"前言Android的消息机制用于同进程的线程间通信，它是由MessageQueue，Message，Looper，Handler共同组成。Android中有大量的交互都是通过消息机制，比如Android的四大组件的启动过程的交互就离不开消息机制，所以Android在某种意义上也可以说成是一个以消息驱动的系统。 本文源码基于Android8.0，源码相关位置: frameworks/base/core/java/android/os/MessageQueue.java frameworks/base/core/java/android/os/Handler.java frameworks/base/core/java/android/os/Looper.java frameworks/base/core/java/android/os/Message.java 消息机制概述Android应用的每个事件都会转化为一个系统消息即Message，消息中包含了事件的相关信息和消息的处理人即Handler，消息要通过Handler发送，最终被投递到一个消息队列中即MessageQueue，它维护了一个待处理的消息列表，然后通过Looper开启了一个消息循环不断地从这个队列中取出消息，当从消息队列取出一个消息后，Looper根据消息的处理人（target）将此消息分发给相应的Handle处理。它们的工作原理就像工厂的生产线，Looper是发动机，MessageQueue是传送带，Handler是工人，Message则是待处理的产品。整个过程如下图所示。 消息机制架构图 Looper — 是每个线程的MessageQueue管家，里面有一个MessageQueue消息队列，负责把消息从MessageQueue中取出并把消息传递到Handler中去，每个线程只有一个Looper。 MessageQueue — 消息队列，有一组待处理的Message，主要用于存放所有通过Handler发送的消息，每个线程只有一个MessageQueue。 Message — 是线程之间传递的消息，里面有一个用于处理消息的Handler。 Handler — 主要用于发送和处理消息，里面有Looper和MessageQueue。 深入了解Android的消息机制1、 Looper的创建，Handler与Looper的关联我们知道Android应用程序的入口实际上是ActivityThread.main方法，在该方法中首先会创建Application和默认启动的Activity，并将它们关联在一起，而该应用的UI线程的消息循环也是在这个方法中创建，具体源码如下：12345678public static void main(String[] args) &#123; //... //1、创建UI线程的消息循环Looper Looper.prepareMainLooper(); //... //2、执行消息循环 Looper.loop();&#125; 执行ActivityThread.main后，应用程序就启动了，UI的消息循环也在Looper.loop（）中启动，此后Looper会一直从消息队列中取出消息，用户或系统通过Handler不断往消息队列中添加消息，这些消息不断的被取出，处理，回收，使得应用运转起来。Android应用程序的Handler在ActivityThread中被创建，如下：123456789101112131415161718final H mH = new H();//H定义如下，里面定义了大量的字段，跟Activity的启动，Application的绑定等有关class H extends Handler &#123; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; public static final int CREATE_SERVICE = 114; //.... public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case BIND_APPLICATION: //... case EXIT_APPLICATION: //... case CREATE_SERVICE: //... //... &#125; //... 在开发中，我们在子线程中执行完操作后通常需要更新UI，但我们都知道不能在子线程中更新UI，此时我们就要通过Handler将一个消息post到UI线程中，然后再在Handler中的handleMessage（）中进行处理，在这里要注意的是如果我们不传递UI线程所属的Looper去创建Handler，那么该Handler必须在主线程中创建，如下：1234567891011121314//在主线程中创建Handler Handler mHandler = new Handler（）&#123; @Override public void handleMessage(Message msg)&#123; //更新UI &#125;&#125;//在子线程中进行耗时操作new Thread（）&#123; public void run()&#123; mHandler.sendEmptyMessage(0); &#125;&#125; 如果不这样做将会抛出一个异常”Can’t create handler inside threadxx that has not called Looper.prepare()”, 为什么会这样呢？看异常描述是我们没有调用Looper.prepare()，那么问题又来了，为什么在主线程中创建Handler时我们没有手动调用Looper.prepare()不会抛异常，而在子线程创建Handler时没有调用Looper.prepare()就会抛异常？这里我们先从Handler的默认构造函数看起，源码如下：1234567891011121314151617 public Handler() &#123; this(null, false);&#125;public Handler(Callback callback, boolean async) &#123; //... //与Looper关联 mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); &#125; //通过Looper获取MessageQueue mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 可以看到，Handler构造中会和Looper关联，如果通过Looper.myLooper()获取不到Looper，就会抛出上述所讲的异常，然后再通过Looper获取它持有的MessageQueue。我们继续点进myLooper()中看它如何工作，如下：1234public static @Nullable Looper myLooper() &#123; //获取当前线程TLS区域的Looper return sThreadLocal.get();&#125; 可以看到myLooper方法是通过ThreadLocal获取的，这里简单介绍一下ThreadLocal（关于ThreadLocal更多信息可以查看ThreadLocal原理解析）: ThreadLocal： 线程本地存储区（Thread Local Storage，简称为TLS），每 个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。 它的常用操作方法有： ThreadLocal.set(T value)：将value存储到当前线程的TLS区域。 ThreadLocal.get()：获取当前线程TLS区域的数据 ThreadLocal的get()和set()方法操作的类型都是泛型，接着回到前面提到的sThreadLocal变量，其在Looper中定义如下：1static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); 可见sThreadLocal的get()和set()操作的类型都是Looper类型,也就是说每个线程只能有一个Looper，不同线程的Looper是不相同的。那么Looper是什么时候被set到ThreadLocal中的？其实答案就在上面写到的ActivityThread.main方法中的Looper.perpareMainLooper中，相关源码如下：12345678910111213141516171819202122232425262728 public static void prepareMainLooper() &#123; //设置不允许退出的Looper prepare(false); synchronized (Looper.class) &#123; //将当前的Looper保存为主Looper，每个线程只允许执行一次。 if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125; &#125; //quitAllowed表示是否允许Looper运行时退出private static void prepare(boolean quitAllowed)&#123; //Looper.prepare()只能执行一次 if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; //把Looper保存到TLS中 sThreadLocal.set(new Looper(quitAllowed));&#125;//Looper的构造函数 private Looper(boolean quitAllowed) &#123; //可以看到MessageQueue是在Looper中创建的 mQueue = new MessageQueue(quitAllowed); //... &#125; 我们再回到Handler中来，Looper属于某个线程，MessageQueue存储在Looper中，MessageQueue则通过Looper与特定的线程关联上，而Handler在构造中又与Looper和MessageQueue关联，所以最终通过Handler发送的消息就会被执行到这个线程上。同时因为应用程序启动时在ActivityThread.main方法中的Looper.prepareMainLooper()中已经调用了Looper.prepare(),所以在主线程中创建Handler无需我们手动调用Looper.prepare()，而在子线程中，如果我们不传递UI线程所属的Looper去创建Handler，那么就需要调用Looper.prepare()后再创建Handle来传递消息（总的来说是因为Handler要和某个线程中的MessageQueue和Looper关联，只有调用Looper.prepare()，Looper和MessageQueue才属于某个线程）。 2、消息循环的运作在创建Looper后，通过Looper.loop()就启动了消息循环，这个函数会不断的从消息队列中取出消息、处理消息。我们点进此方法看一下它的源码：12345678910111213141516171819public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; //... for (;;) &#123; //从MessageQueue中取出消息，没有消息时会阻塞等待 Message msg = queue.next(); //next()返回了null，表示MessageQueue正在退出，即调用了Looper的quit或quitSafely方法 if (msg == null) &#123; return; &#125; //... //分发消息 msg.target.dispatchMessage(msg); //...&#125; loop()中是一个死循环，loop()会调用MessageQueue的next()来获取最新的消息，当没有消息时，next()会一直阻塞在那里，这也导致loop()阻塞，唯一跳出循环的条件是next()返回null，这时代表Looper的quit()或quitSafely()被调用，从而调用MessageQueue的quit()来通知消息队列退出。MessageQueue的next()是最关键的函数，我们来看看next函数的关键代码：12345678910111213141516171819202122232425262728293031323334353637383940Message next() &#123; //mPtr是在构造中被赋值，是指向native层的MessageQueue final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int nextPollTimeoutMillis = 0; for(;;)&#123; //1、处理native层事件，是一个阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; //java层的消息队列 Message msg = mMessages; //... if (msg != null) &#123;//有消息 //2、消息还没到触发时间 if (now &lt; msg.when) &#123; //设置下一次轮询的超时时长（等待时长） nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; mBlocked = false; //3、获取一条消息并返回 if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; //设置消息的使用状态，即flags |= FLAG_IN_US msg.markInUse(); return msg; &#125; &#125; else &#123;//没有消息 nextPollTimeoutMillis = -1; &#125; &#125; //...&#125; next函数看起来有点多代码，但这里只分析核心部分，其实MessageQueue是消息机制的Java层和C++层的连接纽带，大部分核心方法都交给native层来处理，这里的mPtr是指向native层的NativeMessageQueue对象，在MessageQueue构造中被赋值, 如下：12345MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; //通过native方法初始化消息队列，其中mPtr是供native代码使用 mPtr = nativeInit();&#125; next方法也是一个死循环，最主要的方法是nativePollOnce(),它是一个阻塞操作，其中nextPollTimeoutMillis代表下一个消息到来前，还需要等待的时长，当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去，则next方法将会一直阻塞在这里，当有新消息到来时，next方法会返回这条消息并将其从单链表中删除。可以发现虽然MessageQueue叫消息队列，但它却不是用队列实现的，而是用链表实现的。 MessageQueue是消息机制的核心类，它里面有大量的native方法，Android有俩套消息机制（java层和native层，实现不一样），但本文只讲解java层的消息机制，不会涉及到native层。 （关于native层的查看Android消息机制（native层）） 3、消息的分发如果loop方法中next()返回了null，那么就会执行到这一句” msg.target.dispatchMessage(msg)“,Looper会把这条消息交给Message的target（Handler对象）来处理, 实际上是转了一圈，Handler把消息发送给消息队列，Looper又把这个消息给Handler处理。注意：在本文的情景下，loop方法这个时候是执行在主线程的，因为Looper是在主线程中创建的，所以到了这里，消息的处理就切换到主线程了，这就是Handler线程切换的原理，Handler发送的消息的线程不处理消息，只有在Looper.loop()中将消息取出来后再进行处理，所以在Handler机制中，无论发送消息的Handler对象处于什么线程，最终处理都是运行在Looper.loop()所在线程。下面来看消息分发逻辑，dispatchMessage()源码如下： 123456789101112131415public void dispatchMessage(Message msg) &#123; //1、检查msg的callback是否为空 if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; //2、Handler的mCallback是否为空 if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; //3、我们平常处理消息的方法，该方法默认为空，Handler子类通过覆写该方法来完成具体的逻辑。 handleMessage(msg); &#125; &#125; 里面代码量很少，首先第一步，检查msg.callback是否为空，不为空则执行” handleCallback(msg)”, 源码如下:123private static void handleCallback(Message message) &#123; message.callback.run(); &#125; msg.callback其实是一个Runnable对象，当我们通过Handler来post一个Runnable消息时，它就不为空，如下：12345678910public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0); &#125;//把Runnable对象包装成Message对象private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; 可以看到，在post(Runnable r)中，会把Runnable包装成Message对象，并把Runnable设置给Message的callback字段，然后发送此消息。 如果msg.callback为空，就到第二步，检查mCallback是否为空，mCallback是一个Callback接口，定义如下：123public interface Callback &#123; public boolean handleMessage(Message msg); &#125; 当我们这样来创建Handler: Handler handler = new Handler(callback)时, mCallback就不为空，它的意义是当我们不想派生Handler的子类重写handleMessage()来处理消息时，就可以通过Callback来实现。 如果mCallback为空，就到第三步，调用Handler的handleMessage方法来处理消息。 4、消息的发送前面讲到消息的接收处理最终是在Handler中进行，而消息的发送也是通过Handler进行，消息的发送可以通过handler的一系列post方法和一系列的send方法，一系列post方法最终通过一系列send方法来实现，如图：从上图，可以发现所有的发消息方式，最终都是调用MessageQueue.enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)，该方法源码如下：1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 在该方法中，首先把Message的target字段设置为当前发送消息的Handler,然后设置Message是否是异步消息，最后把所有逻辑交给MessageQueue的enqueueMessage(Message msg, long when)方法，该方法的相应源码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243boolean enqueueMessage(Message msg, long when) &#123; //... synchronized (this) &#123; //正在退出时，回收msg，加入到消息池 if (mQuitting) &#123; //... msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; //1、取队头消息 Message p = mMessages; //2、如果p为null，则代表MessageQueue没有消息 //如果when == 0 或 when &lt; p.when, 则代表msg的触发时间是队列中最早的 //满足上述条件就把msg插入到队列头部 if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; //... &#125; else &#123; //3、如果p != null且msg并不是最早触发的 //... Message prev; //下面是一个链表的插入操作,将消息按时间顺序插入到MessageQueue for (;;) &#123; prev = p; p = p.next； if (p == null || when &lt; p.when) &#123; break; &#125; //... &#125; msg.next = p; prev.next = msg; &#125; //消息没有退出，此时mPtr != 0，native层处理逻辑 if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 这个方法主要操作就是一个链表的插入操作，MessageQueue是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，如果消息队列为空或这个消息是最早触发的，就会直接插入队头，否则会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。 5、消息的复用前面多次提到了Message，当我们通过Handler的obtainMessage()或Message的obtain()获取一个Message对象时，系统并不是每次都new一个出来，而是先从消息池中（sPool）尝试获取一个Message。Handler的obtainMessage()最终是调用了Message的obtain()。Message#obtain()的源码如下:1234567891011121314public static Message obtain() &#123; synchronized (sPoolSync) &#123; //从sPool头部取出一个Message对象返回，并把消息从链表断开（即把sPool指向下一个Message） if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0;//清除in-use flag sPoolSize--;//消息池的大小进行减1操作 return m; &#125; &#125; //消息池中没有Message，直接new一个返回 return new Message(); sPool的数据类型为Message，通过next成员变量，维护一个消息池，消息池的默认大小为50。定义如下:12345678public final class Message implements Parcelable &#123; public static final Object sPoolSync = new Object();//用于在获取Message对象时进行同步锁 private static int sPoolSize = 0;//池的大小 private static final int MAX_POOL_SIZE = 50;//池的可用大小 private static Message sPool; Message next; //...&#125; 虽然叫消息池，其实是通过链表实现的，每个Message都有一个同类型的next字段，这个next就是指向下一个可用的Message，最后一个可用的Message的next为空，这样所有可用的Message对象就通过next串成一个Message池，sPool指向池中的第一个Message。那么Message对象是什么时候被放进消息池中的呢？其实在obtain方法中创建Message对象时，并不会直接把它放到池中，而是在回收Message时把它放入池中，Message中也有类似Bitmap那样的recycler函数，如下：1234567891011121314151617181920212223242526272829303132333435public void recycle() &#123; //判断消息是否正在使用 if (isInUse()) &#123; if (gCheckRecycle) &#123;//Android 5.0以后的版本默认为true,之前的版本默认为false. throw new IllegalStateException(\"This message cannot be recycled because it \" + \"is still in use.\"); &#125; return; &#125; recycleUnchecked(); &#125; //对于不再使用的消息，加入到消息池 void recycleUnchecked() &#123; //将消息标示位置为IN_USE，并清空消息所有的参数 flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; //当消息池没有满时，将Message对象加入消息池（即把Message插入链表头部） if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++;//消息池的可用大小进行加1操作 &#125; &#125; &#125; recycler函数先判断该Message是否还在使用，如果还在使用，就会抛异常，否则就调用recyclerUnchecked函数根据MAX_POOL_SIZE判断是否把该消息回收，回收前还要先清空该消息的各个字段，回收消息就是把自身插入到链表表头。 通过消息的复用，减少Message对象不断创建与销毁的过程，提升了效率。 结语能看到这里的，证明你已经了解了java层的消息机制是如何运作的了，本文从Android应用UI线程消息循环的创建出发，通过讲解Looper与Handler的关联，如何启动消息循环，消息的发送与分发，还有消息的复用来讲解了Message，Handler，MessageQueue，Looper之间是如何配合工作。掌握了这些，在以后开发中又能更加随心所欲了。 参考资料： 《Android开发艺术探索》 《Android源码设计与分析》 Android消息机制1-Handler(java层)","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"handler","slug":"handler","permalink":"http://yoursite.com/tags/handler/"}]},{"title":"Http网络请求浅析","date":"2018-12-31T07:33:15.000Z","path":"2018/12/31/Http网络请求浅析/","text":"前言随着互联网的发展，网络已经越来越普及了，绝大多数的网络请求都是基于HTTP协议的，因此在开发中，了解HTTP的基本原理是必要的，在TCP/IP四层体系结构中，HTTP协议位于应用层，它是应用层主要使用的协议，应用层往下一层就是运输层，HTTP在运输层采用的是TCP协议来保证可靠传输，知道这些后，接下来详细介绍一下 Http。 HTTP协议版本我们先来简单了解一下 HTTP 协议的历史演变： HTTP/1.0：1996年，HTTP/1.0 版本发布，可以传输文字，图像、视频、二进制文件，它的特点是每次请求都需要建立一个单独的TCP连接，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接，上一次请求和下一次请求完全分离，这种非持续连接过程又叫做短连接。它的特点也是它的缺点，客户端和服务端每次请求都要建立TCP连接，而建立TCP连接和关闭TCP连接都是相对比较费时的过程，严重影响客户端和服务端的性能。 HTTP/1.1：1997年，HTTP/1.1 版本发布，1999年广泛应用于各大浏览器网络请求中，直到现在HTTP/1.1也是使用最为广泛的HTTP协议，它进一步完善了HTTP/1.0，HTTP/1.1支持在一个TCP连接上传送多个HTTP请求和响应，即一个TCP连接可以被多个请求复用，减少了建立和关闭连接的消耗延迟，一定程度上弥补了HTTP/1.0每次请求都要创建连接的缺点，这种持续连接过程又叫做长连接，HTTP/1.1默认使用长连接。 HTTP/2.0：2015年，HTTP/2 .0版本发布，前面的两个版本都是基于超文本的协议，HTTP 2.0把基于超文本的协议改成了基于二进制的，把HTTP请求和响应变成数据帧，这样就实现了多路复用，在一个TCP连接上可以同时“混合”发送多个HTTP的请求和响应，效率大大提高。 1、长连接和多路复用的区别上面讲到HTTP/1.1的长连接和HTTP 2.0的多路复用都是复用TCP连接，它们之间有什么区别呢？如图： 可以看到，HTTP/1.1的长连接的若干个请求只能排队发送，后面的请求等待前面请求的响应返回才能获得执行机会，一旦有某请求超时，后续请求只能被阻塞，这就是人们常说的线头阻塞；同时由于浏览器自身的Max-Connection最大连接限制，导致同一个域名 (host) 下的请求连接限制，比如谷歌浏览器的Max-Connection值为6，即同一个域名下一次最多连续发送6个请求，超过限制后续请求就会被阻塞。 而HTTP/2.0的多路复用才是做到了同一个域名下的真正的并发请求，多个请求可同时在一个TCP连接上并行发送，某个请求任务超时，不会影响到其它连接的正常执行。 2、HTTPS是什么HTTPS就是在HTTP的应用层与运输层之间加了一层SSL/TLS，如下： HTTP协议运行在TCP之上，所有传输的内容都是明文；HTTPS协议运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都通过SSL/TLS层进行了加密，保证了数据安全。目前大多数网站都运行在HTTPS协议之上，把HTTP报文经过加密后才发送出去，在接收到HTTP报文后经过解密才能使用。 由于HTTP/2.0还未大规模应用，所以下面的讨论都是围绕HTTP/1.x，只有熟悉HTTP/1.x的原理，才能更好的读懂HTTP/2.0。 HTTP工作过程HTTP是基于TCP的应用层协议，从更高层次封装了TCP的使用细节，使得网络操作更为简单，一个HTTP请求就是一个典型的C/S模式，HTTP协议首先要和服务器建立TCP连接，当建立TCP连接的三报文握手的前两次报文握手完成后，在第三次握手，客户端就把HTTP请求报文作为第三个握手报文的数据发送给服务端，服务器收到请求报文后，就把所请求的文档作为响应报文返回给客户端。 HTTP的工作特点可以总结为以下两点： 1、面向无连接的：即通信双方在交换HTTP报文时不需要向建立HTTP连接，但HTTP使用了面向连接的TCP作为运输层协议。 2、无状态的：服务器不会记得每个客户访问的状态，同一个客户访问两次服务器上的页面时，服务器响应与第一次访问相同，所以出现了Cookie/Session机制维护连接的状态，可自行了解。 HTTP的请求方式HTTP协议提供了几种请求方式，大家熟知的请求方式有7种GET、POST、DELETE、PUT、HEAD、TRACE、OPTIONS，其中最常用的是PUT（增）、DELETE(删)、POST（改）、GET（查）。下面以一张表来看看它们各自的作用。 请求 作用 CET 客户端获取服务器中的某个资源，然后服务端返回对应资源给客户端，请求参数放在URL中 POST POST请求通常会用来提交HTML表单，把数据填在表单中，传给服务器，然后服务器对这些数据进行处理 PUT 与GET相反，PUT向服务器写入数据 DELETE 顾名思义，请服务器删除请求URL所指定的资源，但是服务端可以在客户端不知情下撤销此请求，请求参数放在URL中 HEAD HEAD与GET类似，但服务器在响应中只返回首部不会返回主体部分，HEAD是用来在不获取资源的情况下对资源的首部进行检查，如查看响应的状态码，看看资源是否被修改，对象是否存在 TRACE 客户端发起一个请求时，可能要穿过防火墙，代理，网关等，每一个中间点都会修改HTTP原始请求，TRACE允许请求最终发送给服务端时，看看它最终变成什么样，服务端会返回一个TRACE响应 OPTIONS 客户端请求Web服务器告知其支持的各种功能，就是询问服务器支持什么方法或者对某些特殊资源支持什么方法，这就让客户端不用访问那些实际的资源就能判定访问各种资源的最优方法 HTTP的报文格式用于HTTP协议交换的信息称为HTTP报文，客户端发出的HTTP报文叫做请求报文，服务端返回的HTTP报文交过响应报文，它们都是由多行数据构成的字符串文本，用CR + LF作为换行符，即回车符 + 换行符作为换行符，HTTP报文大体分为报文首部和报文主体两块，由第一个出现的空行(CR + LF)划分，如下： 1、请求报文一个HTTP的请求报文通常由请求行，请求头部，空行(CR + LF)，请求数据4个部分组成，如图： 请求行 又叫起始行，就是报文的第一行，在请求报文中说明要以什么方式做什么请求。 请求头部又叫首部字段，起始行后由零个或多个首部字段，每个字段包含一个key和value，用冒号分割（如Connection：keep-Alive），首部以一个CR + LF结束，如果再细分，首部字段又可以分为请求首部字段、通用首部字段和实体首部字段。 请求数据又叫主体，其中可以包含任意类型的数据（如图片，视频等），而首部和起始行只能是文本形式，在请求主体中包括了要发送给Web服务器的数据。 不同的请求方式，它们的请求报文格式可能有点差别的，有些请求方式它的请求数据为空，有些则不为空，但是请求行和请求头部是必须存在的，下面以GET、DELETE、PULL、POST举例： 1.1、GET、DELETE的请求报文对于GET和DELETE来说，它们的所有参数都是拼接在URL最后，第一个参数前通过”?”连接，然后请求参数按照”key=value”格式进行追加，每个请求参数之间通过”&amp;”连接，如 http://www.myhost.com/text/?id=1&amp;name=rain，如果是GET请求表示获取 http://www.myhost.com/text/ 下用户id为1，名为rain的文本，如果是DELETE请求表示删除该文本。 注意：GET和DELETE的URL最长度为1024字节（1KB） 123GET /?id=1&amp;name=rain HTTP/1.1Host: www.myhost.comCache-Control: no-cache 从上面的HTTP请求格式知，第一行为请求行，表明请求方式为GET，子路径为 /?id=1&amp;name=rain，HTTP版本为1.1。后两行为请求首部，Host为主机地址，Cache-Control为no-cache。因为GET,DELETE的请求参数都在URL中，所以请求数据为空。 1.2、PULL、POST的请求报文而对于PULL和POST来说，它们的报文格式一般是表单格式，也就是说请求参数存储在请求数据位置上： 123456789101112131415161718192021POST /local/ HTTP/1.1Host: www.myhost.comAccept-Encoding：gzipContent-Length: 222222Content-Type:multipart/from-data；boundary=dRGP2cPPTxE6WRTssnh4jC7HJLcSdeConnection：Keep-Alive--dRGP2cPPTxE6WRTssnh4jC7HJLcSdeContent-Disposition：from-data；name=“username”Content-Type：text/plain：charset=UTF-8Content-Transfer-Encoding: 8bitrain--dRGP2cPPTxE6WRTssnh4jC7HJLcSdeContent-Diaposition:from-data:name=&quot;image&quot;filename=&quot;/storage/emulated/0/image/1234.png&quot;Content-Type:application/octet-streamContent-Transfer-Encoding:binary图片二进制数据，在此省略...--dRGP2cPPTxE6WRTssnh4jC7HJLcSde-- 上述的请求含义是向 http://www.myhost.com/local/ 这个地址发送一个POST请求，请求的数据格式为multipart/from-data，报文的boundary值为dRGP2cPPTxE6WRTssnh4jC7HJLcSde，报文有两个请求参数：一个是名为username的文本，值为rain；一个是名为image的二进制参数，值为图片的二进制数据。 请求参数是以两个横杠（–）加上boundary开始的，然后是请求参数的一些首部属性，如参数名，格式等，然后加上一个空行，最后才是参数的值，如上述的username=name，其表示如下： 123456--dRGP2cPPTxE6WRTssnh4jC7HJLcSde //两横杠加boundaryContent-Disposition：from-data；name=“username”//以下三个参数是首部属性Content-Type：text/plain：charset=UTF-8Content-Transfer-Encoding: 8bit //不可省略的空行rain //参数值 POST和PULL都要遵守这种格式，每个参数以两横杠加boundary分隔，参数首部与值之间有一个空行。 请求数据的最后是以两个横杆+boundary+两个横杠结束作为整个报文的结束符，如上面报文的图片二进制数据最后的- -dRGP2cPPTxE6WRTssnh4jC7HJLcSde- -，如下： 12345678--dRGP2cPPTxE6WRTssnh4jC7HJLcSdeContent-Diaposition:from-data:name=&quot;image&quot;filename=&quot;/storage/emulated/0/image/1234.png&quot;Content-Type:application/octet-streamContent-Transfer-Encoding:binary图片二进制数据，在此省略...--dRGP2cPPTxE6WRTssnh4jC7HJLcSde-- //整个报文的结束符 2、响应报文一个HTTP的响应报文通常由状态行、响应头部、空行(CR + LF)、响应主体组成，如下： 状态行 在响应报文中粗略的说明了报文的执行结果。 响应头部 又叫首部字段，起始行后由零个或多个首部字段，每个字段包含一个key和value，首部以一个CR + LF结束，如果再细分，首部字段又可以分为响应首部字段、通用首部字段和实体首部字段。 响应主体 在响应主体中装载了服务端要返回给客户端的数据。 可以看到响应报文与请求报文的格式类似，最大的不同的就是第一行用状态信息代替了请求信息，格式如下：1HTTP-Version Status-Code Reason-Phrase CRLF 其中HTTP-Version代表HTTP协议版本，Status-Code代表响应状态码，Reason-Phrase代表状态码的文本描述，其中状态码的5种取值范围如下： 取值范围 含义 100~199 表示请求已被接收，继续处理 200~299 表示请求已被成功接收，理解，接收 300~399 重定向，要完成请求必须要进一步的操作 400~499 客户端错误，表示请求有语法错误或请求无法实现 500~599 服务端错误，表示服务器未能实现合法的请求 例如这是一个GET请求的返回的响应报文格式：123456HTTP1.1 200 OKData:Sat, 30, Dec 2006 23:23:00 GMTContent-Type:text/plain；charset=UTF-8Content-Length:14&#123;data:这里是返回结果&#125; 上面表示，响应状态码为200，表示请求成功，返回数据类型为text/plain，编码为UTF-8，内容长度为7，空行之后就为返回的数据。 2.1、常见的状态码 200 OK：客户端请求成功 400 Bad Request：客户端请求有语法错误，不能被服务器理解 401 Unauthorized：请求未授权 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 Not Found：请求资源不存在 500 Internal Server Error：服务器发生不可预估的错误 503 Server Unavailable：服务器当前不能处理客户端请求，一段时间后可能恢复正常 常见的首部字段这里列举了一些在请求报文和响应报文中常见的首部： Content-Type：请求数据的格式 Content-Length：消息长度 Host：请求的主机名 User-Agent：发出请求的浏览器类型，可以自行设置 Accept：客户端可识别的内容类型列表 Accept-Endcoding：客户端可识别的数据编码 Connection：允许客户端和服务端指定与请求/响应连接相关的选项，如设置为Connection：Keep-Alive，表示保持连接 Transfer-Encoding：告知接收端为了保证报文的可靠传输性，对报文采用了什么的编码方式 1、Connection ：Keep-Alive工作原理 (长连接)从HTTP/1.1起，默认都开启了Keep-Alive保持连接特性，简单地说，当一个网页打开完成后，客户端和服务端之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务端上的网页，会继续使用这一条已经建立的TCP连接，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同服务器软件中设置这个时间。 那么，长连接是如何工作的呢？长短连接是运输层（TCP）的概念，HTTP是应用层协议，它只能说告诉运输层我打算一段时间内复用TCP通道，而没有自己去建立、释放TCP通道的能力。那么HTTP是如何告诉运输层复用TCP通道的呢？分为以下几个步骤： 客户端第一次发送请求报文时，顺带发送一个Connection: keep-alive的Header，表示需要保持连接，同时客户端可以顺带发送Keep-Alive: timeout=5,max=100这个Header给服务端 然后服务端识别Connection: keep-alive这个Header，并且通过响应报文Header带同样的Connection: keep-alive，告诉客户端我可以保持连接 客户端和服务端之间通过保持的通道收发数据 当客户端最后一次发送请求报文，顺带发送Connection：close这个Header，表示长连接关闭 Keep-Alive: timeout=5,max=100表示TCP连接最多保持5秒，长连接接受100次请求就断开，长连接虽好，但是长时间的TCP连接容易导致系统资源无效占用，浪费系统资源，所以需要有一些限制。 结语网络请求已经成为了一个应用最基本的部分，所以熟悉HTTP对于我们开发很重要，我们不仅会用开发环境提供给我们的API，还要属性它的原理，这样开发才能做到胸有成竹。 参考资料： Web的工作方式 HTTP1.0、HTTP1.1 和 HTTP2.0 的区别 深度解密 HTTP 通信细节","tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]}]